<html><head><title>Jun00: Java Q&A</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Can You Implement COM  Components Using Java?</h1><p><i>Dr. Dobb's Journal</i> June 2000</p><h3>By Jacob Gsoedl</h3><I>Jacob is a corporate MIS manager. He can be reached at jgsoedl@ix.netcom.com.</I><hr><p>Until the late 1980s, applications were predominantly written in procedural programming languages such as C and Pascal. These languages only had primitive mechanisms to facilitate code reusability. Object-oriented languages such as C++ and Java introduced the concepts of classes, encapsulation, inheritance, and polymorphism to make it easy for programmers to develop reusable source code. However, with the exception of Java, object-oriented programming languages such as C++ provide little to develop reusable binary objects. Being able to share binary components between multiple applications is referred to as "component-based programming" and Microsoft's Component Object Model (COM) is one approach for implementing reusable binaries that can be shared between applications across systems.</p><p>Today, most COM components are implemented in C++ and Visual Basic. In this article, however, I'll examine how you can implement COM components in Java. </p><DDJADVERTISEMENT INLINE><h3>Pros and Cons of  Java-Based COM Components</h3><p>Why would you use Java to create COM components? First of all, Java is a great language to work in. Unlike Visual C++, it enforces object-oriented programming. It is more powerful than Visual Basic, but not as hard to learn and use as Visual C++. If you have ever implemented a COM component in C++, you will agree that it is not a trivial task -- even if you take advantage of the Active Template Library (ATL).</p><p>One of the reasons for the reduced complexity is that the Microsoft Virtual Machine (MSVM) provides functionality that otherwise needs to be implemented by the client. For instance, the MSVM takes care of reference counting, eliminating the need for calling <i>AddRef()</i>. The Java garbage collection takes care of objects that are no longer in use. The MSVM aside, Visual J++ 6.0 and its wizards reduce the complexity of developing and using COM components.</p><p>On the downside, COM clients that use Java-based COM components need to have a compatible version of the Microsoft Java Virtual Machine (MSJVM) installed, which requires additional memory. Additionally, Java-based COM objects are still somewhat slower than components written in C++.</p><h3>The Microsoft Java Virtual Machine </h3><p>COM components and Java objects are quite similar. Both support the concept of classes and interfaces. A Java class or interface belongs to a package. A COM class or interface belongs to a COM library. A COM library is the equivalent of a Java package. In Java, the classpath defines the location of the class files that a VM can load. Unlike COM, which has one set of COM classes for all applications on the same system, each Java VM can have different class paths. Java classes are uniquely identified by their fully qualified class names, such as java.util.date. COM classes and interfaces on the other hand are uniquely identified by a 128-bit GUID.</p><p>Despite the similarities between Java and COM, they represent two different worlds. It is the MSJVM that brings the two worlds together. To invoke a Java class via COM, the MSJVM dynamically creates a COM wrapper object that exposes the functionality of the Java class. The Java VM provides a COM object with a v-table that is dynamically constructed to support standard COM interfaces such as <i>IUnknown</i> and <i>IDispatch</i>, as well as interfaces implemented by the Java class. </p><p>Java code is compiled into bytecode and cannot be called directly from languages such as Visual Basic, C++, and VBScript. To call functions in COM components written in Java, the COM client loads MSJava.dll, which executes the bytecode in the Java class file. If a Java COM component was packaged as COM DLL using Visual J++, the client loads the COM DLL file, which then loads MSJava.dll to execute the Java bytecode.</p><h3>Implementing Java Automation Objects Using <i>AutoIDispatch</i></h3><p>Since Microsoft VM 1.5, all Java objects are automatically COM objects. The Microsoft VM automatically presents a Java object as an <i>Automation</i> object through an <i>IDispatch</i> interface. This is called <i>AutoIDispatch</i>. If your component doesn't require a custom interface, and its primary use is in a scripting environment, you can use your Java class directly as a COM object without any programming. </p><p><A NAME="rl1"><A HREF="#l1">Listing One</A>(a) is the ADispatchSample .java example, which contains the <i>SayHi()</i> method and <i>curDate</i> property. To register the Java class file as a COM component, you need to compile the java file by executing <i>jvc ADispatchSample.java</i>, copy the resulting class file into the \winnt\ java\ trustlib directory of your web server, and register it as a COM object using the javareg .exe utility: <i>javareg /register/ class:ADispatchSample/progid:ADispatchSample</i>. The command javareg.exe will display the CLSID that was assigned to our component. <A NAME="rl1"><A HREF="#l1">Listing One</A>(b) is an Active Server Pages (ASP) example, which uses the <i>ADispatchSample</i> object.</p><p>AutoIDispatch has several drawbacks. Because it only implements an Automation interface, performance is limited. Another limitation of <i>AutoIDispatch</i> is that the VM does not associate any Type Library information with the COM object. Therefore, Java and Visual Basic clients, which both require Type Library information, cannot use <i>AutoIDispatch</i>-based Java COM components.</p><h3>Implementing a Java  COM DLL in Visual J++</h3><p><A NAME="rl2"><A HREF="#l2">Listing Two</A>(a) illustrates the tips.java sample file. Tips.java has two methods. <i>getComTips()</i> randomly returns tips about COM. <i>GetASPTips()</i> does the same for ASP. </p><p>To create the component, you need to create a new Project TipServer in Visual J++, and add the class <i>tips.java</i> to the project. After you enter the tips.java source code, go into the project properties and click on the COM tab. As displayed in <A NAME="rf1"><A HREF="0006mf1.htm">Figure 1</A>, select Automatically generate Type Library, and check the classes you want to be exposed as COM interfaces. As you can see in <A NAME="rl2"><A HREF="#l2">Listing Two</A>(a), Visual J++ puts a comment <i>@register.com {clsid clsid= 4F49E33D...}</i> at the beginning of the class file. This directive tells Visual J++ that the Java class file is a COM component, and it will automatically register it in the registry of the local system during compilation. Before you build the project, you need to set the output format to COM DLL.</p><p>After compiling the project, you find this new component in the local registry under the HKEY_CLASSES_ROOT\CLSID folder. Visual J++ automatically generated a CLSID, assigned a program ID (TipServer.tips), and created a DLL file that includes the Type Library information for the TipServer class. To register it on another machine, copy TipServer.dll into the windows\system(32) directory and run regsvr32.exe TipServer.dll. <A NAME="rl2"><A HREF="#l2">Listing Two</A>(b) shows an ASP example that uses the TipServer COM component.</p><p>If you look at the new component using the Visual J++ OLE View utility, it shows that you've just implemented an <i>Automation </i>object and, as such, it does not implement the fast Custom Interface. Additionally, it exposes all public methods of the Java class, including Java core functions such as <i>wait() </i>and <i>notify().</i></p><h3>Implementing an Existing Interface</h3><p>To overcome these limitations, you need to find a way to convince Visual J++ to implement an interface definition you provide. All COM component development typically starts with the interface definition. <A NAME="rl3"><A HREF="#l3">Listing Three</A> is the IDL file for a TipServer component that implements a Dual interface. As you can see, Dual interfaces are derived from <i>IDispatch</i>. A Dual interface implements both the fast v-table as well as the slow Automation calls. The GUIDs for the Interface, Type Library, and COM class in our DualTipServer.idl file were generated with the GUIDGEN.EXE Visual Studio utility. You use another Visual Studio tool, MIDL .EXE, to check the DualTipServer.idl file for errors: MIDL /Zs DualTipServer.idl.</p><p>To be able to use the interface just defined in Visual J++, you need to generate a Type Library file, using MIDL.EXE: MIDL /proxy nul /header nul /iid nul /dlldata nul /win32 DualTipServer.idl. You then copy the resulting TipServer.tlb file into the Visual J++ project directory. After you create a new project in Visual J++, right-click the TipServer project, press the COM Classes tab, and click Use Existing Type Library, as in <A NAME="rf1"><A HREF="0006mf1.htm">Figure 1</A>. You browse to the TipServer.tlb file, which has just been copied into the project directory. Before you exit the project property page, set the output format to COM DLL.</p><p>As you can see in <A NAME="rf2"><A HREF="0006mf2.htm">Figure 2</A>, Visual Studio has now added IDualTipServer.java,  IDualTipServerDefault.java, as well as tips.java to the project. The first two Java files define the interfaces of the component. Each interface method is preceded with the @com.method Directive. It marks a Java method as a COM interface, which should be exposed in the object's v-table and dispatch table. Visual J++ evaluates the COM directives during compile time to register the component properly. The tips.java file provides a default implementation for <i>GetComTips()</i> and <i>GetASPTips()</i>. You need to replace the default implementation for these two methods with the source code. <A NAME="rl4"><A HREF="#l4">Listing Four</A> shows the final tips.java file.</p><h3>Calling a COM Component from Java</h3><p>You are now able to create Java-based COM components with Automation, Custom, or Dual Interfaces. However, the method for calling COM objects within Java applications has yet to be discussed.</p><p>As you have seen, a COM object provides a pointer to a function table (v-table). However, Java doesn't support the concept of pointers. As a result, the v-table pointers cannot be accessed directly in Java. Fortunately, the MSVM creates a Java object that represents the COM object. Whenever you call one of the Java object methods, the MSVM translates the Java method call into a COM function call. </p><p><A NAME="rl5"><A HREF="#l5">Listing Five</A> shows a simple Java application that calls the COM object methods implemented in <A NAME="rl1"><A HREF="#l1">Listing One</A>(a). To create the application, you need to open a new Console Application project in Visual J++ and add the Java class displayed in <A NAME="rl5"><A HREF="#l5">Listing Five</A> to the project. You then select the Add COM Wrappers page from the Project menu. This page then displays the Type Library files of all COM components installed on the local system. Next, check the TipServer Type Library implemented in the second example, and click OK. You will notice that Visual J++ adds the <i>tips.java </i>and <i>tips_Dispatch.java </i>COM wrapper class files to the project. The COM wrapper class files are vital, because this Java application will call all COM interfaces and classes through them. Visual J++ automatically creates Java wrapper classes and interfaces for each COM class and interface that exists in the COM library that's added to the project.</p><h3>COM+ and Windows 2000</h3><p>COM+, the next version of COM, is an integral part of Windows 2000. Microsoft has added several features to COM+, making it a more robust and scalable technology.</p><p>For instance, Transaction Server is now an integral part of Windows 2000. Since its first release, one of Transaction Server's main responsibilities was managing COM components. It enables just-in-time activation and object pooling, two technologies that make COM+ a scalable solution. Transaction Server maintains a pool of objects that are shared by COM+ clients. Instead of creating a new instance for each client that requests a new object, Transaction Server assigns an object from a pool that is shared by all clients. Even better, when a COM client instantiates a COM object, COM+ creates a virtual context object and returns a reference to it, rather than a reference to the component itself. When the component is accessed, Transaction Server assigns an object from the component pool to the context object. As soon as the object is idle (not accessed) the object is returned to the pool to be used by other clients. To a COM client, it looks as if it still possesses the object, although it only owns the Context Object, which takes little resources. </p><p>For busy applications, just-in-time activation and object pooling may not be sufficient to handle the workload. Therefore, COM+ implemented component-level load balancing, which allows distributing the workload among multiple servers in a network. It also provides redundancy. If a client has a reference to a component on a server that goes down, COM+ automatically routes a client request to another server that belongs to the application cluster.</p><p>Like Transaction Server, Microsoft Message Queue Server (MSMQ) is part of Windows 2000. Using queued components, a client can easily execute methods against COM+ components, even if that component is currently unavailable. </p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>(a)// Source Code Startimport java.util.Date;class ADispatchSample{      public String SayHi(){          return("Hi Dr.Dobb's reader!");      }      public Date curDate = (Date)new Date();}<b>(b) </b>File name:   ADispatchTest.asp-------------------------------&lt;%@ LANGUAGE="VBSCRIPT" %&gt;&lt;html&gt;&lt;head&gt;        &lt;title&gt;ADispatchTest&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%     Set objADispatch = CreateObject("ADispatchSample")%&gt;&lt;%= objADispatch.SayHi()%&gt;&lt;br&gt;&lt;br&gt;&lt;b&gt;Today's date is:&lt;/b&gt;  &lt;%= objADispatch.curDate %&gt;&lt;%  Set objADispatch = Nothing  %&gt;&lt;/body&gt;&lt;/html&gt;</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>(a)/** @com.register ( clsid=4F49E33D-A813-4171-97D9-EEE7AD9C2F69, typelib=136C0E92-AF90-4365-8071-47D52152762B ) */public class tips{    private static String[] ComTips = {     "An Automation interface is slower than a Custom Interface",     "All COM objects are derived from IUnknown",     "IUnknow Methods: QueryInterface(),AddRef() and Release()",     "IDispatch Methods: GetIDsOfNames,Invoke(),GetTypeInfoCount,GetTypeInfo",     "COM components can implement a 'Custom Interface',                                     Automation Interface or Dual Interface",     "A GUID is 128bit unique identifier for a COM component",     "If a progid is defined for a COM object, it can be used instead                                     of a CLSID to instantiate a COM object",     "COM+ is the next incarnation of COM. It is part of Windows 2000"    };    private static String[] ASPTips = {        "ASP stands for Active Server Pages",        "The Response object returns information to the client!",        "The Request object is used to get information from the client!",        "ASP is used to call COM components from a scripting language",        "The VBScript and JavaScriptscripting engine are part of Windows",        "ASP supports sessions to maintain state information",        "ASP sessions use cookies to maintain state"    };    public String getComTip(){        return getTip(ComTips);    }    public String getASPTip(){        return getTip(ASPTips);    }    private String getTip(String[] source){        int index = (int)(Math.random() * source.length);        return source[index];    }}<b>(b)</b>&lt;%@ LANGUAGE="VBSCRIPT" %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Tips Test&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%     Set objTip = CreateObject("TipServer.tips")%&gt;&lt;b&gt;COM Tip:&lt;/b&gt;&lt;br&gt;&lt;%= objTip.GetCOMTip()%&gt;&lt;br&gt;&lt;br&gt;&lt;b&gt;ASP Tip:&lt;/b&gt;&lt;br&gt;&lt;%= objTip.GetASPTip()%&gt;&lt;%  Set objTip = Nothing %&gt;&lt;/body&gt;&lt;/html&gt;</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three </H4><pre>import "oaidl.idl";import "ocidl.idl";[   object,  uuid (3D7BFA13-EBF9-418c-B6A8-F2182E7AA03E),  dual,  helpstring("IDualTipServer Interface"),  pointer_default(unique)]interface IDualTipServer : IDispatch{   HRESULT getComTip([out, retval] BSTR* ret);   HRESULT getASPTip([out, retval] BSTR* ret);  };[   uuid (7AF622C6-BD7F-4638-AB1B-82537FEABB38),   version(1.0),   helpstring("DualTipServer 1.0 Type Library")]library DualTipServerLib{   importlib("stdole32.tlb");   importlib("stdole2.tlb");   [      uuid (FF551EA5-812B-4297-8068-118ADE65E718),      helpstring("DualTipServer Class")   ]   coclass tips   {      [default] interface IDualTipServer;   }};</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>// Auto-generated using JActiveX.EXE 5.00.2918//   ("C:\Program Files\Microsoft Visual Studio\VJ98\jactivex.exe"           /javatlb /c2j /creg /xh /wfc  /w /xi /X:rkc /l           "C:\DOCUME~1\JGsoedl\LOCALS~1\Temp\jvc44.tmp" /nologo /d           "C:\Documents and Settings\JGsoedl\My Documents\Visual Studio            Projects\DualTipServer" "C:\Documents and Settings\JGsoedl\My Documents\Visual Studio Projects\           DualTipServer\DualTipServer.tlb")//// WARNING: Do not remove the comments that include "@com" directives.// This source file must be compiled by a @com-aware compiler.// If you are using the Microsoft Visual J++ compiler, you must use// version 1.02.3920 or later. Previous versions will not issue an error// but will not generate COM-enabled class files.package dualtipserver;import com.ms.com.*;import com.ms.com.IUnknown;import com.ms.com.Variant;/** @com.register(clsid=FF551EA5-812B-4297-8068-118ADE65E718,     typelib=7AF622C6-BD7F-4638-AB1B-82537FEABB38, version="1.0",     description="DualTipServer Class")*/public class tips implements IUnknown,com.ms.com.NoAutoScripting,    dualtipserver.IDualTipServerDefault{    private static String[] ComTips = {     "An Automation interface is slower than a Custom Interface",     "All COM objects are derived from IUnknown",     "IUnknow Methods: QueryInterface(),AddRef() and Release()",     "IDispatch Methods: GetIDsOfNames,Invoke(),GetTypeInfoCount,GetTypeInfo",     "COM components can implement a 'Custom Interface',                                Automation Interface or Dual Interface",     "A GUID is 128bit unique identifier for a COM component",     "If a progid is defined for a COM object, it can be used instead                                of a CLSID to instantiate a COM object",     "COM+ is the next incarnation of COM. It is part of Windows 2000"    };    private static String[] ASPTips = {        "ASP stands for Active Server Pages",        "The Response object returns information to the client!",        "The Request object is used to get information from the client!",        "ASP is used to call COM components from a scripting language",        "The VBScript and JavaScriptscripting engine are part of Windows",        "ASP supports sessions to maintain state information",        "ASP sessions use cookies to maintain state"    };    public String getComTip() {        return getTip(ComTips);    }    public String getASPTip() {        return getTip(ASPTips);    }    private String getTip(String[] source){        int index = (int)(Math.random() * source.length);        return source[index];    }}</pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five</H4><pre>/** This class can take a variable number of parameters on the command line. * Program execution begins with the main() method. Class constructor is not  * invoked unless an object of type 'Class1' created in the main() method. */import tipserver.*;public class Class1{    /** The main entry point for the application.      * @param args Array of parameters passed to the application     * via the command line. */   public static void main (String[] args)    {        tips objTips = new tipserver.tips();        String aspTip = objTips.getASPTip();        String ComTip = objTips.getComTip();        System.out.println("\n\nToday's ASP Tip: " + aspTip);        System.out.println("Today's COM Tip: " + ComTip + "\n\n");    }}</pre><P><A HREF="#rl5">Back to Article</A></P></body></html>