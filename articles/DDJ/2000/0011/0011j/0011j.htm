<html><head><title>Nov00: WebDAV, IIS,  & ISAPI Filters</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>WebDAV, IIS,  &amp; ISAPI Filters</h1><p><i>Dr. Dobb's Journal</i> November 2000</p><h2>Extending the HTTP protocol</h2><h3>By Martin Hallerdal</h3><I>Martin is a consultant for the Scandinavian Internet Technology. He can be contacted at marty@site.se.</I><hr><p>Sharing information is one of the major features of the InteFrnet and the World Wide Web. But when it comes to ways of dealing with the flow of information in a structured and safe manner, there's room for improvement. While HTTP has been great for retrieving data, it lacks support for file locking, custom file/directory properties, directory creation, and file/directory copying and deletion -- all of the things you can do on your computer. In this article, I will introduce you to Web-based Distributed Authoring and Versioning (WebDAV) and the ISAPI filter architecture by implementing a filter with some rough WebDAV capabilities.</p><p>The WebDAV specification defines a set of extensions to the HTTP protocol that lets you collaboratively edit and manage files on remote web servers. One way to look at it is that WebDAV makes a web site look like a local drive on your computer. In other words, WebDAV is essentially the HTTP protocol, with some additional methods and headers, which makes it possible to access a web server in a way similar to that in which you use directories and files on your PC. And with its support for locking and versioning of files, WebDAV also becomes a tool for collaboration. <A NAME="rt1"><A HREF="0011jt1.htm">Table 1</A> lists these WebDAV extensions to HTTP. I use the term "WebDAV method" to refer to an extension that is available with WebDAV, but not HTTP.</p><DDJADVERTISEMENT INLINE><p>Tools such as FrontPage and NaviPress also extend the HTTP protocol to achieve some of these functions. However, they've done so in a proprietary way that makes communication between products from different vendors impossible. WebDAV, on the other hand, is managed by an IETF working group (http://www.webdav.org/) and is supported by Microsoft, Netscape, and many other companies. In fact, Microsoft has implemented WebDAV in Internet Explorer 5, Web Folders, and Internet Information Server 5.</p><h3>The ISAPI Filter Architecture</h3><p>A common web-server feature is the ability to let you add (or modify) functionality using plug-ins. Microsoft's Internet Information Server (IIS) 4 is no exception. For this purpose, Microsoft developed the Internet Server API (ISAPI), which lets you extend any ISAPI-compliant web server, including Microsoft's own Internet Information Server.</p><p>There are two different types of ISAPI components -- extensions and filters. Extensions are like CGI scripts that are called when the client has completed its request and are referenced with a normal URL (for example, http://myserver.se/myextension .dll). Filters, on the other hand, are more interesting. Unlike extensions, you cannot call a filter directly. Instead, it receives notifications from the web server when certain events occur (see <A NAME="rt2"><A HREF="0011jt2.htm">Table 2</A>) in the lifetime of a client request. When the IIS service is started, the filter is loaded into memory and informs the web server about the type of events it would like to get notification for, the priority the server should give that filter, and whether the filter should be notified under a secure connection. (I use the term "interested filter" to refer to filters that have registered for notifications for one or more given events.) Both extensions and filters are compiled into DLLs and installed using Internet Service Manager.</p><p>To simplify ISAPI development, you can use MFC, which has a number of support and wrapper classes. To build an ISAPI filter, you would extend the class <i>CHttpFilter</i>, then override the notification functions that you have registered interest in. I use MFC in the filter I build in this article. The complete source code for this filter is available electronically; see "Resource Center," page 5.</p><p>ISAPI components run in the same address space as the HTTP server so there is usually little overhead in calling them. This also means that they inherit many attributes from their parent process -- the HTTP server process -- such as its security context and the fact that they run in a service context. Additionally, this also means that all code must be thread safe because IIS can serve multiple concurrent connections to a resource. If you use MFC, you can use its synchronization classes to resolve that problem.</p><p>Here's how a typical request might manifest itself with different notifications to the interested filters: First, IIS reads a block of data and notifies interested filters with an <i>OnReadRawData</i> notification. This block will contain the request line and some headers. In most cases, the block size will be sufficiently large to contain all the headers. In some cases, it also contains some request body data. If all headers weren't included in the block, IIS reads as many blocks as it takes to include all the headers. With every block it reads, it also notifies interested filters with <i>OnReadRawData</i>. When all headers have been received, the server parses the headers and notifies interested filters with <i>OnPreProcHeaders</i>. This allows a filter to inspect, change, and add headers. Then IIS notifies interested filters with <i>OnUrlMap</i>, which indicates that IIS has mapped the resource in the request line to a physical path on the server. The filter can change this physical path if it so desires. If the client has supplied a request body, it is read. This results in one or more notifications of type <i>OnReadRawData</i> to interested filters. Additionally, there are a few more notification types that involve events such as authentication and logging. If you are interested in them, see the ISAPI filter documentation (http:// msdn.microsoft.com/ library/psdk/iisref/isgu3vn7.htm).</p><p>Two arguments are given to every notification function. The first is always an instance of the <i>CHttpFilterContext</i> class, which is basically a wrapper around the HTTP_FILTER_CONTEXT structure. This object provides services that let the filter communicate with its context, such as getting a particular server variable or writing raw data to the client. The second argument is a pointer to a structure, which is specific for every type of notification. In <i>OnReadRawData</i>, for example, you receive a pointer to an HTTP_FILTER_RAW_ DATA structure that contains the data that has been read from the client.</p><p>The return code of every notification function tells IIS how to proceed with the notification chain. For example, the filter could instruct the server to close the connection with the client, it could ask the server to read another block of data from the client, or just tell the server to notify the next filter.</p><h3>The Filter Implementation</h3><p>WebDAV consists not only of the methods in <A NAME="rt1"><A HREF="0011jt1.htm">Table 1</A>, but also of the entire HTTP 1.1 protocol. You could say that WebDAV extends HTTP in the same way that a Java class can extend another class. WebDAV contains all the HTTP functionality, and many of the new functions share traits with the old functions. For example, if a client requests an HTTP property (such as an ETag or Content Type) for a resource in a PROPFIND request, they must be identical to the ones returned by a GET or HEAD. In this case, these latter methods will be implemented by IIS and the new methods such as PROPFIND are implemented by our filter, so you need a tight integration with IIS to find out what Content Type or ETag a certain resource has. It turns out that this information can sometimes be impossible to retrieve in an efficient manner.</p><p>To serve a WebDAV request, you need to have access to the complete request, which consists of two things: the request headers and the request body. Unfortunately, the ISAPI filter architecture does  not have an event type that informs you when the HTTP server has read all the headers and the entire body and gives you access to this data. Instead you have to rely primarily on <i>OnReadRawData</i>, <i>OnPrecProcHeaders</i>, and <i>OnURLMap</i> for this purpose.</p><p>But recall that data from the request can be scattered across many calls to <i>OnReadRawData</i>. How do you patch all of these blocks together? The answer can be found in one of the members of <i>CHttpFilterContext</i>. In contrast to <i>CHttpFilter</i> (which is only instantiated once), a new <i>CHttpFilterContext</i> object is created for every TCP session with a client. The structure that <i>CHttpFilterContext</i> wraps, HTTP_ FILTER_CONTEXT, is exposed as a public member variable in <i>CHttpFilterContext</i> and contains a void pointer. This pointer can be used for any context information that the filter wants to associate with a particular request. This lets you keep a context object for every request, which can contain all the data you have accumulated for that particular request, as well as other information for that request.</p><p>However, <i>OnReadRawData</i> is called for every type of request. The filter should only handle WebDAV requests. As much as you might respect the original HTTP methods, you don't want anything to do with them for performance reasons. These methods are implemented by IIS and any interference by you will slow down the process. So what you need is a way to identify a WebDAV request as early in the request process as possible, and step out of the way if it isn't. This can be done in <i>OnPreProcHeaders</i>, which lets you inspect the headers of the request including the request method. If the method is a WebDAV method, you can set a flag in the context object indicating to <i>OnReadRawData</i> that this is a WebDAV method and that it should copy the data it receives from now on.</p><p>However, there is still a problem. The block of data contained in the <i>OnReadRawData</i> event just before <i>OnPreProcHeaders</i> can also contain request body data in addition to header data. So if you decide that you're interested in the request in <i>OnPreProcHeaders</i>, you might have missed some data.</p><p>A solution is to have <i>OnReadRawData</i> collect data by default. And if processing in <i>OnPreProcHeaders</i> reveals that the method is a standard HTTP method, then we set a flag telling <i>OnReadRawData</i> to ignore the rest of the data for this request. When the request has finished, you reset the flag. How do you know when a request has ended? You don't, because IIS gives filters notification when the TCP connection has been closed -- not when a request has ended. And multiple requests can be sent over one connection through the use of HTTP Keep-Alives. A possible resolution would be to disable Keep-Alives on the server, though this is not an acceptable solution.</p><p>It seems then that the only way out is to copy every incoming block of data in <i>OnReadRawData</i>. On the bright side, if you don't know for certain that the current method is WebDAV, you don't accumulate the data. Instead, you overwrite the old block. This approach assumes that all the header data will be included in the first block of data. The risk involved in this assumption will probably fade a bit when you consider that the amount of data that IIS attempts to read every time is 48 KB, which should be enough for any requests header data.</p><p>But there are still more problems. The HTTP method OPTIONS is used by the client to retrieve information concerning the communication abilities for a particular resource or for the server as a whole. As a response, the server can (and IIS does) return a <i>Public</i> header, which lists all the methods supported by the server, and an <i>Allow</i> header, which lists all the methods supported for a particular resource. Since the server now also handles WebDAV methods, you should include the names of these methods in the appropriate headers in an OPTIONS response. You must also include an additional DAV header telling the client that this is a WebDAV-compliant server. Although <i>CHttpFilterContext</i> provides a member function for adding headers to a response, <i>CHttpFilterContext::AddResponseHeaders</i>, it does not let you change an existing header.</p><p>One way of doing all of this is to handle the OPTIONS method yourself, just as you have done with the WebDAV methods. This seems excessive though, since all you really need to do is modify a couple of headers. An alternative is to flag for an OPTIONS request in <i>OnPreProcHeaders</i>. When IIS sends its response, you intercept it in <i>OnSendRawData</i>. Unfortunately, you cannot change the data that will be sent. But what you can do is copy the data to a temporary buffer, add the data you want, send the temporary buffer to the client using <i>CHttpFilterContext::WriteClient</i>, and return a value telling IIS that you have handled the notification and to refrain itself from sending the unmodified OPTIONS response to the client.</p><h3>The MetaBase and Active Directory</h3><p>ISAPI provides moderate integration with the web server. Using the <i>CHttpFilterContext</i> object provided with each notification function, you can retrieve the server variables defined by the CGI specification as well as some Microsoft-specific ones. You can also set the next read size, and add headers that will be included in a 401 Access Denied response. But that's basically it. For most filters, this will be more than enough. But for a filter like this, which operates extremely close with, and needs access to, many internals of the web server, you need more.</p><p>For example, consider the PROPFIND method. If a client requests the MIME type for a particular resource in a PROPFIND request, the filter would have to know how to map a file extension to a MIME type. Sure, the filter could have its own MIME map with the most common types. But this would not only be poor design, it would also be error prone. If users add another MIME type or change an existing MIME type in the IIS administration program, your filter would never know about it and return an invalid MIME type.</p><p>The solution is in the MetaBase, the database where IIS stores most of its configuration information. The MetaBase is organized in a hierarchical structure, much like the Windows Registry, with keys containing subkeys and properties. For that matter, much of what you can find in the Internet Service Manager is stored in the MetaBase. (For MetaBase details, see http:// msdn.microsoft.com/library/psdk/iisref/ aint94dh.htm.)</p><p>The MetaBase is accessed through Active Directory Service Interfaces (ADSI), a set of COM interfaces generalizing the capabilities that are offered by many different directory services such as LDAP and NDS from Novell. If you are familiar with Java Naming and Directory Interface (JNDI), ADSI basically provides the same functionality.</p><p>Both ADSI and JNDI are based upon the notion of providers that conform to a set of specifications and provide access to different directory services. Access to a directory object is given through the use of a URL, which also tells the Active Directory engine what provider is to be used. Every directory object also has an associated class, or schema class, which is to a directory object what the Java class <i>Class</i> is to a Java object. Through the schema class you can discover at run time what properties a directory object must contain, what properties a directory object may contain, if the directory object is a container (if it can contain other directory objects), and more. It is also possible for a schema class to be derived from other schema classes.</p><p>The IIS documentation reveals that the name of the schema class for the root object in the MetaBase is <i>IIsComputer</i>. Examining the documentation for that schema, you learn that directory objects of that type can contain an object of type <i>IIsMimeMap</i>, which always contains a property by the name of <i>MimeMap</i> -- a list of the <i>MimeTypes</i> known to the system. But this property is inheritable, which means that web servers, virtual directories, or even files can override this property in the MetaBase. This means that to perform a correct MIME type mapping, you must know which resource was requested and then traverse up the MetaBase tree looking for a match in every branch. Considering the effort required to implement this compared to the advantages gained, I have decided not to do this in this version. <A NAME="rl1"><A HREF="#l1">Listing One</A> presents the complete MIME mapping function.</p><h3>Conclusion</h3><p>There certainly remains a lot of work on the filter I present here to consider it a commercial alternative. The PROPPUT command is not implemented yet, memory pools need to be set up for efficiency purposes, certain parts of the code need to be made thread safe, and so on.</p><p></p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>/* Returns a mime type for a file NOTE: Not threadsafe */BOOL GetMimeType(char* szFile, char* szBuff) {//Find extension    char* szExt = szFile;    while(*szExt != '\0' &amp;&amp; *szExt != '.') {        szExt++;    }    //If we found it, search the MetaBase for it    if(*szExt != '\0') {        _bstr_t bstrExt(szExt);        static CComPtr&lt;IADs&gt; adMimeMap;        static bool bDidInit = false;        static bool bGoodObject = false;        static VARIANT vMimeMap;        HRESULT hr;        //Look up the mimemap object that IIS has        if(!bDidInit) {            bDidInit = true;            //Reference MimeMap object through a URL with "IIS" as provider            hr = ::ADsGetObject(L"IIS://LocalHost/MimeMap",                                              IID_IADs, (void**)&amp;adMimeMap);            if(SUCCEEDED(hr)) {                //Get the "MimeMap" property                ::VariantInit(&amp;vMimeMap);                hr = adMimeMap-&gt;GetEx(L"MimeMap", &amp;vMimeMap);                if(SUCCEEDED(hr)) {                    //It should be an array                    if(vMimeMap.vt &amp; VT_ARRAY) {                        bGoodObject = true;                    }                }            }        }            //Only proceed if we have a valid reference        if(bGoodObject) {            //Declare some nifty variables            long lIdx;            long lHigh;           _bstr_t bstrBuff;            BSTR bstrRaw;            CComQIPtr&lt;IISMimeType&gt; MimeType;                                VARIANT vElem;            ::VariantInit(&amp;vElem);            SAFEARRAY* pArrMimeMap = vMimeMap.parray;            //Get the upper and lower bounds of the array            ::SafeArrayGetLBound(pArrMimeMap, 1, &amp;lIdx);            ::SafeArrayGetUBound(pArrMimeMap, 1, &amp;lHigh);            //Loop through the array            while(lIdx &lt;= lHigh) {                hr = ::SafeArrayGetElement(pArrMimeMap, &amp;lIdx , &amp;vElem);                if(SUCCEEDED(hr)) {                    if(vElem.vt &amp; VT_DISPATCH) {                        //Each element in array should be of type IISMimeType                        MimeType = vElem.pdispVal;                        if(MimeType != NULL) {                            MimeType-&gt;get_Extension(&amp;bstrRaw);                            bstrBuff = bstrRaw;                            //Check if the extension matches                            if(bstrExt == bstrBuff) {                                MimeType-&gt;get_MimeType(&amp;bstrRaw);                                bstrBuff = bstrRaw;                                strcpy(szBuff, (char*)bstrBuff);                                MimeType.Release();                             return TRUE;                            }                                                    }                        MimeType.Release();                    }                }                lIdx++;            }   // Loop through elements        } //bGoodObject    }   //szExt != \0    *szBuff = '\0';    return FALSE;}</pre><P><A HREF="#rl1">Back to Article</A></P></body></html>