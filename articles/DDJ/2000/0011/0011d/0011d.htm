<html><head><title>Nov00: Security Analysis  & Design</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Security Analysis  &amp; Design</h1><p><i>Dr. Dobb's Journal</i> November 2000</p><h2>A strategy that's both practical and generic</h2><h3>By Uttara Nerurkar</h3><I>Uttara is a research associate in the Software Concept Laboratory at Infosys Technologies Limited. She can be contacted at uttaran@inf.com.</I><hr><p>Most analysis of system vulnerabilities require that analysts create a security-specific model of the application, which is quite distinct from the functional model of the system that analysts would already have handy. An example of this is the technique described by Bruce Schneier in "Attack Trees" (<i>DDJ</i>, December 1999). Largely because of this, practitioners resort to adding security from the outside, such as with firewalls and PKI. This normally takes care of threats posed by outsiders, but leaves room for insiders to compromise the system. In a product development scenario, the problem is compounded because the undocumented security features of a previous release can get inadvertently designed out in the next release. Distributed applications add another level of complexity to security analysis. All these instances point to the need to include security as one of the concerns in the functional analysis and design of the software itself.</p><p>I was faced with exactly this problem when developing a financial product. In the search for a solution, I put together a security analysis and design/modeling technique that closely couples the security and functional model of the product. While the model is based on my experience with financial software, it is sufficiently generic to be suitable for other business applications as well.</p><DDJADVERTISEMENT INLINE><p>The method broadly involves the following steps:</p><p>1.	Determine the scope of the problem; that is, the product and its environment.</p><p>2.	Partition this into zones having similar security concerns.</p><p>3.	Analyze each zone for vulnerabilities in a structured way by focusing on the different stages in the access and use of objects in the zone. </p><p>4.	Design countermeasures for each vulnerability and choose one or more of them based on their coverage and cost. </p><p></p><p>I call this model the "Onion Peel Model," with the security zones forming the "peels." Vulnerability analysis is done from the outside peel to the inside, as well as from the inside to the outside. At the risk of sounding similar to "Onion Routing," I have retained this name because it aptly describes the exposure of product zones from the inside versus outside.</p><h3>The Onion Peel Model</h3><p>Modeling starts with defining high-level security requirements (or the security policy) and a preliminary functional model. You can use existing guidelines for defining the security policy. For the functional model, any of the existing methodologies -- object-oriented analysis and design (OOAD) or structured system analysis and design (SSAD) -- can be used. </p><p>As in SSAD, the model begins with a context diagram depicting the system and its environment. The difference here is that I include the known physical components of the environment in the model, instead of considering only the logical ones as is done in a functional model. These components could include software components such as web servers, application servers, databases, and the like; and hardware components such as network cabling, satellite uplinks, and so on. The product and these identified components define the system that needs to be analyzed (the onion), and the diagram is called the "Onion Diagram."</p><p>The caveat when defining the onion is that the components that are not under your control (directly or indirectly) are not included inside the onion, but rather remain outside it. For example, it may be possible to utilize the security features provided by the database. In that case it is included in the onion. On the other hand, it may not be possible to assume attributes of commercially available off-the-shelf products. These then form the environment of the onion.</p><p>The onion is now partitioned into peels based on the similarity in the nature and criticality of the security concerns of the components. This ensures that you focus on similar and/or related security concerns during the analysis. Of course, the interactions of objects between peels should be minimized, and those within the peel should be maximized, but cohesiveness of security concerns takes first priority. The peels are documented in the Peel Diagram.</p><p>To illustrate, I define an Internet User Interface Peel consisting of the web interface of the application, where the concerns are that of controlling access, restricting sensitive data modification (like product prices), and so on. The network components, on the other hand, are placed in the Internet Communications Peel -- the issues here being network failure, intrusion, confidentiality, and the like.</p><p>To illustrate further, an e-commerce web site may need to secure its interaction with the payment system much more than its interface with the online customer. In that case, you should divide the mentioned Internet User Interface Peel into the Customer Interface Peel and the Payment System Interface Peel.</p><p>For a typical financial product, you can expect the following peels: Internet/Extranet User Interface, Internet/Extranet Communication, External Interfaces, External Interfaces Communication, Intranet User Interface, Intranet Communication, Product Services, Product Resources (this includes the physical elements of the product, such as scripts, executables, and so on), and Database and System Resources; see <A NAME="rf1"><A HREF="0011df1.htm">Figure 1</A>. The functional model is distributed over the User Interface peels and the Product Services Peel, the latter containing most of the business functions. </p><p>If the product services are distributed over several physical machines, the corresponding Communication Peel (Internet or Intranet) includes all the network components and services, the Product Services Peel will include all the distributed services; similarly, the Product Resources Peel and the System Resources Peel will include all the distributed machines.</p><p>In the beginning, you may not know much about the physical environment of the product. Details will start pouring in as the design proceeds. All that information needs to be fed back into the model and analyzed at checkpoints that you can define suitably. Also, as new modules are added/removed from the product, you can add/remove peels (or object sets, which are described in the next paragraph) from the model, thus taking care of maintenance and scalability.</p><p>Each peel is now further decomposed into object sets consisting of objects, again with similar security concerns and/or requiring similar levels of security. In the context of security, an object is defined as any logical or physical entity that contains information and can, therefore, be attacked (see "Role Based Access Control Models," by R. Sandhu, E.J. Coyne, H.L. Feinstein, and C. Youman, <i>IEEE Computer</i>, February 1996). I have extended that definition to include services, as they can also be compromised or shut down. The counterpart of the object is the subject: the entity trying to gain access to the object or change its state. </p><p>You may specify several levels of object sets for the purpose of abstraction, or more importantly, consider combined controls running across lower level object sets. As a rule of thumb, similar object types will comprise one object set. To illustrate, the External Interfaces Peel could consist of the object sets Online Messages and File Transfer; see <A NAME="rf2"><A HREF="0011df2.htm">Figure 2</A>. Since the objects are heterogeneous in nature, their security concerns are different (for example, alternative network routes for the former, and alternative file transfer mechanisms for the latter). However, similar security concerns will always take precedence over similar object types. For example, an authentication server along with its database, key management services, and so on, in the Internet Communication Peel will form a single object set since all its components are involved in providing a single service -- authentication. (Here a control, the authentication server, is defined as an object set. This is how the model will be recursively applied to ensure the security of the controls themselves.)</p><h3>The Levels of Penetration</h3><p>Now comes the difficult part -- exposing the vulnerabilities in the onion, the peels, and the object sets. It seems most logical to go about looking for vulnerabilities the way the attacker would (be a thief to catch a thief). Taking this approach, I have defined five Levels of Penetration (LOPs), which denote the different levels at which an attacker could gain control of an object. Another way of conceptualizing the LOPs is that they denote the different stages in the life cycle of an object from its birth to its death. Again, from the perspective of security, this seems to be the logical way of searching for concerns. </p><p>The LOPs, in increasing order of penetration, are as follows (note that I use the term "object" to denote the victim for the sake of simplicity. Depending on the level at which you are analyzing the model, the object would be the onion, a peel, or an object set):</p><ul>  <li>Inward Access (IA). This is the knock on the door or the breaking down of it. At this point, the object has to distinguish whether the access request emanates from an authorized subject, and accordingly allow access to the system. Typical controls at this level include authentication, detection of intrusion, logging of the user login time/ profile, and providing for recovery in case of an abnormal exit (this connects with the last Exit LOP).  <li>Authorization (AZ). Once the subject has been allowed access, you grant or deny permissions to it. These permissions determine the nature of operations allowed on the object: read, execute, create, update, or delete. Controls include Role-Based Access Control, Discretionary Access Control, Mandatory Access Control, or Sandbox.  <li>Operation (OO). The subject now operates on the object. The operation may need to be controlled to ensure a stable new state of the system, or it may just be monitored to provide a trail that can be analyzed later. Controls generally applied are integrity controls, covert channel analysis, trapping system faults, auditing, and ensuring availability.  <li>Outward Access (OA). This refers to the access requests that are made by the object to other objects inside or outside the onion. This is the LOP that accounts for most of the security loopholes in a product. The reason is that while designing the called object, it may not be possible to define all the access doors from calling objects. And while defining the calling object, the sensitivity profile of the called object may not be defined. This leads to access doors being left behind, allowing access in a way that was not envisaged. The Onion Model mandates that the designer cross-reference this LOP of an object with the Inward Access LOP of the called object. (Check out an example of such a bug found in Microsoft's Internet Explorer; see http://www.bugnet.com/: "IE5 Bug Parade Continues With JavaScript Redirect Danger," October 21, 1999.)  <li>Exit (EX). This LOP addresses the security considerations for normal and abnormal exits from the object. It loops back onto the Inward Access LOP to ensure that exit security is handled either at the time of destruction of the object or at the time of its creation. See Case 1 for an example of this. Typical controls here include hot standby, trusted recovery, and integrity controls.</ul><p>Using the aforementioned LOP technique, you can systematically analyze the onion, its peels, and the object sets one by one, and design countermeasures for the exposures you discover. Common or shared controls are likely from a higher level to a lower one; thus, an access control provided at the peel level may be sufficient for all the object sets under the peel. In that case, you just cross-reference the control from the peel in all the lower level object sets. For example, a firewall in the Internet Communication Peel may permit less stringent access control mechanisms in the back-end system. However, if you find that the controls run across peels or peer object sets, you probably need to review the peel or object set definition. Combining two peels and then splitting them into two object sets, or introducing a higher level object set will typically resolve the problem. If you run across a situation where it is absolutely impossible to do this, the model lets you cross-reference the two (see <A NAME="rf2"><A HREF="0011df2.htm">Figure 2</A> for an example of cross-referencing across LOPs).</p><p>Also, take into account the constraints imposed by external interfaces on your product and those that you want to impose on the others. These are documented in the LOP analysis as in <A NAME="rf2"><A HREF="0011df2.htm">Figure 2</A>.</p><p>As a final step, go over the completed model once more to combine, separate, or remove security controls across LOPs, object sets, and peels. Take their coverage and cost into account.</p><h3>Examples</h3><p>We applied this model to our financial product and discovered the following vulnerabilities.</p><p><b>Case 1:</b> <b>Failure Handling.</b> Files containing financial transactions on remote centers are generated at the end of every day and sent to the concerned center. These files are encrypted for the purpose of confidentiality. When the operation was modeled in the Product Services Peel and the Exit LOP was analyzed, it was discovered that under a system failure condition, the download process could fail before the file was encrypted. Even though the downloaded file was created in a secure area, this flaw was considered serious enough to necessitate other countermeasures; that is, file deletion under trappable failure conditions. The fact that some failure conditions may still not be trapped meant that I had to introduce another control: When the operation was restarted (IA LOP), the previous run's temporary files were deleted.</p><p>Case 2: Access Control. In the old system, it was possible for any user to access the (UNIX) OS prompt and run an executable. This was discovered while analyzing the IA LOP in the Product Resources Peel. Consequently, access to the OS prompt was restricted to specified trusted users only.</p><h3>Conclusion</h3><p>The Onion Peel Model provides a way of modeling security by extending the functional model of the system, instead of divorcing one from the other. It provides another way of discovering vulnerabilities in the system by following the path of the attacker from the birth to the death of the victim. The model is capable of handling distributed applications and provides maintainability and scalability.</p><p></p><p><b>DDJ</b></p></body></html>