<html><head><title>Nov00: Kerberos  Versus the Leighton- Micali Protocol</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Kerberos  Versus the Leighton- Micali Protocol</h1><p><i>Dr. Dobb's Journal</i> November 2000</p><h2>Deriving session keys from symmetric long-term keys</h2><h3>By Aviel D. Rubin</h3><I>Aviel is a researcher at AT&amp;T Labs and the author of an upcoming book on computer security. He can be contacted at rubin@ research.att.com.</I><hr><p>There are two ways to communicate securely over a computer network. The first is to have dedicated private lines that are inaccessible to anyone else. In general, this does not scale well for large networks. It is also expensive, not to mention unrealistic. The other way is with cryptography. </p><p>To secure data over unsecure networks, you must encrypt and authenticate it. Both these functions require secret keys, known only to legitimate communicating parties. It is common to refer to the legitimate communicating parties just mentioned as Alice and Bob. In a typical scenario, there are two categories of keys. The first category is long-term keys. Public/private key pairs can be used for long-term keys. However, there are cases where it is practical and more desirable to use symmetric keys instead. These keys are simply large random numbers known to both parties in the communication. The two advantages of symmetric keys over public/private keys are that encryption and authentication functions are much more efficient, and symmetric-key algorithms are not vulnerable to unexpected advances in mathematics. Such advances could render public-key systems useless. </p><DDJADVERTISEMENT INLINE><p>The second category of keys is session keys. These are the keys that operate directly on the data to encrypt and authenticate it. In this article, I'll explore the derivation of session keys from long-term keys. Imagine that Alice and Bob share a long-term symmetric key, <i>K<sub>AB</i></sub>. Establishing a session key is straightforward. One of them simply picks a random key and encrypts it with the long-term key and forwards it to the other. Unfortunately, in practice, there may be so many parties wishing to communicate that it is unreasonable to assume that they each share a long-term symmetric key with every other participant. Instead, a central, trusted authority is used to distribute session keys. Each user shares a long-term symmetric key with the trusted authority. The question is: How can Alice and Bob securely establish session keys by using the long-term keys they share with the trusted authority? Here, I'll examine two alternatives. The first is a well-established and widely deployed protocol called "Kerberos." The second is a little-known protocol that offers several advantages over more widely deployed systems. </p><h3>Kerberos </h3><p>The Kerberos system (see "Kerberos: An Authentication Service For Open Network Systems," by J.G. Steiner, B.C. Neuman, and J.I. Schiller, <i>Usenix Conference Proceedings</i>, February 1988) was designed for user authentication and the distribution of session keys in an open system with trusted hosts but an untrusted network. The protocol is based on earlier work by Needham and Schroeder (see "Using Encryption For Authentication In Large Networks Of Computers," by R.M. Needham and M.D. Schroeder, <i>Communications of the ACM</i>, December 1978). In Kerberos, principals establish long-term associations with an authentication server. Then, when they wish to establish a secure session with another user or a service, the authentication server generates a random key and assigns it to them. In Kerberos, it is more likely that Bob is a file server than an actual person. The Needham and Schroeder protocol is quite simple; the authentication server generates a random key for the two parties in each session. The interesting aspect of the protocol is the way in which the session keys are revealed to Alice and Bob. <A NAME="rf1"><A HREF="0011af1.htm">Figure 1</A> illustrates the Needham and Schroeder protocol, which is at the heart of Kerberos. It can be specified as follows: </p><blockquote><p>1.<i> A <IMG SRC="arrow10.gif" ALT="" WIDTH="10" HEIGHT="5"> S : A,B,N<sub>a</i></sub> </p><p>2.<i> S <IMG SRC="arrow10.gif" ALT="" WIDTH="10" HEIGHT="5"> A : {N<sub>a</sub>,B,K<sub>ab</sub>,{K<sub>ab</sub>,A}K<sub>bs</sub>}K<sub>as</i></sub></p><p>3. <i>A <IMG SRC="arrow10.gif" ALT="" WIDTH="10" HEIGHT="5"> B : {K<sub>ab</sub>,A}K<sub>bs</sub> </i></p><p>4. <i>B <IMG SRC="arrow10.gif" ALT="" WIDTH="10" HEIGHT="5"> A : {N<sub>b</sub>}K<sub>ab</sub> </i></p><p>5.<i> A <IMG SRC="arrow10.gif" ALT="" WIDTH="10" HEIGHT="5"> B : {N<sub>b</i></sub>-<i>1}K<sub>ab</sub></p></blockquote><p></i>In this protocol, <i>Kxy</i> represents the long-term key shared between <i>X</i> and <i>Y</i>. <i>A</i> and <i>B</i> represent Alice and Bob, respectively. In message 1, Alice sends a request to the server, <i>S</i> indicating that she wishes to communicate with Bob. The value <i>N<sub>a</i></sub> is a random number called a "nonce" and is included to link future messages to this request. The nonces in this protocol are not necessary in Kerberos because timestamps are used to prevent replay. This message is sent in the clear because it includes no security-related information. </p><p>In message 2, the server <i>S</i> responds with a session key, <i>K<sub>ab</i></sub>. A copy of the key is also encrypted under Bob's long-term key. In addition, <i>N<sub>a</i></sub> is included as a guarantee that this message is not a replay of a previous response. Each party is also told who will be on the other end of the secure channel. This can be seen by the inclusion of <i>A</i> in <i>{K<sub>ab</sub>,A}K<sub>bs</i></sub>. </p><p>In message 3, Alice forwards <i>{K<sub>ab</sub>,A}K<sub>bs</i></sub> to Bob, who can decrypt it and recover K<sub><i>ab</i></sub>. Bob then issues message 4 as a challenge to Alice to make sure that she possesses <i>K<sub>ab</i></sub>. In reality, Alice should also challenge Bob, but this was accidentally left out of the protocol. In message 5, Alice proves possession of the session key. </p><p>The Kerberos adaptation of the Needham and Schroeder protocol is in widespread use. Version IV was the first one to be widely deployed. The latest version is number V. It is part of the Andrew File System, and Kerberos has also been implemented in the Open Software Foundation Distributed Computing Environment (OSF DCE) and Windows NT. For information about the most recent version, instructions for obtaining the code, and many papers about Kerberos, see http://web.mit.edu/kerberos/www/. </p><h3>Problems with Kerberos </h3><p>Kerberos has been a great success. It is used in many locations around the world. While Version V corrects many of the problems in Version IV, the older version is still the one in predominant use. As such, it pays to take a look at some of the problems with Kerberos IV. There are also many lessons to be learned from what was done incorrectly. While the tone of this section is negative, it should be remembered that the designers and implementors of Kerberos did a great service to the community, and that their product is probably the most impactful security system in the real world, with the recent exception of SSL. </p><p>In 1991, Steve Bellovin and Michael Merritt published "Limitations Of The Kerberos Protocol" (<i>Proceedings of USENIX Winter Conference</i>, 1991). This is an excellent account of what is right and wrong with Kerberos from a security perspective. Many of the changes that were made to Kerberos were direct results of this paper. </p><p>Some of the problems in Kerberos IV are due to environmental factors. In Kerberos IV, the keys used by the users for various services are cached locally. However, in diskless environments, the /tmp directory, where the keys are cached, is on a file server, so the keys actually travel across the network. However, the purpose of Kerberos was to design a system that is secure against an adversary who controls the network. Another problem with this is that it means only one user should be on a workstation at a time. While this was a reasonable model for MIT, where Kerberos originated, it does not work in all environments. The reason is that most workstations do not come with local storage and access that can be partitioned among several users. </p><p>Another weakness of Kerberos IV is that it is vulnerable to replay attacks. An authenticator, which is a message encrypted by a client to prove knowledge of a key, is valid for about five minutes. In the 1985 unpublished manuscript "A Weakness In The 4.2BSD UNIX TCP/IP Software," Robert Morris showed that this is plenty of time to spoof a TCP connection, if the attacker sets it up in advance. Yet another limitation pointed out by Bellovin and Merritt is that Kerberos relies on clocks that are roughly synchronized, despite the fact that many time services, especially the ones in predominant use, are unauthenticated. </p><p>One of the most interesting attacks against Kerberos IV results from the fact that users tend to pick poor passwords (see "Password Security: A Case History," by Robert Morris and Ken Thompson, <i>CACM</i>, November 1979). The third message in the Needham and Schroeder exchange is called a "ticket" in Kerberos. There is a special server called a "Ticket Granting Server" (TGS) that has access to the Kerberos database of long-term keys. It is responsible for issuing tickets for services, such as the file system, to clients. When a client requests a ticket for a service, the ticket is returned from the TGS, encrypted under the long-term password between that client and the TGS. How does the client obtain this key it shares with the TGS? The authentication server sends a ticket for the TGS, in much the same way that tickets are issued for services. There is one exception, however, the client does not have to prove possession of the key. For example, if Bob wishes to obtain a ticket for the TGS, the following conversation takes place between him and the Authentication Server (AS):</p><blockquote><p>1.<i>B <IMG SRC="arrow10.gif" ALT="" WIDTH="10" HEIGHT="5"> AS : B,TGS</i></p><p>2.<i>AS <IMG SRC="arrow10.gif" ALT="" WIDTH="10" HEIGHT="5"> B : {K<sub>B,TGS</sub>,TKT<sub>B,TGS</sub>,Time}K<sub>B,AS</sub> </i></p></blockquote><p>Bob asks the AS for a ticket to talk to TGS. The ticket, and a session key are returned to Bob, encrypted under <i>K<sub>B,AS</i></sub>, which is the long-term session key between Bob and the AS. This key is derived from Bob's long-term Kerberos password. The problem arises from the fact that the Time, and other information's format that is known in advance is included in the message as well. Now, an attacker, Charlie, can do the following: </p><blockquote><p>1. <i>C <IMG SRC="arrow10.gif" ALT="" WIDTH="10" HEIGHT="5"> AS : B, TGS</i></p><p>2. <i>AS <IMG SRC="arrow10.gif" ALT="" WIDTH="10" HEIGHT="5"> C : {K<sub>B,TGS</sub>,TKT<sub>B,TGS</sub>,Time}K<sub>B,AS</i></sub></p></blockquote><p>Charlie pretends to be Bob, and asks the AS for a ticket for TGS. The AS complies, without authenticating Bob, and sends Bob a ticket-granting ticket, encrypted under Bob's long-term key. Charlie can now search for Bob's password offline. The easiest way is to construct a dictionary of all possible passwords that can be generated on a computer. For each password, Charlie uses the <i>string-to-key</i> function of Kerberos to generate a key, and then tries to decrypt message 2. If, after decryption, the location where the Time is supposed to be contains a valid time, Charlie probably found the key. </p><p>The reason this attack works is that Kerberos IV is willing to hand a ticket-granting ticket, encrypted under the user's password, to anyone who asks for it. A simple way to prevent this is to require the client to encrypt a random challenge from the server using the long-term key. If the client succeeds, he has proven possession of the key, and the ticket can be sent, encrypted under that key. This is the approach recommended by Bellovin and Merritt and adopted in Kerberos V.</p><p>There are other problems with Kerberos as well. The AS must be online most of the time. Anytime users wish to obtain tickets for a service, they must contact the AS. Also, the AS is a central point of attack. All of the user's keys are stored there. While they are stored encrypted under a master key, that master key must always reside in memory, so that user keys can be accessed. Thus, physical security is required for the authentication server. </p><p>In addition to these protocol-level attacks, it turns out that all of the existing implementations of Kerberos contain buffer overflow bugs. These can potentially be exploited to circumvent any security offered by the system, and probably introduce additional security threats that did not exist before Kerberos was used. </p><h3>Another Approach </h3><p>Buried in the cryptoliterature is a wonderful protocol by Leighton and Micali (see "Secret-key Agreement Without Public-key Cryptography," by Tom Leighton and Silvio Micali, <i>Advances In Cryptology: Proceedings of Crypto '93</i>, 1994) that has several advantages over Kerberos. Perhaps the protocol has not been widely adopted because it is a bit more mathematically complex than Needham and Schroeder's protocol, or perhaps it is due to patent issues. In any case, it is a protocol worth understanding. </p><p>There are several advantages to Leighton-Micali. First of all, it does not require that the Trusted Authority (TA) be available at all times. The TA creates a directory that can be made public, and from then on, each party can look up information in the directory and use it to establish a symmetric key with any other party. In addition, the scheme does not require any public-key operations. </p><p>The only security assumption made by Leighton-Micali is the existence of one-way functions. In practice, you use pseudorandom functions (see <i>Pseudorandomness and Cryptographic Applications</i>, by Michael Luby, Princeton University Press, 1996) to achieve this. For the purposes of this discussion, consider a pseudorandom function to be a keyed function with certain cryptographic properties. There are two properties that we are interested in: </p><p>1.	Given the output, it is not feasible to find the input to the function. </p><p>2.	Without the key, there is no way to compute the function. </p><p></p><p>It is reasonable to use a MAC function, such as HMAC (see "Keying Hash Functions For Message Authentication," by M. Bellare, R. Canetti, and H. Krawczyk, <i>Crypto '</i>96 Proceedings, 1996) to simulate this function in practice. Basing the entire security of the scheme on the assumptions about HMAC makes it easy to analyze the security of the protocol. It also makes for a clean and easy way to implement system. Leighton-Micali, as you will see, is also very efficient. I refer to the pseudorandom function used here as <i>f</i> and recommend that HMAC be used. </p><h3>The Scheme </h3><p>The Leighton-Micali scheme works as follows: The TA generates two master secret keys, <i>K</i> for secrecy, and <i>L</i> for authentication. One advantage of this scheme over Needham and Schroeder is that confidentiality and authentication are explicitly dealt with separately, whereas in Needham and Schroeder, you must employ encryption to attain authentication. The TA computes a key-exchange key to be shared with each participant in the system. These correspond to the <i>K<sub>sx</i></sub> in the Kerberos scheme. Take Alice as an example. The TA computes <i>K<sub>sa</i></sub> by applying the function <i>f</i> to the master key, <i>K,</i> and the string <i>Alice</i>. Using HMAC, you could write this as <i>K<sub>sa</sub>= HMAC<sub>K</sub>("Alice")</i> and <i>K<sub>sb</sub>=HMAC<sub>K</sub>("Bob")</i>. </p><p>In addition to the key exchange key it shares with each user, the TA computes another key called the "individual authentication key." This is simply computed as <i>L<sub>sa</sub>=HMAC<sub>L</sub> ("Alice")</i> and <i>L<sub>sb</sub>= HMAC<sub>L</sub>("Bob")</i>. In other words, the long-term keys are computed by applying the pseudorandom function using <i>K</i> and <i>L</i> to the person's name. Only the TA could have generated these values, as <i>K</i> and <i>L</i> are master secrets. Each participant is then given the two keys in a secure manner, out of band. </p><p>Now the tricky part. The TA computes some information that will be stored in a public directory. For <i>n</i> participants in the system, the table contains <i>n</i><sup>2</sup> values. The directory can be made widely available; it could be stored on a web site, for example. For every two participants, such as Alice (<i>a</i>) and Bob (<i>b</i>), the TA computes <i>P<sub>a,b</sub>={K<sub>sb</sub>("Alice") <IMG SRC="xor12.gif" ALT="" WIDTH="8" HEIGHT="8"> f<sub>Ksa</sub>("Bob") and A<sub>a,b</sub>=f<sub>Lsa</sub> (f<sub>Ksb</sub>("Alice"))</i>. </p><p>If storage is not an issue, each party can download and store the values in the table for the participants with whom they expect to communicate. Another option is to download them on demand. The method used to obtain these values is unimportant. After making them available, the TA can disappear and erase the master keys. So, how do Bob and Alice share a common key? Interestingly, the key already exists. It is the output of <i>f<sub>Ksb</sub>("Alice")</i>. Similarly, the key shared by Bob and Fred is <i>f<sub>Ksb</sub>("Fred")</i>, and the key shared by Alice and Fred is <i>f<sub>Kab</sub>("Fred")</i>. In general, the secret key that results from this protocol is <i>f</i>, keyed by the key-exchange key of the first party, applied to the name of the second party. To recover the key between Alice and Bob, Bob can simply apply the function <i>f</i>, using his key-exchange key, to Alice's name. Alice has to do a little more work, but not much. She simply computes <i>f<sub>Ksa</sub>("Bob")<IMG SRC="xor12.gif" ALT="" WIDTH="8" HEIGHT="8"> P<sub>a,b</i></sub>, which is the exclusive OR of her key-exchange key, applied to Bob, with the directory value for her and Bob. The reason this works is that:</p><blockquote><p><i>f</i><sub>Ksa</sub>("Bob") <IMG SRC="xor12.gif" ALT="" WIDTH="8" HEIGHT="8"> P<sub>a,b</sub></p><p></i>=<i>f</i><sub>Ksa</sub>("Bob") <IMG SRC="xor12.gif" ALT="" WIDTH="8" HEIGHT="8"> <i>f</i><sub>Ksb</sub>("Alice") <IMG SRC="xor12.gif" ALT="" WIDTH="8" HEIGHT="8"> <i>f</i><sub>Ksa</sub>("Bob") </p><p><i>=<i>f</i><sub>Ksb</sub>("Alice") </i></p></blockquote><p>The two <i>f</i><sub>Ksa</sub>("Bob") </i>cancel out, and the result is the key that Bob computed directly. To be sure that she has the right key, Alice computes <i>f</i><sub>Lsa</sub>(<i>f</i><sub>Ksb</sub>("Alice"))</i> and compares it to <i>A<sub>a,b</i></sub> from the table. The two values should match. If they do, then Alice can be sure that the directory values are legitimate. Any tampering with them would result in an error. The protocol works because nobody can produce <i>P</i> and <i>A</i> values that will match when a session key is tested without possession of the master keys. </p><p>As mentioned earlier, in general, it is best to use different keys for each direction. This protocol achieves this very naturally. The key used to receive is always the one that computes directly from the long-term key. For example, when Bob receives from Alice, he uses <i>f<sub>Ksb</sub>("Alice")</i>. When Alice receives messages from Bob, she uses the key <i>f<sub>Ksa</sub>("Bob")</i>. To compute a sending key, each party must consult the directory. This is nice because the heavier burden is placed on the sender, and the receiver can easily decrypt by performing a simple computation to find the key. </p><p>So, what you have is a protocol where Bob and Alice, who share a secret with a TA, can compute a shared symmetric key, with only HMAC and XOR operations. This is pretty efficient, but allows for only one derived key in each direction. This key could be used as a long-term key directly between Alice and Bob, who could use it to encrypt a randomly chosen session key to be used for actual data encryption and authentication. </p><p>Leighton-Micali is elegant, efficient, and secure. It is a little complicated, but after staring at it for a while, you should become convinced that it works. </p><p><b>DDJ</b></p></body></html>