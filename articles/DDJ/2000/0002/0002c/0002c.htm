<html><head><title>Feb00: Java References</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Java References</h1><p><i>Dr. Dobb's Journal</i> February 2000</p><h2>Working with the  garbage collection</h2><h3>By Jonathan Amsterdam</h3><I>Jonathan is an Adjunct Associate Professor of Computer Science at New York University and president of Astrel. He can be reached at amsterdam@astrel.com.</I><hr><p>Of all the features in Java 1.2, references are the most accessible and the most mysterious. Accessible because they are closely tied to Java's garbage collector, mysterious because it is not entirely clear what they are. </p><p>The idea behind Java references is easy to understand: They let a program refer to objects without preventing those objects from being garbage collected. There is also a way to obtain control just before an object is collected, so that you can perform clean up actions. That's the story in a nutshell. But references are a low-level feature, difficult to reason about and to use correctly. In addition to explaining how references work, I'll present some useful abstractions that make working with references easier.</p><DDJADVERTISEMENT INLINE><h3>Why References?</h3><p>While a program is running, the garbage collector occasionally seeks out all the objects that the program can access. These reachable objects consist of those pointed to by class variables, those pointed to by local variables in the currently active methods of all threads, and any other objects reachable from the aforementioned objects by following pointers. All other objects are unreachable -- the program will never be able to access them again. If they can't be accessed, they can't possibly affect the computation. So, these unreachable objects are garbage and their storage can be reclaimed.</p><p>The principle that an object is garbage if and only if it is unreachable is obviously correct. Unfortunately, it is a little too correct sometimes. To take one example, if you have a way of reconstructing an object, either by performing some computation or reloading it from a file, then you may be willing to let the garbage collector reclaim it if memory is tight. A "soft" reference can handle this case. Another situation occurs if you're keeping a table of information around, keyed by object, the only purpose of which is to serve other parts of the program. When one of the key objects becomes garbage, then you'd like to remove it and its associated information from the table. "Weak" references are used in this situation.</p><p>A third kind of reference -- "phantom" references -- are really just another way to be notified when an object is garbage collected, much like the <i>finalize </i>method. </p><p>Each kind of reference is represented by a subclass of <i>Reference</i> in the java .lang.ref package. By passing an object to the constructor of one of these classes, you obtain a reference to the object.</p><p>A clarification before delving into the details: In Java parlance, the term "reference" is used for the normal relationship between a variable and an object:</p><blockquote><p>String s = "On Sense and Reference";</p></blockquote><p>You might say that <i>s</i> holds a reference to the string. But I prefer to reserve references for one of the three special relationships just mentioned. Instead, I'll designate <i>s</i> as a standard pointer to the string.</p><h3>Soft References</h3><p>Consider a special case of the first situation I described. Say you have a large object that is stored in a file, perhaps in serialized form. You must load it into memory to work with it, and you'd like to keep it around, space permitting, but you also want to give the garbage collector the option of freeing the object when necessary.</p><p>By using a soft reference to your object (instead of a standard pointer), you can still access the object while allowing the garbage collector to reclaim it. More precisely, if an object can be reached only via soft references, then the object can be reclaimed. The garbage collector would never reclaim an object that is reachable through a standard pointer, no matter how many soft references to it existed.</p><p>To use soft references, first get your object:</p><blockquote><p>Object obj = readObjectFromFile(...);</p></blockquote><p>The variable <i>obj</i> holds the object in the normal Java way -- it's a standard pointer. Now pass the object to the <i>SoftReference </i>constructor:</p><blockquote><p>SoftReference ref = new SoftReference(obj);</p></blockquote><p>Then make sure that there are no standard pointers to your object:</p><blockquote><p>obj = null;</p></blockquote><p>Now, you may be able to retrieve your object with the <i>get</i> method:</p><blockquote><p>obj = ref.get();</p></blockquote><p>On the other hand, <i>get</i> may return null, indicating that the garbage collector has reclaimed your object and cleared the reference. In this case, if you really want the object back, you will have to recreate it.</p><p><A NAME="rl1"><A HREF="#l1">Listing One</A> is a class called <i>SoftObject</i> that embodies this pattern. It maintains a soft reference to an object. Its <i>get</i> method is guaranteed to return the object (if it doesn't throw an exception). If the reference has been cleared, the <i>retrieve </i>method is called and a new soft reference is created. (You can't reuse the old one -- except for being cleared, references are immutable.) </p><p>Subclasses of <i>SoftObject</i> may implement the <i>retrieve </i>method as desired. You might perform a computation or download the object over the network. (<i>SoftObject</i>s would be particularly useful for image and sound file downloading.) A third possibility, reading the object from a serialized file, is shown in the <i>FileObject</i> class in <A NAME="rl2"><A HREF="#l2">Listing Two</A>. If the file sense.ser contained a serialized representation of a <i>String</i>, you could use <i>FileObject</i> to access the <i>String</i> like so:</p><blockquote><p>SoftObject fo = new FileObject(''sense.ser");</p><p> ...</p><p>String s = (String) fo.get();</p><p>display(s);</p></blockquote><p>The call <i>fo.get()</i> will return the <i>String</i> immediately if it's available, or read it from the file. As long as there is a standard pointer to the object, such as <i>s </i>or the parameter of the <i>display </i>method, the object will not be garbage collected.</p><p>There are dangers in working with references akin to those involving multiple threads, because the garbage collector behaves much like a separate thread. Consider these two lines from the <i>get</i> method of <i>SoftObject</i>:</p><blockquote><p>result = retrieve();</p><p>ref = new SoftReference(result);</p></blockquote><p>A seemingly equivalent formulation is:</p><blockquote><p>ref = new SoftReference(retrieve());</p><p>result = ref.get();</p></blockquote><p>But there is a problem with this code. If the garbage collector runs after the first line but before the second, it may reclaim the object and <i>ref.get()</i> will return <i>null. </i>The first version doesn't have this problem because it puts the newly retrieved object into a standard pointer before creating the reference.</p><p>Java's only guarantee about a soft reference is that it will be cleared before the system runs out of memory. But the hope and the intent is that implementations will choose carefully, which soft references to clear when memory is low, to provide the best possible performance. For instance, an implementation might prefer to clear soft references that haven't been accessed in a while.</p><h3>Weak References</h3><p>Weak references share with soft references the property that the garbage collector is welcome to release the contained object if no standard pointers to it exist. The most important difference between them is that no clever algorithms will be applied to clearing weak references. A weak reference is used simply to allow an otherwise unreachable object to be reclaimed. The difference is subtle and is best illustrated with an example.</p><p>As you may know, any Java string literals in the same program that are spelled the same are represented by the same <i>String</i> object in memory. For instance, <i>"Frege" == "Frege"</i> is true, even though (in general) <i>s.equals(t)</i> should be used to compare two strings <i>s</i> and <i>t</i>. You can get the same effect by calling the <i>intern</i> method of the <i>String</i> class -- if <i>s.equals(t)</i>, then <i>s.intern() == t.intern()</i>. In other words, <i>intern</i> returns the same object for all strings that are equal to one another.</p><p>When a single object is used to represent a potentially large group of equal objects, that object is called the "canonical object" for the group. (A related idea is the Flyweight pattern described in <i>Design Patterns</i>, by Erich Gamma et al.) Using canonical objects saves space, because fewer objects need actually be in memory. And it saves time, because the object identity (the <i>== operator</i>, which can be done in one machine instruction) can be used in place of object equality (the <i>equals </i>method).</p><p>Lisp symbols are another example of canonical objects. Symbols represent variables in Lisp and consist of a name and a value; the Java version would be:</p><blockquote><p>class Symbol {</p><p>	String name;</p><p>	Object value;</p><p>}</p></blockquote><p>In a running Lisp program, there is only one symbol with a given name. Symbols are <i>intern</i>ed, just like Java literal strings.</p><p>It is easy to implement canonical objects using a hashtable or other mapping data structure, such as Java 1.2's <i>HashMap. </i>You can keep the canonical objects in the table, and canonicalize (<i>intern</i>) new objects by looking them up in the table and adding them if not present. </p><p>A first version of a Lisp symbol class in Java appears in <A NAME="rl3"><A HREF="#l3">Listing Three</A>. If the <i>Symbol.intern</i> method finds a symbol in the table corresponding to the string, it is the canonical symbol, and is returned XXXX. If it doesn't find a symbol, it creates a new one, which becomes the canonical symbol for that name. Since the constructor is private, the only way to create a symbol is via the <i>intern</i> method. Thus you can guarantee that there is only one <i>Symbol</i> with a given name -- if <i>s.name.equals(t.name)</i>, then <i>s == t</i>.</p><p>There is just one problem: As more and more names are <i>intern</i>ed, the size of the table grows without limit. Even if a symbol is no longer reachable by the program, and should be garbage, the pointer to it in the symbol table will prevent it from being garbage collected. (This is actually the correct behavior for an interactive Lisp interpreter, where users can type in a symbol name at any time, but it is not right for a standalone program.)</p><p>The solution, of course, is to use Java references. If the symbol table holds weak references to <i>Symbol</i>s instead of the <i>Symbol</i>s themselves, then the table will not prevent the garbage collector from reclaiming an unreachable <i>Symbol</i>. To adapt the <i>Symbol </i>class to use weak references, change the <i>intern</i> method to that of <A NAME="rl4"><A HREF="#l4">Listing Four</A>. </p><p>Weak references are more appropriate in this case than soft references, for two reasons. First, there is no complicated memory juggling going on here as there was in our first example. Of course, if space were infinite, we wouldn't need to bother with references. So, in that sense, memory is still our concern. But we don't want the system to waste its time applying clever algorithms to determine which weak references should be cleared first. Once a <i>Symbol</i> is garbage, it's garbage, and any weak reference to it should be cleared pronto.</p><p>There is a second reason for preferring weak references to soft references where canonical objects are involved. A soft reference may be cleared even if weak references still exist, but the opposite will not happen. In other words, consider a situation in which an object is reachable by one soft reference and one weak reference, and nothing else. Then the soft reference will be cleared before the weak one. This can violate the correctness of canonical objects if the table is implemented with soft references.</p><p>Here is a scenario that demonstrates the problem. Assume your symbol table were to use soft references. First, you <i>intern</i> a new symbol and keep a weak reference to it:</p><blockquote><p>WeakReference r =</p><p>	new WeakReference(Symbol				         .intern("Gottlob"));</p></blockquote><p>There are now only two references to the symbol: the weak reference <i>r</i> and the soft reference inside the table. The soft reference will be cleared first. After it is cleared, you <i>intern</i> the same string, causing a new canonical symbol to be created:</p><blockquote><p>Symbol s1 = Symbol.intern("Gottlob");</p></blockquote><p>Now you retrieve the original canonical symbol from the weak reference:</p><blockquote><p>Symbol s2 = (Symbol) r.get();</p></blockquote><p>If the weak reference has not yet been cleared, then <i>s1</i> and <i>s2</i> are two different <i>Symbol</i>s with the same name, violating the rule that governs canonical objects.</p><p>This problem occurs because the clearing of a soft reference does not imply that the object is completely unreachable. When a weak reference is cleared, there is truly no way to reach the object (not even through another weak reference -- the specification requires that all weak references to an object are cleared atomically).</p><p>To summarize, you use weak references instead of soft references to implement canonical objects when you don't need sophisticated memory management, but you do require that once removed from the table, the canonical object can never be retrieved.</p><h3>Reference Queues</h3><p>There is still a problem with the table of symbols. Although weak references allow the symbols to be garbage collected, the weak reference objects themselves -- and the space they use in the table -- are reachable through standard pointers and will not be reclaimed. The table entry for a symbol should be removed when the symbol is collected.</p><p>You will quickly appreciate that the solution is not to have another level of weak references to the existing weak references. Where would you store these new reference objects? Taking another track, you could set up a thread that periodically scans the table and removes cleared references and their keys, but much of that thread's effort would be wasted examining uncleared references. Ideally, you would like to be notified whenever a reference is cleared.</p><p>Reference queues do just that. If a reference is created with a reference queue, then it will be placed on that queue after it is cleared. The program can periodically check the queue and perform any cleanup<i> </i>operations associated with the queued references. It can do that in a separate thread, or as part of another activity. A simple and natural choice for the symbol table is to clean up each time <i>intern</i> is called.</p><p>Rather than modify our symbol table, let me present a generalization of it that incorporates reference queues. Called <i>CanonicalTable</i>, it resides in <A NAME="rl5"><A HREF="#l5">Listing Five</A>.</p><p>You typically create a <i>CanonicalTable</i> with a factory<i> </i>object, which is used to create new canonical objects when one is not found in the table. The factory<i> </i>for the <i>Symbol</i> table would call the <i>Symbol</i> constructor. Besides a factory<i>, </i>an instance of <i>CanonicalTable</i> contains a <i>HashMap</i> and <i>ReferenceQueue</i>. (The <i>ReferenceQueue</i> class is also in java.lang.ref.)</p><p>Calling the <i>canonicalize</i> method with a key has the same effect as calling <i>Symbol</i>'s <i>intern</i> method: The canonical object is returned if present, otherwise a new one is created (using the factory) and returned. A second version of <i>canonicalize </i>takes an object as well as a key, with the understanding that this object is to become the canonical object if none is found in the table.</p><p>In both cases, <i>canonicalize</i> begins by doing a cleanup, the details of which I'll examine shortly. It then proceeds much like <i>Symbol.intern</i>, looking up the key in the map and creating a new canonical object (or using the supplied one) if necessary. The only difference is that when the <i>WeakReference</i> is created, its constructor is given the reference queue.</p><p>The <i>cleanup</i> method, called at each invocation of <i>canonicalize</i>, dequeues references from the reference queue by calling the queue's <i>poll </i>method, which returns <i>null </i>when the queue is empty. If a reference is dequeued, that means the canonical object to which it refers is about to become garbage, so the key-value pair for that object should be removed from the map. Because references are cleared before being queued, there is no way to retrieve the canonical object. So, if <i>WeakReference</i>s were used directly, <i>cleanup</i> wouldn't be able to determine which key to remove. The solution is to write a subclass of <i>WeakReference</i> with an instance variable to hold the key. This subclass, <i>WeakValue,</i> is a private inner class of <i>CanonicalTable</i>. When a <i>WeakValue</i> is dequeued, its key can be extracted and used to remove the key-value pair from the map:</p><blockquote><p>map.remove(((WeakValue) r).key);</p></blockquote><p>The end result is a <i>CanonicalTable</i> that cleans up after itself, removing canonical objects that are eligible for reclamation.</p><p>It's worth mentioning another application of weak references. Say you wished to associate additional data with some objects. One approach would be to write a subclass with additional instance variables, but that wouldn't be viable if you didn't have control over the creation of the objects. For example, you might want to associate additional information with each thread of your program, even the threads created and used internally by the Java Virtual Machine. Java supports these thread-local variables with two java.lang classes, <i>ThreadLocal</i> and <i>InheritableThreadLocal</i>.</p><p>These classes could work by using a <i>HashMap</i> from threads to variables, except for the problem that a thread and its associated variables will never be garbage collected as long as the thread is present in the table. As you know by now, the fix is to use weak references to hold the threads. Unlike <i>CanonicalTable</i>, weak references here must hold the keys of the map instead of the values. The JDK supplies such a data structure as j<i>ava.util.Weak</i>HashMap. Its source code is required reading for students of references. </p><h3>Phantom References</h3><p>Like soft and weak references, phantom references have a <i>get</i> method, but it always returns <i>null</i> -- you can never retrieve the contained object. (That explains the ghoulish name.) So phantom references are useful only in conjunction with reference queues. When you dequeue a phantom reference, you know that an object is effectively garbage, so you can clean up after it. Specifically, no soft or weak references to the object exist -- a phantom reference is enqueued only after all other references have been cleared -- and the object's <i>finalize </i>method, if any, has been called.</p><p>Java's finalization mechanism might seem to render phantom references useless. An object's <i>finalize </i>method is called just before the object is garbage collected, to provide a chance for cleaning up. Moreover, the <i>finalize </i>method has access to the entire object, while a phantom reference does not.</p><p>Phantom references solve two problems with finalization. The first is that the <i>finalize</i> method is called by a thread you know nothing about at a time you cannot predict. <i>finalize</i> methods have to be written very carefully to avoid unwanted interactions with your program. And exceptions thrown by the <i>finalize</i> method are simply ignored, which, as you can imagine, makes debugging finalizers a delight. The safest thing to do in a <i>finalize</i> method is to place the object on a queue for later processing at the program's convenience. This is just the functionality phantom references provide.</p><p>The second problem with the <i>finalize</i> method is that there might not be one. If a class's objects need to be finalized but the class writer has neglected to write a <i>finalize</i> method, phantom references can help. For example, say a class acquires an external resource -- something outside the program, like a file descriptor or network connection -- but neglects to provide a <i>finalize </i>method to release it:</p><blockquote><p>class Leaker {</p><p>	int erToken = ExternalResource					      .acquire();</p><p>	// no finalize method release</p><p>}</p></blockquote><p>Here, I'm imagining that the class for the resource returns an integer token representing the resource. If your code creates <i>Leaker</i>s, then you can subclass <i>Leaker</i> and write a <i>finalize</i> method. But if you don't have control over object creation, this solution isn't available. However, if you can access the external resource token inside a <i>Leaker</i>, you can create a phantom reference to each <i>Leaker</i> object and do the release yourself. </p><p>A <i>PhantomReference</i> itself can tell you nothing about the <i>moribund</i> object or what to do about it, so you must always create a subclass of <i>PhantomReference</i> that contains cleanup information. Here we hold the resource to be released:</p><blockquote><p>class Releaser extends PhantomReference {</p><p>   int token;</p><p>   Releaser(Leaker lkr, ReferenceQueue q) {</p><p>	   super(lkr, q);</p><p>	   this.token = lkr.erToken;</p><p>   }</p><p>}</p></blockquote><p>A crucial subtlety lurks in this code: The object of the phantom reference -- the first argument to the superclass constructor -- must not be stored in an instance variable of the <i>PhantomReference</i> class. If it were, then there would be a standard pointer to the object -- the one in the instance variable -- and the object would never be eligible for garbage collection.</p><p>Now each time you are given a <i>Leaker</i>, you create a phantom reference to it, associated with a particular reference queue. The referencing object must itself be accessible by a standard pointer -- you don't want it to get garbage collected before it can do its job -- so you'll add it to a list. (I'm using Java 1.2 collections, but you can just as well use a <i>Vector</i>.)</p><blockquote><p>ReferenceQueue leakerQueue = new  		          ReferenceQueue();</p><p>List releasers = new ArrayList();</p><p> ...</p><p>Leaker lkr = ...;</p><p>releasers.add(new Releaser(lkr,  		            leakerQueue));</p></blockquote><p>Now, whenever you want, you can do some cleaning up:</p><blockquote><p>Releaser r = (Releaser) leakerQueue.poll();</p><p>   if (r != null) {</p><p>   ExternalResource.release(r.token);</p><p>   r.clear();</p><p>   releasers.remove(r);</p><p>}</p></blockquote><p>Here, the queue is polled to obtain the next reference whose object is ready to be reclaimed. Then the data in that reference is used to clean up. The reference is removed from the list so it, too, can be garbage collected. </p><p>The call to <i>clear</i> is the final nail in the coffin of the <i>Leaker</i> object contained in the reference; after that call, it will be reclaimed. Calling <i>clear</i> is not strictly necessary in this case, because removing the <i>Releaser</i> object from the list renders it unreachable, and when the garbage collector runs again, it will reclaim both the <i>Releaser</i> and the <i>Leaker</i> that it contains. But calling <i>clear</i> explicitly can't hurt, and it may hasten the demise of the <i>Leaker</i>.</p><p>If this seems like a lot to go through for one call of a <i>cleanup </i>method, then you might be interested in my <i>Cleanup</i> class; see <A NAME="rl6"><A HREF="#l6">Listing Six</A>. All you have to do is register a <i>Cleanup.Handler </i>with an object, and it takes care of the rest. Registration involves creating an instance of <i>Cleanup .Handler</i> and calling the <i>register </i>method:</p><blockquote><p>Leaker lkr = ...;</p><p>final int token = lkr.erToken;</p><p>Cleanup.register(lkr, new Cleanup.Handler() {</p><p>   public void cleanup() {</p><p>	ExternalResource.release(token);</p><p>   }})</p><p>;</p></blockquote><p>It's important that you don't refer to <i>lkr</i> inside the <i>cleanup </i>method, for the same reason I discussed previously. If you do, <i>lkr</i> will never be garbage collected.</p><p>The actual cleaning up can be done directly, whenever you wish, by calling the <i>doPending</i> method of <i>Cleanup</i>:</p><blockquote><p>try {</p><p>  Cleanup.doPending();</p><p>} catch (Exception e) {...}</p></blockquote><p>The <i>doPending</i> method propagates any exceptions thrown by <i>Cleanup.Handler</i>s.</p><p>Or you can start a thread to clean up continuously in the background, using the <i>startBackground</i> method. This thread uses the <i>remove </i>method of <i>ReferenceQueue</i>, which makes its calling thread wait until a reference is enqueued.</p><p>What happens to exceptions thrown by <i>Cleanup.Handler</i>s called from the background thread? In "Multithreaded Exception Handling in Java" (<i>Java Report</i>, August 1998), Joe De Russo III and Peter Haggar suggest using an event listener-like mechanism for communicating exceptions between threads. Here, I adopt a simpler, if less flexible, solution. Exceptions are accumulated into a list, which may be obtained at any time by calling <i>Cleanup.getExceptions</i>.</p><h3>Conclusion</h3><p>References are obviously not for the casual programmer. Leave consideration of references for late in the implementation phase of your project, and give precedence to abstractions like <i>SoftObject</i>, <i>CanonicalTable</i>, <i>WeakHashMap</i>, and <i>Cleanup</i> over naked references. When used correctly, references are a powerful tool for communicating with the garbage collector.</p><p></p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>import java.lang.ref.*;public abstract class SoftObject {    private SoftReference ref = new SoftReference(null);    public Object get() throws Exception {        Object result = ref.get();        if (result == null) {            result = retrieve();            ref = new SoftReference(result);        }        return result;    }    protected abstract Object retrieve() throws Exception;}                </pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>import java.io.*;public class FileObject extends SoftObject {    private String filename;  FileObject(String fn) {        filename = fn;    }    protected Object retrieve()             throws IOException, ClassNotFoundException {        ObjectInputStream in =             new ObjectInputStream(                new FileInputStream(filename));        try {            return in.readObject();        } finally {            in.close();        }    }}</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>import java.util.*;import java.lang.ref.*;class Symbol {    private String name;    Object value;    private static Map table = new HashMap();    private Symbol(String nm) { name = nm; }    String getName() { return name; }    static Symbol intern(String name) {        Symbol s = (Symbol) table.get(name);         if (s == null) {            s = new Symbol(name);            table.put(name, s);        }        return s;    }}            </pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>static Symbol intern(String name) {    Reference r = (Reference) table.get(name);    Symbol s = null;    if (r != null)        s = (Symbol) r.get();    if (r == null || s == null) {        s = new Symbol(name);        table.put(name, new WeakReference(s));    }    return s;}       </pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five</H4><pre>import java.util.*;import java.lang.ref.*;/** This class is for maintaining canonical objects. */public class CanonicalTable {    private Map map = new HashMap();    private ReferenceQueue queue = new ReferenceQueue();    private Factory factory;    public interface Factory {        public Object create(Object key);    }    public CanonicalTable() {}    public CanonicalTable(Factory f) {        factory = f;    }    public synchronized Object canonicalize(Object key) {        return canonicalize(key, null);    }    public synchronized Object canonicalize(Object key, Object o) {        cleanup();        Object value = map.get(key);        if (value != null)            value = ((WeakReference) value).get();        if (value != null)            return value;        else {            if (o == null)                o = factory.create(key);            map.put(key, new WeakValue(key, o, queue));            return o;        }     }    public synchronized Object get(Object key) {        cleanup();        Object value = map.get(key);        if (value != null)            return ((WeakReference) value).get();        else            return null;    }    private void cleanup() {        Reference r;        while ((r = queue.poll()) != null)            map.remove(((WeakValue) r).key);    }    ////////    private static class WeakValue extends WeakReference {        Object key;        WeakValue(Object k, Object o, ReferenceQueue q) {            super(o, q);            key = k;        }    }}</pre><P><A HREF="#rl5">Back to Article</A></P><H4><A NAME="l6">Listing Six</H4><pre>import java.util.*;import java.lang.ref.*;/** A class for simplifying the use of phantom references. */public class Cleanup {    // Doubly linked list of CleanupReferences, with an empty header.    private static CleanupReference list = new CleanupReference();    private static ReferenceQueue queue = new ReferenceQueue();    private static Thread backgroundThread = null;    private static ArrayList exceptions = null;    public interface Handler {        public void cleanup() throws Exception;    }    /** Register a cleanup handler with an object. */    public static void register(Object o, Handler h) {        synchronized (list) {            CleanupReference r = new CleanupReference(o, h);            r.linkAfter(list);        }    }    /** Perform all pending cleanup operations. */    public static void doPending() throws Exception {        Reference r;        while ((r = queue.poll()) != null)            ((CleanupReference) r).cleanup();    }    /** Start a thread to do cleanup in the background. */    public static synchronized void startBackground() {        if (backgroundThread != null)            return; // already running        backgroundThread = new Thread(new Runnable() {            public void run() {                while (!Thread.interrupted()) {                    try {                      CleanupReference r = (CleanupReference) queue.remove();                        r.cleanup();                    } catch (InterruptedException e) {                        // do nothing; loop will end                    } catch (Exception e) {                        addException(e);                    }                }            }        });        backgroundThread.setPriority(Thread.MIN_PRIORITY);        backgroundThread.start();    }    /** Stop the background cleanup thread. */    public static synchronized void stopBackground() {        if (backgroundThread != null) {            backgroundThread.interrupt();            backgroundThread = null;        }    }    /** Get a list of all exceptions generated by cleanup         calls in the background thread. */    public static synchronized List getExceptions() {        ArrayList result = exceptions;        exceptions = null;        return result;    }    private static synchronized     void addException(Exception e) {        if (exceptions == null)            exceptions = new ArrayList();        exceptions.add(e);    }    ////////////////////////////////////////////    private static class CleanupReference                 extends PhantomReference {        private Handler handler;        private CleanupReference next, prev;        CleanupReference() {   // Used only for head of linked list.            // Queue is never garbage; ensures             // no enqueuing.            super(queue, queue);            next = prev = this;        }        CleanupReference(Object o, Handler h) {            super(o, queue);            handler = h;        }        void linkAfter(CleanupReference c) {            this.prev = c;            this.next = c.next;            c.next.prev = this;            c.next = this;        }        void cleanup() throws Exception {            try {                handler.cleanup();            } finally {                this.clear();                synchronized (list) {  // unlink                    this.prev.next = this.next;                    this.next.prev = this.prev;                }            }        }    }} </pre><P><A HREF="#rl6">Back to Article</A></P></body></html>