<html><head><title>Feb00: Programmer's Toolchest</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Visualizing Network Resources Using Visio</h1><p><i>Dr. Dobb's Journal</i> February 2000</p><h2>Using drag-and-drop to  assemble development diagrams</h2><h3>By Chris Trueman</h3><I>Chris is the cofounder of Wave Software (http://www.wavesoftware.com/), which specializes in software development for Windows and the Internet. He can be reached at ctrueman@wavesoftware.com.</I><hr><p>Visio is generally considered a generic illustration tool for creating flowcharts, organizational charts, timelines, and the like. While Visio (from Visio Corp., http://www.visio.com/), although recently acquired by Microsoft, is an excellent tool for applications such as these, it is nonetheless built around a powerful visualization engine, making it ideal for visualizing and diagramming networks, software, databases, and other such systems.</p><p>With Visio, you can use drag-and-drop to assemble diagrams from a multitude of prebuilt shapes. Each shape consists of a number of properties that control a shape's appearance and response to stimuli. Visio presents the editable properties in a ShapeSheet editor that looks somewhat like a normal spreadsheet. In addition to simple numeric values, a property (or cell) can contain a formula that derives the value through some computation. </p><DDJADVERTISEMENT INLINE><p>These shapes can be transformed, connected to other shapes, and grouped. Furthermore, you can construct custom shapes from scratch or by modifying/extending those in the box. You can then use stencils to collect shapes for a particular purpose. In this article, for example, I'll use a network stencil that contains many shapes to represent the objects typically found on computer networks. In addition to stencils, Visio supports the notion of templates that are empty (or partially built) diagrams to which one or more stencils can be attached. In short, a Visio template can be used in much the same way as a Microsoft Word or Excel template.</p><p>To illustrate the use of Visio in a software development environment, I'll build the presentation layer for network resource discovery and visualization. While this article is based on Visio Professional 5.0, there are several different versions of the package, ranging from Visio Standard Edition to Visio Enterprise 5.0. In addition, there are add-ons, such as the Visio Solutions Library and the Visio Network Equipment toolkit (with various network device shapes).</p><p>There are three different ways to build a Visio-based solution:</p><ul>  <li>Write a special kind of DLL called a "Visio Solutions Library" (VSL).  <li>Utilize the embedded Visual Basic for Applications (VBA) development environment.  <li>Create a separate executable that drives Visio through its automation API.</ul><p>I'll focus VSLs using C++. That doesn't mean I don't use VBA. In fact, I always start a Visio-based project by prototyping the automation usage in VBA because it is quick and easy. The embedded nature of VBA means that solutions developed require a template (or diagram) in which to store the code. Likewise, implementing a separate executable that drives Visio is similar to writing a VSL, except that Visio runs in a different process. Thus the communication between the two applications is slightly slower. I've written solutions of this form using both C++ (using the wrapper classes) and Visual Basic.</p><p>Except for VBA, your choice of development tool is restricted to those that are capable of calling through OLE automation interfaces. However, Visio makes it easier to create VSLs if you are using Microsoft Visual C++ by including a custom App Wizard. All of the aforementioned alternatives utilize the Visio Automation API to handle the interactions between your code and the Visio environment.</p><h3>Visio Solutions Library</h3><p>A VSL is a standard Windows DLL that contains one or more add-on objects. It is identified by the .VSL suffix and the single export:</p><blockquote><p>VAORC VisioLibMain(VAOMSG wMsg, WORD wParam, LPVOID lpParam)</p></blockquote><p>I've removed some of the additional preprocessor elements that control its export and calling convention. In form, it looks like a Windows message handler; indeed, this is how it operates in practice. Once the VSL has been loaded, Visio sends it messages through this function to inform it of actions and events that have occurred. As a writer of a VSL, not all the messages will be of interest, so Visio includes a default message handler (sounds a lot like <i>DefWindowProc</i>) called <i>VAOUtil _DefVisMainProc</i>.</p><p>It is possible for one VSL to contain multiple add-on objects. When Visio calls through <i>VisioLibMain</i>, it sets the <i>wParam</i> parameter to be the identifier of the add-on that it is communicating with. When the add-on first registers with Visio, it is assigned a session-wide unique identifier. If you write add-ons and VSLs from scratch, it is your responsibility to ensure you record this information and process a standard set of messages in your <i>VisioLibMain</i>. Alternatively, you can use C++ and leverage the wrappers and Wizard that Visio provides.</p><p>Wizards are included for Visual C++ 4 and 5 (Version 5 Wizards also work with Version 6.0). When run, Visio creates a project that resembles the standard Win32 DLL project. However, the Visio-created project contains a prebuilt <i>VAddon</i> derivative you use as the basis for your application. The project will compile and link successfully and, if installed, the add-on will popup a message box when invoked.</p><p>The most important <i>VAddon</i> override is the <i>Run</i> method, which is called when users invoke your add-on from the Visio UI (or programmatically). <A NAME="re1"><A HREF="0002ie1.htm">Example 1</A> shows the <i>Run</i> method implementation in my network resource discovery VSL. The <i>VAddon</i> source file includes a stock implementation of the <i>VisioLibMain</i> that routes messages to virtual methods defined on the <i>VAddon</i> class. By overriding these methods in your derivatives you control how your add-on reacts to messages sent from Visio.</p><p>The Wizard is only capable of generating a project with one add-on. If you want the VSL to contain multiple add-ons then they must be cranked out by hand. Study the <i>VAddon</i> class and, in particular, how it is registered before starting down this path.</p><p>In addition to providing a C++ wrapper for writing add-ons, Visio includes an entire library of classes that encapsulate its automation API. This library saves you from having to spend too much time worrying about the details of the interfaces (in particular <i>AddRef</i> and <i>Release</i>) and lets you concentrate on the important job of writing your solution.</p><p>All the files I've mentioned -- Wizard, C++ wrappers, and so on -- are not installed by default. You must select the custom install and make sure that the "Developing Visio Solutions" option is checked. You can tell if your installation includes these files by looking for a DVS subdirectory in the Visio directory.</p><p>You configure the Visual C++ project to debug a VSL in exactly the same way you would for any normal Win32 DLL. Under the "Debug" option for the project set the "Executable for debug session" to &lt;VISIO&gt;\VISIO32.EXE where &lt;VISIO&gt; has been substituted for the Visio installation path on your system.</p><p>To install a VSL, Visio maintains a list of directories that it searches on startup for templates, stencils, and VSLs. By default, every installation includes a Solutions subdirectory. (In the past, I've created a subdirectory under Solutions called "IntelliCorp," the company I work for, for storing our VSLs.)</p><p>If you are running Visio in Developer Mode, then each VSL that has been marked visible can be found under Tools&gt;&gt;Addons. If the Addons menu is not present, look under Macros or enable Developer Mode from the Advanced Options dialog. If you're building solutions, you really should be running in Developer Mode, as this enables a number of useful short-cut menus -- most notably the Show ShapeSheet item on the Shape Context menu.</p><p>You are not constrained to install your solution in the Solutions directory structure. However, if an alternative directory is used, you must ensure that the search path is updated. You can either do this through the Visio UI or programmatically by editing the Visio.ini file. Changing the path through the UI causes Visio to automatically update its cache of VLSs, stencils, and templates. Programmatically, for example, perhaps you have written an installation script for your solution, then remember to change the <i>BuildDirectoryCache</i> entry in the INI file to 0 as this will instruct Visio to update its cache when next started.</p><h3>Pulling the Resources Together</h3><p>To illustrate the ideas presented here, I've written a C++ VSL that generates diagrams to represent all the available resources on a Windows network. The VSL utilizes the Visual C++ 5.0 Wizard, C++ wrappers, a standard Visio template, and some Win32 API calls.</p><p><A NAME="rf1"><A HREF="0002if1.htm">Figure 1</A> diagrams my home network. The real meat of the diagram starts with the cloud (ICBRISTOL); this is my Workgroup. The two machines it contains (DEEPTHOUGHT and DIABLO) are shown with their shares. Directory and printer shares each get their own shape.</p><p>In the interest of clarity, the code contains only a few debug ASSERTs and almost nothing in terms of error handling. If you start copying/pasting code into your solution, your first exercise would be to introduce some error handling. Also, I divided the VSL engine into a <i>CNetworkResourceCollector</i> and <i>CNetworkResource</i> class.</p><h3><i>CNetworkResourceCollector</i></h3><p><A NAME="rl1"><A HREF="#l1">Listings One</A> and Two present the <i>CNetworkResourceCollector</i> class. The point of entry to this object is its <i>Run</i> method. The actual processing is then split into the collection of resource data and its presentation. The <i>Collect</i> method is surprisingly short and uses recursion to walk the hierarchy of resources found in a network. In general, Windows networks are formed as follows:</p><blockquote><p>Windows Network</p><p>   Domain</p><p>Computer</p><p>  Share (represents both directories and 				       printers)</p></blockquote><p>The core Win32 API functions used to traverse this structure are <i>WNetOpenEnum</i>, <i>WNetCloseEnum</i>, and <i>WNetEnumResource</i>. Before the advent of the COM task allocator, it was typical for functions that returned variable length data to require two calls. The first call determined how much memory would be required to hold the returned data. The second call actually obtained the data. The <i>WNet</i> functions work in this way. <i>WNetEnumResource</i> returns ERROR_MORE_DATA when it needs more memory to complete successfully. A common bug (at least it used to be) is illustrated in realloc call in this method; see the code comments for more details.</p><p>As each resource is found, an instance of <i>CNetworkResource</i> is created to encapsulate the important details of the NETRESOURCE structure. I maintain the hierarchy by passing a parent resource through each successive call to <i>Collect</i>. Actually, this explains the The Network Universe shape at the top of the diagram. It makes the code in <i>Collect</i> much simpler during its first invocation if a real <i>CNetworkResource</i> instance is supplied. If I didn't include this I'd have to program for a special case and this makes the code larger, more cumbersome, and can point to design deficiencies.</p><p>Once all the resources have been collected, the <i>Display</i> method is called, which is responsible for loading the Visio network template, calling on each of the resources to draw themselves, and finally to organize the shapes using Visio's built-in auto layout routine.</p><h3><i>CNetworkResource</i></h3><p>In addition to wrapping the significant elements of the NETRESOURCE structure, the <i>CNetworkResource</i> (available electronically; see "Resource Center," page 7) provides methods to create the Visio representation of the resource and to add new resources to it (this is how the hierarchy is maintained in the data structure). Each type of resource gets its own shape.</p><h3>Generating the Diagram</h3><p>I used the Basic Network template that ships with Visio 5.0 Professional as the basis for the network resource diagram. The stencils that it uses provide a good range of shapes that can be used to represent the resources of the network. In particular, I used the Desktop PC (computer), Straight Bus (network), Cloud (domain), City (root -- network universe), Printer (shared printer), and Tape Drive (shared directory). The Tape Drive shape is actually used for directory shares because there is no hard-disk shape in the stencil; odd, given that there is one for floppy drives.</p><p>To make it easier to change the shapes used to represent each resource, I created a resource to shape map (see ShapesInc.cpp; available electronically). The <i>g_Shapes</i> global vector holds the shape index used for each type of resource. For the most part, determining the type of resource is a simple matter of looking at the <i>dwDisplayType</i> attribute of the NETRESOURCE structure (or calling <i>GetDisplayType</i> on a <i>CNetworkResource</i> instance). Unfortunately, in the case of shares this always returns RESOURCEDISPLAYTYPE_SHARE. For this reason, I store the <i>dwType</i> element (<i>GetType</i>) and use it to distinguish directory and printer shares. </p><p>In my tests, only the following resource types were encountered:</p><blockquote><p>RESOURCEDISPLAYTYPE_SHARE</p><p>RESOURCEDISPLAYTYPE_DOMAIN</p><p>RESOURCEDISPLAYTYPE_NETWORK</p><p>RESOURCEDISPLAYTYPE_SERVER</p></blockquote><p>The production of the diagram falls neatly into these steps:</p><p>1. Create an instance of a shape for each resource.</p><p>2. Set the text of the shape.</p><p>3. Assemble the hierarchy of links between the resources.</p><p>4. Layout the diagram.</p><p></p><p>Fortunately, Visio provides a number of autolayout algorithms, so making the diagram look pretty is simply a matter of calling the right method. As I've said, Visio handles all the dirty work of laying out the shapes and links. After trying the different options, I settled on those in <A NAME="rt1"><A HREF="0002it1.htm">Table 1</A>.</p><p>Interestingly, the layout properties are stored in the User Defined properties section on the Page object. You can see this by opening the ShapeSheet editor for the page. You configure the settings by updating the contents of each User Defined property cell.</p><p><A NAME="rf1"><A HREF="0002if1.htm">Figure 1</A> took about 20 seconds to produce. Running it on the INTELLICORP domain remotely via a dial-up ISDN connection took around 15 minutes. A fair percentage of the time is spent executing the autolayout function -- reasonable considering the number of machines and shares present in the domain.</p><h3>Conclusion</h3><p>The underlying principle of this article is to reinforce the idea of component-based development -- the utilization of prebuilt, quality modules that can be rapidly assembled to create complete software solutions.</p><p></p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>// NetworkResourceCollector.h: interface for CNetworkResourceCollector class//////////////////////////////////////////////////////////////////////#if !defined(AFX_NETWORKRESOURCECOLLECTOR_H__C855318A_17FC_11D3_B3C5_                                                  00105A98B108__INCLUDED_)#define AFX_NETWORKRESOURCECOLLECTOR_H__C855318A_17FC_11D3_B3C5_                                                  00105A98B108__INCLUDED_#if _MSC_VER &gt;= 1000#pragma once#endif // _MSC_VER &gt;= 1000#include &lt;list&gt;class VNetInfo;class CNetworkResource;//////////////////////////////////////////////////////////////////////// CNetworkResourceCollectorclass CNetworkResourceCollector  {public:     // C'tor/d'tor.    CNetworkResourceCollector(VNetInfo* addon);    ~CNetworkResourceCollector();public:     // Operations.    BOOL Run();private:        // Implementation.    BOOL Layout(CVisioPage&amp; page);    void DeleteNetworkResources();    CNetworkResource* CreateNetworkResource(NETRESOURCE* buffer);    BOOL Display();    BOOL Collect(CNetworkResource* parent, NETRESOURCE* nr = NULL);    VNetInfo* m_Addon;    // Having a "special" root object makes the Collect code simpler.    CNetworkResource* m_RootResource;public:#ifdef _DEBUG    void Dump();#else#define Dump()#endif // _DEBUG};#endif // !defined(AFX_NETWORKRESOURCECOLLECTOR_H__C855318A_17FC_11D3_B3C5_                                                     00105A98B108__INCLUDED_)</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>// NetworkResourceCollector.cpp//////////////////////////////////////////////////////////////////////#include "stdafx.h"#include "VNetInfo.h"#include "visiwrap.h"#include "NetInfo.h"#include "NetworkResourceCollector.h"#include "NetworkResource.h"#include "ShapesInc.h"#ifdef _DEBUG#undef THIS_FILEstatic char THIS_FILE[]=__FILE__;#define new DEBUG_NEW#endifCNetworkResourceCollector::CNetworkResourceCollector(VNetInfo* addon){    m_Addon = addon;    m_RootResource = new CNetworkResource();}CNetworkResourceCollector::~CNetworkResourceCollector(){    DeleteNetworkResources();}BOOL CNetworkResourceCollector::Run(){    Collect(m_RootResource);    Display();    return(TRUE);}BOOL CNetworkResourceCollector::Collect(CNetworkResource* parent,                                              NETRESOURCE* nr /* NULL */){    HANDLE enumHandle = 0;    DWORD rc = 0;    rc = ::WNetOpenEnum( RESOURCE_GLOBALNET, RESOURCETYPE_ANY, 0, nr,        &amp;enumHandle);    if(NO_ERROR == rc)    {        NETRESOURCE* buffer = NULL;        DWORD bufferSize = 0;        bufferSize = sizeof(NETRESOURCE);        buffer = (NETRESOURCE*) malloc(bufferSize);        ASSERT(NULL != buffer);        ::ZeroMemory(buffer, bufferSize);        do        {            DWORD count = 1;            rc = ::WNetEnumResource( enumHandle, &amp;count, buffer,                &amp;bufferSize);            switch(rc)            {            case NO_ERROR:               {                    // buffer now describes a single network resource.                    CNetworkResource* res = CreateNetworkResource(buffer);                    ASSERT(NULL != res);                    parent-&gt;AddResource(res);                    Collect(res, buffer);                    break;                }            case ERROR_MORE_DATA:                // For clarity I am not protecting against realloc returning                 // NULL - should it do so then we'll lose the memory already                // allocated to buffer. Be warned!                buffer = (NETRESOURCE*) realloc(buffer, bufferSize);                ASSERT(NULL != buffer);                ZeroMemory(buffer, bufferSize);                break;            default:                break;            }        } while(ERROR_NO_MORE_ITEMS != rc);        free(buffer);        buffer = NULL;        ::WNetCloseEnum(enumHandle);    }    return(TRUE);}BOOL CNetworkResourceCollector::Display(){    CVisioApplication app;    m_Addon-&gt;GetApp(app);    CVisioDocuments documents;    HRESULT hr;    hr = app.Documents(documents);    if(SUCCEEDED(hr))    {        CVisioDocument document;        BSTR filename = CString("Basic Network.vst").AllocSysString();        hr = documents.Add(filename, document);        FREE_BSTR(filename);;        if(SUCCEEDED(hr))        {            CVisioMasters masters;            short documentsCount;            documents.Count(&amp;documentsCount);            for(int i = 1; i &lt;= documentsCount; i++)            {                CVisioDocument document;                documents.Item(COleVariant((long) i), document);                BSTR bstrName;                CString name;                document.Name(bstrName);                name = bstrName;                FREE_BSTR(bstrName);                TRACE1("%s\n", name);                // We're looking for this specific stencil.                if(-1 != name.Find("basic network shapes.vss"))                {                    document.Masters(masters);                    break;                }            }            CVisioPages pages;            hr = document.Pages(pages);            if(SUCCEEDED(hr))            {                CVisioPage page;                hr = pages.Item(COleVariant((long) 1), page);                if(SUCCEEDED(hr))                {                    m_RootResource-&gt;Display(page, masters);                    Layout(page);                }            }        }    }    return(SUCCEEDED(hr));}CNetworkResource* CNetworkResourceCollector::                            CreateNetworkResource(NETRESOURCE* buffer){    ASSERT(NULL != buffer);    CNetworkResource* nr = new CNetworkResource(buffer);    ASSERT(NULL != nr);    return(nr);}void CNetworkResourceCollector::DeleteNetworkResources(){    delete m_RootResource;    m_RootResource = NULL;}BOOL CNetworkResourceCollector::Layout(CVisioPage&amp; page){    HRESULT hr;    CVisioShape shape;    hr = page.PageSheet(shape);    ASSERT(SUCCEEDED(hr));    CVisioCell cell;    ShapeGetCell(shape, _T("User.visControlsAsInputs"), cell);    CellSetFormula(cell, _T("0"));    ShapeGetCell(shape, _T("User.visPlacementStyle"), cell);    CellSetFormula(cell, _T("1"));    ShapeGetCell(shape, _T("User.visPlacementDepth"), cell);    CellSetFormula(cell, _T("1"));    ShapeGetCell(shape, _T("User.visRoutingStyle"), cell);    CellSetFormula(cell, _T("7"));    ShapeGetCell(shape, _T("User.visResize"), cell);    CellSetFormula(cell, _T("-1"));    page.Layout();    return(TRUE);}</pre><P><A HREF="#rl2">Back to Article</A></P></body></html>