<html><head><title>Feb00: Algorithm Alley</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>High-Speed Cryptography  with the RSA Algorithm</h1><p><i>Dr. Dobb's Journal</i> February 2000</p><h3>By Michael J. Wiener</h3><I>Michael is a senior cryptologist with Entrust Technologies. He can be reached at wiener@entrust.com.</I><hr><p>In 1978, Ronald Rivest, Adi Shamir, and Leonard Adleman published the RSA public-key cryptosystem (see "A Method for Obtaining Digital Signatures and Public Key Cryptosystems," by R. Rivest, A. Shamir, and L. Adleman, <i>Communications of the ACM</i>, February 1978). Since then, public-key cryptography has become a critical technology for confidentiality and trust in messaging and online transactions on the Internet. There are many choices for symmetric cryptosystems, but only a few public-key algorithms are available. The two main contenders right now are RSA and elliptic-curve cryptography. Here, we focus on implementing RSA.</p><p>RSA can be implemented in hardware, but great performance can also be achieved in software running on general-purpose processors. In fact, many (but not all) hardware implementations of RSA are actually much slower than RSA on a PC. In this article, I'll explain some of the key optimizations (with source code examples) that can be made to make RSA as fast as possible.</p><DDJADVERTISEMENT INLINE><p>The speed of RSA varies greatly from one implementation to the next. It is not unusual to see RSA code that is 100 times slower than the best available for a given platform. There are many tricks that boost performance by a few percent, but the most important ones make the code up to four times faster. Combining these ideas can make a speed difference of one to two orders of magnitude. Here, I'll discuss optimizations that apply to the underlying large integer math, the encryption and decryption operations, and key generation. I'll also give RSA performance figures for what can be achieved on an Intel PC.</p><h3>RSA Math Background</h3><p>Creating an RSA key pair begins with selecting two large prime numbers <i>p</i> and <i>q</i> at random. A typical size for each of these primes is 512 bits. The product of these primes is called the RSA modulus <i>n=p&times;q</i>. To say that we are using 1024-bit RSA means that the RSA modulus is 1024 bits long.</p><p>Next, a public exponent <i>e</i> is chosen. A common choice is <i>e</i>=2<sup>16</sup>+1=65537. Then the private exponent <i>d</i> is computed such that <i>ed</i>-1 is divisible by both <i>p</i>-1 and <i>q</i>-1. This makes <i>e</i> and <i>d</i> inverses of each other, in a sense to be discussed shortly.</p><p>To encrypt a message (which is often a symmetric key used to encrypt the real message), it must first be encoded as an integer <i>m</i> between 0 and <i>n</i>-1. The ciphertext is computed with a modular exponentiation operation: <i>c=m<sup>e </i></sup>mod <i>n</i>. The special form of the aforementioned private exponent <i>d</i> makes it possible to recover the message from the ciphertext: <i>m=c<sup>d</sup> </i>mod <i>n</i>.</p><p>The quantities <i>e</i> and <i>n</i> (but not <i>p</i> and <i>q</i>) can be made public, allowing anyone to encrypt a message, but only the owner of the private exponent <i>d </i>can decrypt the message. For attackers to find <i>d</i>, they must factor <i>n</i> into the primes <i>p</i> and <i>q</i>. For a 1024-bit modulus <i>n</i>, this is infeasible using the best factoring method known, the general-number field sieve (see <i>The Development of the Number Field Sieve, Lecture Notes in Math. 1554</i>, edited by A. Lenstra and H. Lenstra, Jr., Springer- Verlag, 1993).</p><p>If the goal is to compute a digital signature on a message (or hash of a message) rather than to encrypt it, the owner of the private exponent computes <i>s=m<sup>d</sup> </i>mod <i>n</i>. Then anyone can recover <i>m</i> and verify that the signature must have been created by the owner of <i>d</i> by computing <i>m=s<sup>e</sup> </i>mod <i>n</i>.</p><p>For a more complete mathematical description of RSA, see <i>Handbook of Applied Cryptography</i>, by A. Menezes, P. van Oorschot, and S. Vanstone (CRC Press, 1997).</p><h3>Targets of Optimization</h3><p>The main target of optimization is the modular exponentiation operation that consists of raising one number to some power modulo a third number: <i>m<sup>x</sup> </i>mod <i>n</i>. A naive approach is to start with <i>m</i>, multiply by <i>m x-</i>1<i> </i>times, divide by <i>n</i>, and take the remainder. This would be fine for very small numbers, but for RSA the private exponent <i>d</i> is very large, and doing <i>d</i>-1 multiplies is completely infeasible. A faster way can be illustrated using the exponent 19:<i> m</i><sup>19</sup>=(((<i>m</i><sup>2</sup>)<sup>2</sup>)<sup>2</sup>&times;<i>m</i>)<sup>2</sup>&times;<i>m.</i></p><p>Instead of 18 multiplies, you need only four squares and two multiplies. The next problem is that <i>m<sup>x</i></sup> can be extremely large. This is dealt with by dividing by <i>n</i> and taking the remainder after every square and multiply instead of waiting until the end.</p><p>Of the five further RSA optimizations described in the following, four apply to modular exponentiation and one is specific to prime number generation.</p><h3>Large Integer Representation</h3><p>A frequent operation in modular exponentiation is multiplying two integers. However, these integers are generally much larger than the maximum integer size supported by compilers. Some strategy is needed for breaking the problem down.</p><p>To multiply large numbers, children are taught to break the problem down into many products of single-digit numbers and to add all the partial products. The same can be done with computers, except that you use bytes or words instead of digits; see <A NAME="rf1"><A HREF="0002mf1.htm">Figure 1</A>(a). Each large integer is represented as an array of words. The words are small enough that you can easily compute the product of two words. To multiply two large integers, consisting of three words each, would require 3&times;3=9 small products to be computed and summed appropriately to produce the final result consisting of six words (<i>r</i>0 to <i>r</i>5).</p><p>For C/C++ programmers, it is tempting to use 16-bit words so that the small products are 32 bits long and fit in an unsigned long <i>int</i>. However, most 32-bit machines have an instruction that takes two 32-bit unsigned integers and computes the 64-bit result. The problem is that for many compilers, the upper half of the result is not accessible. To get the full 64-bit product requires writing a small amount of assembly code. <A NAME="re1"><A HREF="0002me1.htm">Example 1</A> shows inline assembly for Microsoft's Visual C++ on an Intel platform.</p><p>Using assembly code here is well worth it. Going from a large integer representation based on 16-bit words to 32-bit words cuts down the number of small products by a factor of four. This is possible on most 32-bit processors. Depending on the particular platform, this can save between a factor of two and four in the run time of all RSA operations. This is the only place in the RSA software where dramatic speed improvement is possible using assembly code. Intel's Merced chip promises further improvement by offering an integer multiply and add instruction that takes two 64-bit unsigned integers and produces the full 128-bit product (see "IA-64 Application Developer's Architecture Guide," May 1999, http://developer.intel .com/design/ia64/architecture.htm.)</p><h3>Faster Squaring</h3><p>The method used for modular exponentiation involves both multiplying and squaring large integers. The squaring can be done simply by using the multiply function with the arguments equal, but there is a faster way. In <A NAME="rf1"><A HREF="0002mf1.htm">Figure 1</A>(b), you see that three of the small products appear twice (for instance, <i>a&times;b=b&times;a</i>). Instead of computing each one twice, you can compute them once and add them twice to the final result. This does not save much for the small example in the figure, but for the larger numbers used in RSA, this can make squaring almost twice as fast as multiplication.</p><h3>Divide and Conquer</h3><p>To decrypt or digitally sign, the owner of the private exponent computes <i>r=y<sup>d</sup> </i>mod <i>n</i>, where <i>y</i> is either a ciphertext to be decrypted or a message (or hash of a message) to be signed, and <i>r</i> is the resulting plaintext message or digital signature. A clever observation is that because <i>n=p&times;q</i>, the Chinese Remainder Theorem says that you can compute <i>r </i>mod<i> p</i> and <i>r </i>mod<i> q</i>, and then combine them to get <i>r </i>mod<i> n</i> (see J.J. Quisquater and C. Couvreur's "Fast Decipherment Algorithm for RSA Public-Key Cryptosystem," <i>Electronics Letters</i>, October, 1982).</p><p>To take advantage of this performance improvement, a 1024-bit RSA private key is not really stored simply as two 1024-bit values <i>(d,n)</i> as described earlier, but is stored as five 512-bit values <i>(d<sub>p</sub>,d<sub>q</sub>,p,q,k)</i>. Three of these values require explanation. When a new RSA key pair is created, these values are computed as follows: <i>d<sub>p</sub>=d</i> mod (<i>p</i>-1), <i>d<sub>q</sub>=d</i> mod (<i>q</i>-1), and <i>k</i> is computed such that <i>kq</i>-1 is divisible by <i>p</i>. This quantity <i>k</i> is used in the final stage of constructing <i>r</i>. The process of computing <i>r=y<sup>d</i></sup> mod <i>n</i> begins with computing <i>r<sub>p</sub>=y<sup>dp</i></sup> mod <i>p</i> and <i>r<sub>q</sub>=y<sup>dq</i></sup> mod <i>q</i>. These are then combined to form <i>r</i> as follows:</p><blockquote><p><i>r=((r<sub>p</sub>+p-(r<sub>q</sub> </i>mod <i>p))&times;k </i>mod <i>p)&times;q+r<sub>q</sub></p></blockquote><p></i>The added <i>p</i> before subtracting <i>r<sub>q</i></sub> is there simply to avoid having to deal with negative numbers. It is more efficient to deal with only unsigned quantities. Normally, the owner of the private key also stores the public exponent <i>e</i> and possibly <i>n</i> (or he may choose to compute <i>n=p&times;q</i> when necessary to save space).</p><p>It is natural to ask at this point whether all this is really worth the trouble. The short answer is yes. The time required to perform a modular exponentiation is proportional to the cube of the size of the numbers involved. This means that each of the half-size exponentiations mod <i>p</i> and mod <i>q</i> take one-eighth as long as a big one mod <i>n</i>. The time required to do the final step of combining partial results is small by comparison. The overall improvement is almost a factor of four. Computing the extra information for a private key <i>(d<sub>p</sub>,d<sub>q</sub>,p,q,k</i>) is negligible and happens only at the time of key generation.</p><h3>Sliding Window Method</h3><p>I'll now examine a way to reduce the number of multiplies required to carry out a modular exponentiation. In the example earlier, we showed how to efficiently compute <i>m</i><sup>19</sup> by taking <i>m</i>, squaring it three times (to make <i>m</i><sup>8</sup>), multiplying by <i>m</i>, squaring, and finally multiplying by <i>m</i> again to get <i>m</i><sup>19</sup>. Looking at the binary representation of 19 (10011) suggests a general approach that works for any exponent. First, find the most significant set bit in the exponent and set the current result to be <i>m</i>. Then, for each successively less significant bit of the exponent, square the current result and if the exponent bit was set, multiply the result by <i>m</i>. This is a fairly simple approach that requires a square for each exponent bit (after the first one) and a multiply for each set exponent bit (after the first one).</p><p>The number of squares cannot be reduced much, but the number of multiplies required by the approach just described can be reduced significantly for large exponents using the sliding window method. This method deals with several exponent bits at a time instead of handling them one by one. You begin by selecting a window size <i>w</i>. For RSA-1024, <i>w</i>=6 is most efficient. Modular exponentiation proceeds in three stages described in the following steps:</p><p> </p><p>1.	Table computation. Compute all the odd powers of <i>m </i>up to 2<sup><i>w</i></sup> using a square and 2<sup><i>w</i>-1</sup>-1 multiplies. For <i>w</i>=6, this means computing <i>m</i><sup>1</sup>, <i>m</i><sup>3</sup>, ..., <i>m</i><sup>63</sup> and storing them in a table. </p><p>2.	Initialize exponent scanning. Next, we take the top window of <i>w</i> bits of the exponent and compute that power of <i>m</i> and assign it to the current result. If the <i>w</i> exponent bits form an odd value, then the appropriate table entry can be assigned to the current result. If the <i>w</i> exponent bits form an even value, then we can form that power of <i>m </i>by squaring a table entry or multiplying two entries and assigning the product to the current result. In <A NAME="re2"><A HREF="0002me2.htm">Example 2</A>, the initial exponent bits are 110, meaning that we have to initialize the result to <i>m</i><sup>6</sup> (by squaring <i>m</i><sup>3</sup> from the table).</p><p>3.	Main Loop. Repeat the following until the exponent is used up. Starting from the end of the last window processed, scan for the next set bit in the exponent and square the result for each zero bit encountered along the way. When a "1" bit is found, take the next window of <i>w </i>exponents bits (including the first set bit) if there are that many. Otherwise, just take as many exponent bits as are left. Suppose that this string of exponent bits ends in <i>z</i> zero bits and begins with <i>y</i> bits that form an odd value. Then square the result <i>y</i> times, multiply by the table entry corresponding to the <i>y</i> bits, and finally square the result <i>z </i>times. This trick eliminates the need to store even powers in the table. In <A NAME="re2"><A HREF="0002me2.htm">Example 2</A>, after setting the result to <i>m</i><sup>6</sup>, you have two zero bits each requiring a squaring, and then a window of 110 that ends in <i>z</i>=1 zero bits and whose initial <i>y</i>=2 bits form the odd value 3. This means that you square twice, multiply by <i>m</i><sup>3</sup>, and then square once more.</p><p></p><p><A NAME="rl1"><A HREF="#l1">Listing One</A> implements the sliding window method. For 1024-bit RSA, this method does not significantly affect the number of squaring operations required, but it reduces the number of multiplies by more than a factor of two.</p><h3>Sieving</h3><p>A common way to generate the prime numbers needed for an RSA key pair is to generate random numbers of the desired size and perform a primality test on each one until a prime number is found. The most efficient primality tests are probabilistic; they can say that a number might be prime with some probability or that it is definitely not prime. If a given number passes the test enough times, then the probability of it not being prime is so low that we can declare it a highly probable prime and use it for RSA. A good probabilistic primality test is the Miller-Rabin test (again, <i>Handbook of Applied Cryptography</i>, by A. Menezes, P. van Oorschot, and S. Vanstone, CRC Press, 1997).</p><p>A first thought on this approach to generating prime numbers is that it makes no sense to test whether an even number is prime. If you generate only large odd candidates to test, the process should run twice as fast. Taking this a step further, you could check whether the candidate is divisible by 3 or 5 before running the Miller-Rabin test. This can be extended to checking that the candidate is not divisible by any prime below some bound. For a bound of 4096, you save a factor of 15 in the number of primality tests performed. However, the cost of checking each candidate for divisibility by the primes up to the bound can become expensive. Much of this cost can be eliminated using a technique called "sieving," where you seek the first prime number after a random starting candidate by efficiently eliminating multiples of small primes.</p><p>An efficient approach based on sieving begins with generating a random odd candidate <i>c</i>. Create an array of Boolean flags, where element 0 corresponds to <i>c</i>, element 1 corresponds to <i>c</i>+2, and in general, element <i>i</i> corresponds to <i>c</i>+2<i>i</i>. Initially, set all flags to 1 indicating that the corresponding integer <i>c</i>+2<i>i</i> might be prime. For each small prime <i>s </i>less than the bound, find the smallest value <i>i</i> such that <i>c</i>+2<i>i</i> is divisible by <i>s</i> and turn off flags <i>i</i>, <i>i</i>+<i>s</i>, <i>i</i>+2<i>s</i>, up to the end of the array. This eliminates all multiples of <i>s</i> as prime candidates. After this process is done for all small primes less than the bound, the flags that are still on correspond to possible primes that can be tested with the Miller-Rabin test. If none of the remaining candidates are prime, you can repeat with <i>c</i>+2<i>l</i> in place of <i>c</i>, where <i>l</i> is the length of the array. <A NAME="rl2"><A HREF="#l2">Listing Two</A> implements sieving.</p><h3>Performance</h3><p>The performance figures in <A NAME="rt1"><A HREF="0002mt1.htm">Table 1</A> are based on the RSA implementation by Entrust. Additional information is available at either http://developer.entrust.com/ or http://developer.entrust.ch/. The run times are based on a 400-MHz Pentium II, a public exponent of <i>e</i>=65537, and do not include overhead such as hashing a message.</p><p>For the currently recommended RSA key size of 1024 bits, the operations of encrypting, decrypting, signing, and verifying signatures are very fast. Even key pair generation, which is not required frequently, takes less than a second. Digital certificates, which enforce the usable lifetime of a key pair, most frequently specify lifetimes of at least a year, and so a fraction of a second for key pair generation is a small overhead.</p><p>But what if you are forced to use larger key sizes in the future because attackers will have faster computers as Moore's law marches on? RSA-2048 is about a billion times stronger than the already strong RSA-1024, and even today's RSA-2048 operations are quite fast. If attackers have faster computers in the future, then so will users who are protecting their data. Moore's law favors the cryptographer, not the cryptanalyst. </p><h3>Conclusion</h3><p>When RSA was first introduced, it ran very slowly on the computers that existed at the time. But, the continuous drive to faster and faster computers has brought us to a point where RSA is very fast and practical to use. As computers become faster still, attackers will have more power for trying to break RSA, but this can be countered easily by increasing key sizes. Doubling the key size to 2048 bits costs the cryptographer less than a factor of eight in RSA signing time, but costs the cryptanalyst about a billion times more work to attack RSA. This makes it quite easy for the cryptographer to stay ahead.</p><p></p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>// To use this code, a BigInt class to handle big integers// is needed along with the following 5 functions.// set up an exponent to point to the top set bit for next_exponent_bit()void init_exponent(BigInt exponent);// get next exponent bitunsigned long next_exponent_bit();// return TRUE if exponent used upint exponent_finished();// result = result*result % modulusvoid modular_square(BigInt &amp;result, BigInt modulus);// result = result*x % modulusvoid modular_multiply(BigInt &amp;result, BigInt x, BigInt modulus);#define WINDOW 6#define TABLE_LEN 32BigInt table[TABLE_LEN];void fill_table(BigInt message, BigInt modulus){    BigInt sq;    long i;    sq = message;    modular_square(sq, modulus);    table[0] = message;    for (i = 1; i &lt; TABLE_LEN; i++)    {        table[i] = table[i - 1];        modular_multiply(table[i], sq, modulus);    }}BigInt modular_exponentiation(BigInt message, BigInt exponent, BigInt modulus){    BigInt result;    long started, num_pending_bits, num_zero_bits, i;    unsigned long pending_bits, bit;    fill_table(message, modulus);    init_exponent(exponent);    if (exponent_finished())       return 1;    started = 0;    num_pending_bits = 0;    pending_bits = 0;    do    {        while (!exponent_finished() &amp;&amp; ((bit = next_exponent_bit()) == 0))            modular_square(result, modulus);        num_pending_bits = pending_bits = bit;        while (!exponent_finished() &amp;&amp; (num_pending_bits &lt; WINDOW))        {            pending_bits = (pending_bits &lt;&lt; 1) + next_exponent_bit();            num_pending_bits++;        }        if (num_pending_bits &gt; 0)        {            if (!started)            {                if (pending_bits &amp; 1)                    result = table[pending_bits &gt;&gt; 1];                else if (pending_bits &amp; 2)                {                    result = table[pending_bits &gt;&gt; 2];                    modular_square(result, modulus);                }                else                {                    result = table[(pending_bits-1) &gt;&gt; 1];                    modular_multiply(result, message, modulus);                }                started = 1;            }            else            {                for (num_zero_bits = 0; !(pending_bits &amp; 1); num_zero_bits++)                    pending_bits &gt;&gt;= 1;                for (i = num_zero_bits; i &lt; num_pending_bits; i++)                    modular_square(result, modulus);                modular_multiply(result, table[pending_bits &gt;&gt; 1], modulus);                for (i = 0; i &lt; num_zero_bits; i++)                    modular_square(result, modulus);            }        }    }     while (!exponent_finished());    return result;}</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>// To use this code, a BigInt class to handle big integers// is needed along with the following function.// return true if candidate is a highly-probable primeint miller_rabin_test(BigInt candidate);#define SMALL_PRIME_BOUND_DIV2 2048#define SQRT_BOUND 64char small_prime_flags[SMALL_PRIME_BOUND_DIV2];// sieve to find small primes// small_prime_flag[i] == 1 means 2*i+1 is primevoid generate_small_primes(){    unsigned long i, sieve_val;    small_prime_flags[0] = 0; // 1 is not prime    for (i = 1; i &lt; SMALL_PRIME_BOUND_DIV2; i++)        small_prime_flags[i] = 1;    // for each odd number, throw out its multiples    for (sieve_val = 3; sieve_val &lt;= SQRT_BOUND; sieve_val += 2)        for (i = sieve_val + (sieve_val &gt;&gt; 1); i &lt; SMALL_PRIME_BOUND_DIV2;               i += sieve_val)            small_prime_flags[i] = 0;}#define SIEVE_LEN 2048BigInt generate_large_prime(BigInt start){    unsigned long small_prime, i, sp, candidate;    char sieve_array[SIEVE_LEN];    generate_small_primes();    start |= 1;  // force starting point odd    for (;; start += 2*SIEVE_LEN)    {        for (i = 0; i &lt; SIEVE_LEN; i++)            sieve_array[i] = 1;        for (sp = 0; sp &lt; SMALL_PRIME_BOUND_DIV2; sp++)            if (small_prime_flags[sp])        {            small_prime = 2*sp + 1;  // next prime to sieve with            // magic to find i such that small_prime divides start+2*i            i = (small_prime - 1) - ((start - 1) % small_prime);            if (i &amp; 1)                i += small_prime;            i /= 2;            // remove multiples of small_prime            for (; i &lt; SIEVE_LEN; i += small_prime)                sieve_array[i] = 0;        }        // test primality of remaining candidates        for (i = 0; i &lt; SIEVE_LEN; i++)            if (sieve_array[i])        {            candidate = start + 2*i;            if (miller_rabin_test(candidate))                return candidate;       }    }}</pre><P><A HREF="#rl2">Back to Article</A></P></body></html>