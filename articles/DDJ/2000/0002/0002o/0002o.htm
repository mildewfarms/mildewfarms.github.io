<html><head><title>Feb00: Programmer's Bookshelf</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>All This, and  Frequent Flyer Miles, Too!</h1><p><i>Dr. Dobb's Journal</i> February 2000</p><h3>By Gregory V. Wilson</h3><I>Greg is the author of Practical Parallel Programming (MIT Press, 1995), and coeditor with Paul Lu of Parallel Programming Using C++ (MIT Press, 1996). Greg can be reached at gvwilson@interlog.com.</I><hr><p>They say that the Internet has made geography irrelevant, but I'm not convinced. I put 65,000 miles on my frequent-flyer card last year.</p><p>On the bright side, all that flying has given me a lot of time to read, and various publishers have done a good job of giving me things worth reading. At the top of the list are two very practical, and very useful, books: <i>Mastering Algorithms with Perl</i>, by Jon Orwant, Jarkko Hietaniemi, and John Macdonald, and <i>Programming for the Java Virtual Machine</i>, by Joshua Engel.</p><DDJADVERTISEMENT INLINE><p><i>Mastering Algorithms with Perl</i> is a good complement to O'Reilly &amp; Associates' earlier <i>Perl Cookbook</i>, by Tom Christiansen and Nathan Perl Torkington (ISBN 1-56592-243-3; reviewed in this column in February, 1999). Where the <i>Cookbook</i> showed how to solve particular small and medium-sized tasks, <i>Mastering Algorithms</i> is a guided tour of classic data structures and algorithms, ranging from linked lists to directed graphs, and from sorting and searching to number theory and cryptography. The book is rich in code -- hardly a page goes by without some Perl or a diagram to illustrate a point -- but the authors have kept these snippets short enough to ensure comprehensibility. They are also careful to write readable Perl (no, that isn't an oxymoron), so that novice or occasional users won't have to flip back and forth between this book and a Perl language reference.</p><p>The excellent index will also help keep back-and-forthing to a minimum: In the month or so that I've had this book on my desk, the index has always taken me straight to what I was looking for. My only complaints are the lack of theoretical analysis after the first few chapters (I don't usually care, but when I do, it's handy to have), and the off-hand way the authors excuse Perl's use of reference counting instead of real garbage collection. Java is proof that modern garbage collection systems are fast enough for production use. It's high time the authors of books such as this one stopped telling people to avoid circular reference patterns (which cause memory leaks), and began admitting that Perl, and other scripting languages, have some ground to make up.</p><p>This brings us to Joshua Engel's <i>Programming for the Java Virtual Machine</i>.  This book is not a reference guide to the JVM, although it can certainly serve as one. Instead, it describes how Java, and other languages, can be compiled to run on the JVM. If you want to know how calls to virtual and static methods differ, how exceptions are implemented, or what adding the <i>synchronized </i>keyword to a method actually does, then this is the book you've been looking for. What's more, this book also describes how features from other languages can be made to run on the JVM. The cores of both Scheme and Prolog are covered, as are Sather-style iterators, parameterized types (like the templates of C++), and full-blown multiple inheritance.</p><p>Like the Perl algorithms book, <i>PJVM</i> is well written, well edited, well illustrated, and has lots of pertinent code examples and a good index. If you are building compilers or tools that target the JVM, or just want a better understanding of what's going on under the hood when your code starts to run, then this book is the place to start.</p><p>Java's teachability is one of its greatest strengths. However, that doesn't make it the right language for every student. In particular, it wasn't designed for number crunching, and doesn't have such basic numeric programming features as operator overloading or data-parallel array notation. Many science departments and engineering schools are now teaching Java anyway, in part because its hypesters have convinced everyone that it is the future, and in part because those hypesters are right.</p><p>Stephen Chapman's <i>Java for Engineers and Scientists</i> (<i>JES</i>) and Richard Davies' <i>Introductory Java for Scientists and Engineers</i> (<i>IJSE</i>) are aimed at different slices of this growing market. <i>JES</i> is a fairly conventional introduction to programming. It covers data  representation, loops and conditionals, classes, and all the other machinery that any beginners' text has to, in more or less the same order as other beginners' texts. It emphasizes numerics more than most such books, and does base some of its exercises on simple physics problems, but not enough to make it clearly better for a first-year engineering programming course than other books.</p><p>IJSE, on the other hand, would be very hard to follow if you didn't already know something about programming, but would be a better choice for a Fortran, C, or MATLAB programmer who wanted to change languages. (It actually has a chapter called "Java for C Programmers.") Davies sometimes takes three sentences to make a point that could as clearly be made in one, and, like Chapman, doesn't go out of his way to point out that current-generation Java systems are much slower than their Fortran, C, or C++ equivalents.</p><p>C++ is the topic of our next book, James Smith's <i>C++ Toolkit for Engineers and Scientists</i> (<i>CTES</i>). I ordered my copy of this one based on the title, and while my first flip through the table of contents was positive, my reaction to the book itself was more equivocal. The best thing about the book for me was its exposition of the design of a medium-sized object-oriented framework for numerical computation, complete with I/O, error handling, and all the other incidental code that makes up half or more of any useful library. Few professional programmers, and even fewer scientists and engineers, have ever been shown how to do this, and I think many would profit from a careful reading of this book.</p><p>However, I do have some reservations about the software in this book. C++ has a reputation for low performance, in part because compilers have not been able to optimize away the temporary variables created by overloaded operators. The template expression techniques developed by Todd Veldhuizen and others now enable Standard C++ to deliver the performance of optimized Fortran-77, without any sacrifice in the level of abstraction. Unfortunately, Smith's software doesn't use these techniques. Like many others in this fast-moving industry, it has simply been overtaken by developments. Despite this, <i>CTES</i> might still be the best place for a scientist or engineer to learn how to build object-oriented libraries, at least until an equally lucid description of the MTL (http://www .mpi.nd.edu/research/mtl/) or Blitz (http:// www.oonumerics.org/blitz/) comes along.</p><p>The last pair of books on this month's list examine two activities that are probably equally foreign to true believers in UNIX: quantum computing and using Visual Basic to drive Microsoft Word. (If I had to wager, I'd bet that my UNIX friends would start using the former long before they'd start using the latter...) Michael Brooks, the editor and coauthor of <i>Quantum Computing and Communications</i>, is a physicist and science journalist. The slim book he has produced is a nontechnical introduction to the idea of using quantum uncertainty to speed up certain classes of computation, and to ensure secure communication. There are very few equations, and some occasional gushing, but overall this is a good pop-sci look at something that might be computing's next really big idea.</p><p>The subject of Steve Roman's <i>Learning Word Programming</i> might not be anybody's next big thing, but that doesn't diminish its utility. Microsoft's use of a single scripting language is a big step forward from UNIX's reliance on shell scripts, Perl, Emac's Lisp, and dozens of opaque configuration files. Most people think of Microsoft Office as a package for accountants and small businesses. In the hands of a competent VB programmer, however, Word, Excel, and other tools are more like a library of software components. Roman does spend time talking about how to use VB to write Word macros, but he also describes how other VB applications can use Word to check spelling, format text, and so on. The book jumps around between topics more than I would have liked, and there are places where I felt that Roman stopped half-way through an explanation, but this book is still a worthy entry in O'Reilly's growing list of Microsoft titles.</p><p><b>DDJ</b></p></body></html>