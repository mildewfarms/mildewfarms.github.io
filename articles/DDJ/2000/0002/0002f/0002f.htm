<html><head><title>Feb00: OpenCard Framework Application Development</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>OpenCard Framework Application Development</h1><p><i>Dr. Dobb's Journal</i> February 2000</p><h2>Using Java to build platform-independent smartcards</h2><h3>By Vesna Hassler and Oliver Fodor</h3><I>Vesna is a professor in the Distributed Computing Group at the Technical University of Vienna. She can be contacted at hassler@ infosys.tuwien.ac.at. Oliver is a graduate student at the Technical University of Vienna. He can be reached at ofodor@ infosys.tuwien .ac.at.</I><hr><p>The Personal Computer/Smart Card Interface (PC/SC) and OpenCard Framework are two industry initiatives to define a standard way to integrate smartcards into computer systems. With PC/SC, emphasis has been placed on the interoperability of smartcards and card terminals, and on the integration of those card terminals into Microsoft Windows. (Interoperability for smartcards means that one manufacturer's card or card reader can be used with another manufacturer's.) Members of the OpenCard (http://www .opencard.org/) and PC/SC (http://www .smartcardsys.com/) consortiums realized the need for a common framework to support smartcards on various platforms (ranging from network computers to smart phones and set-top boxes), to securely authenticate users, and to personalize these otherwise anonymous devices (similar to GSM cell phones that are activated and personalized via inserting a smartcard). OCF took advantage of some features already available within PC/SC and other smartcard standards, then focused on two new areas -- independence from host operating systems, and transparent support of different multiapplication cards and management schemes.</p><p>In this article, we'll discuss OCF, then present an OCF-based terminal (reader) application. The complete source code for this Java applet is available electronically (see "Resource Center," page 7). Although the examples and techniques are based on Schlumberger's Cyberflex Open16K card family supporting JavaCard 2.0 API, OCF is platform independent. For more information on JavaCard development, see "JavaCard Application Development," <i>DDJ</i>, February 1999. Likewise, Version 1.0 of the PC/SC standard is available at http:// www.smartcardsys.com/.</p><DDJADVERTISEMENT INLINE><h3>What Is OCF?</h3><p>OCF is a high-level interface that provides a framework for developing terminal (reader) applications for smartcards in Java. It is independent of the underlying operating system because it is implemented in Java. OCF supports multiapplication cards, such as JavaCard. Its target platforms are network computers, web browsers, and any other platform that runs Java and needs to interact with smartcards. Java applications running on a desktop computer can use OCF to access smartcards. <A NAME="rf1"><A HREF="0002ff1.htm">Figure 1</A> illustrates the general OCF architecture:</p><ul>  <li>The Card Applet is provided by the card developer and is running on a smartcard.  <li>The <i>CardTerminal</i> classes are provided by vendors who want to make their card terminals available to OCF applications. A <i>CardTerminal</i> class encapsulates the card-terminal behavior and a <i>CardTerminalFactory</i> class. The factory is used by OCF to create <i>CardTerminal</i> instances when the Framework is initialized. The card-terminal factory of each card terminal attached to the desktop computer has to be registered with the <i>CardTerminalRegistry</i>.  <li>OCF provides methods and classes for <i>CardService</i> to access the card (<i>CardChannel</i>, <i>CardServiceScheduler</i>, and the like). Because there may be more than one instance of card services per card, the <i>CardServiceScheduler</i> serializes the access of different services to the <i>CardChannel</i>, a communication link to the card that is represented by the <i>CardID</i>.  <li>The <i>CardService</i> classes implement a standard API, thus hiding the smartcard specifics. It generates application protocol data units (APDUs) and communicates with the card to support high-level API functions. A <i>CardServiceFactory</i> is associated with each <i>CardService</i> implementation and is capable of constructing it. The <i>CardServiceFactory</i> identifies the card or cards for which the <i>CardService</i> was designed. When a smartcard is inserted into the reader, OCF goes through its list of registered card-service factories (within the card-service registry) and instantiates card services corresponding to the card.  <li>Currently, OCF defines a few card-service interfaces (<i>FileAccessCardService</i> or <i>AppManagementCardService</i>, for instance) to make the common smartcard functions available to you. Smartcard manufacturers are supposed to provide implementations of these classes and the corresponding factory classes, but at this time they are generally not available.  <li>The terminal application is written by you. All you need to know is the API provided by the <i>CardService</i>.</ul><h3>Development Environment</h3><p>To develop an application using JavaCard and OCF, you need:</p><p></p><ul>  <li>JDK 1.1.(6 or higher).  <li>A smartcard conforming to the JavaCard 2.0 (or higher) API specification.  <li>An applet loader to load applets onto the card.  <li>A card terminal supported by OCF.  <li>The OCF build tree (currently Version 1.1).  <li>OCF <i>CardTerminal</i> classes for the card terminal.</ul><p>Most card vendors provide an SDK that supports features for managing applets and communication with the card. For example, the applet loader provided in the Cyberflex Open16K development kit needs PC/SC, but you can use it with a pure Java applet loader. However, if you use a Java loader based on the Java Communications API, you need to remove PC/SC because it captures the necessary communication port.</p><h3>Configuring the  Framework</h3><p>In OCF 1.1, the code making up the framework is organized into components (base-core.jar, base-opt.jar, and the like). Each component is made up of one or more Java packages that provide a well-defined functionality for you.</p><p>Depending on the card terminal you use, you should install the <i>CardTerminal</i> classes. We use the Litronic 210 1.0b OCF CardTerminal driver that uses the Java Communication API (javax.comm 2.0) to access the device connected to a serial port. The Java Communications API can be used to write platform-independent communications applications for technologies such as voice mail, fax, and smartcards.</p><p>OCF obtains some configuration information via the Java system properties. The Java system properties are platform-independent mechanisms to make operating system and run-time environment variables available to programs. OCF provides a utility class to load properties from a file called "opencard.properties."</p><p>You can configure the card terminal registry via the <i>OpenCard.terminals</i> property, and the card service registry via the <i>OpenCard.services</i> property. <A NAME="rl1"><A HREF="#l1">Listing One</A> is the opencard.property file for the <i>SimpleString</i> card service.</p><h3>Card Applet</h3><p>The <i>SimpleString</i> applet lets you write a string to the card (the <i>setString()</i> method), and read it back from the card (<i>getString()</i> method). The card applet class must store strings as byte arrays, but the terminal application can easily handle type translation to store strings.</p><p>The <i>setString()</i> method stores a string on the card; see <A NAME="rl2"><A HREF="#l2">Listing Two</A>. The <i>setIncomingAndReceive()</i> method in the APDU class is used to both set the JavaCard Runtime Environment (JCRE) to receive mode and to receive any available data into the APDU buffer. The command data will not be in the APDU buffer until it is read by the applet calling <i>setIncomingAndReceive()</i> or <i>receiveBytes()</i>. The second method can be called only after <i>setIncomingAndReceive()</i> when there is more data than can fit into the APDU buffer. The APDU buffer has a minimum size of 37 bytes, and the maximum size is determined by you (255 bytes on Cyberflex Open16K).</p><p>The <i>getString()</i> method retrieves the string from the card (see <A NAME="rl3"><A HREF="#l3">Listing Three</A>). To access the data in the APDU buffer, the applet must retrieve a reference to the APDU data buffer by calling the APDU <i>getBuffer()</i> method.</p><p>When a client application asks for the string, it has no way of knowing how long the string really is. We handle this in the following way:</p><p>1. The client sends a <i>getString</i> APDU with the length field set at 0.</p><p>2. The card responds with a status word set at 0x50<i>yy</i>, where <i>yy</i> is the string length (hex).</p><p>3. The client sends the <i>getString</i> APDU again, but this time with the length field set at <i>yy</i> (string length).</p><p>The response APDU may or may not contain data. If the response doesn't contain data, the applet need not do anything but return.</p><p>To set the JCRE mode to send, the APDU method <i>setOutgoing()</i> is called (see <A NAME="rl3"><A HREF="#l3">Listing Three</A>). This method returns the number of response bytes expected by the client application. This number corresponds to the number of bytes expected by the command APDU (in most cases the Le byte) to which the applet is responding.</p><p>The <i>setOutgoingLength()</i> method informs the JCRE about the number of bytes the applet will be sending. The <i>sendBytes()</i> method sends a specified number of response bytes from the APDU buffer. </p><p>The APDU class contains the <i>setOutgoingAndSend()</i> method combining the three methods described in this section. Using this method, the data are actually not sent until the applet returns from the <i>process()</i> method, at which time the data are combined with the status bytes. So, once <i>setOutgoingAndSend()</i> is called, the applet cannot alter the APDU buffer until <i>process()</i> returns.</p><p>To compile the applet, you can use a standard Java compiler (javac, for example). For example, the Cyberflex post-processor mksolo requires using javac with the debugging option "-g." Before you can load the applet to the card, it must be converted (that is, previously compiled with mksolo) to a form that the JavaCard can understand. This is done by the off-card part of the JavaCard Virtual Machine. Now you can load, install, and register the applet using a proprietary card loader provided by your card SDK.</p><h3>Card Service</h3><p>Once the applet is properly loaded, installed, and registered on the card, you need to provide a corresponding terminal application for accessing the card. In other words, a special card service that supports the interfaces of the card applet is necessary.</p><p>At this point, we'll introduce several OCF features by a demo card service for the <i>SimpleString</i> applet. The card service is not suitable for the multiapplication/multiterminal scenario; it only supports one terminal application accessing one card applet at a time.</p><p>A card service is instantiated by the corresponding card-service factory registered with OCF. The instantiation is performed in two steps. First, the default constructor is called, then the <i>initialize()</i> method is called, which we override. In this case, we must call the <i>super.initialize()</i> method.</p><p>The card service instance provides the methods for application use. We'll provide two methods corresponding to the two functions of the card: the <i>writeString()</i> and <i>readString()</i> methods. To communicate with the card, the Framework's <i>CardChannel</i> class is used. It must be allocated (<i>allocateCardChannel()</i>) before use, and deallocated (<i>releaseCardChannel()</i>) after use. The <i>allocateCardChannel()</i> method makes sure that a card channel is available for communication with the card. This method blocks other threads until the active thread releases the channel. The card applet must be selected before it can accept APDU commands (see <A NAME="rl4"><A HREF="#l4">Listing Four</A>). If the <i>AppMgmntCardService</i> class (see <A NAME="rf1"><A HREF="0002ff1.htm">Figure 1</A>) was provided by Cyberflex, methods for selecting applets would already be provided (Schlumberger has announced planned support for the service).</p><p>We also have to define a method for sending APDUs to the card (see <A NAME="rl5"><A HREF="#l5">Listing Five</A>). The <i>getCardChannel()</i> method returns a reference to a <i>CardChannel</i> object that can be used for communication with the card. The <i>CardChannel</i> offers methods for sending commands and receiving responses.</p><h3>Card-Service Factory</h3><p>To create a card-service instance, OCF needs a card-service factory. Each smartcard has a unique identifier that is returned by the card in the Answer To Reset (ATR) message when it is powered up (in our case it is <i>cyberFlexATR[]</i>). <i>CardID</i> is an OCF class for handling unique smartcard identifiers that are returned in an ATR. Our <i>SimpleStringCardServiceFactory</i> class can only create instances of <i>SimpleStringCardService</i> (see <A NAME="rl6"><A HREF="#l6">Listing Six</A>).</p><p>Now we are ready to register our service with OCF (see <A NAME="rl7"><A HREF="#l7">Listing Seven</A>). Additionally, all card-service factories must override two abstract methods that are used by OCF to instantiate services -- <i>knows()</i> and <i>cardServiceClasses()</i>. The <i>knows()</i> method indicates whether this factory knows the smartcard operating system (<i>cardID</i>). If it does, the factory is able to instantiate card services for the card.</p><p>The card-service factory of each service supported by OCF has to be registered with the card-service registry. To register the factory, add <i>OpenCard.services = samples.simplestring.SimpleStringCardServiceFactory</i> to the opencard.properties file.</p><h3>Terminal Application</h3><p>The SimpleStringDemo terminal application (available electronically; see "Resource Center," page 7) writes a string to the card and reads it back. Importing the <i>SimpleStringCardService</i> lets you use the high-level interface previously defined. At the beginning we have to initialize OCF. OCF offers two approaches to find out whether a card supporting a particular service is inserted in the card terminal. The first one works with event notification, an event being card insertion into or card removal from the terminal. The second approach uses the <i>SmartCard.waitForCard()</i> method, which delays the program execution until a card supporting specified service is inserted into the card terminal. In our terminal application, OCF waits for a card supporting the <i>SimpleString</i> card service (see <A NAME="rl9"><A HREF="#l9">Listing Nine</A>). Now we can instantiate the <i>SimpleStringCardService</i> and start using the card-service methods (<i>writeString()</i> and <i>readString()</i>).</p><h3>Conclusion</h3><p>JavaCard and OCF provide a development environment that makes it possible for you to create platform-independent smartcard-based applications. Because the concept is relatively new (some parts are still under development) and rapidly changing (for example, the latest version of the JavaCard API is 2.1, and our examples are written for 2.0), it is not yet quite suitable for developing industry- or commercial-strength applications. However, these two concepts -- together with the Sun Microsystem's JavaCommerce platform -- are promising to develop into a pure Java development environment for e-commerce applications. </p><p></p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>OpenCard.services = samples.simplestring.SimpleStringCardServiceFactoryOpenCard.terminals = dk.itplus.smartcard.terminal.litronic210.                     LitronicCardTerminalFactory|Litronic210|Litronic210|COM1 </pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>private void setString(APDU apdu){        buffer = apdu.getBuffer();        // receive data from terminal        byte size = (byte)(apdu.setIncomingAndReceive());        byte index;        TheBuffer[0] = size;        // store string and its length        Util.arrayCopy(buffer, ISO.OFFSET_CDATA, TheBuffer,                                                    (short)1, (short)size);        return;}</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>private void getString(APDU apdu) {        buffer = apdu.getBuffer();        byte numBytes = buffer[ISO.OFFSET_LC];        if (numBytes == 0)        ISOException.throwIt((short)(SW_WRONG_LENGTH + TheBuffer[0]));        apdu.setOutgoing();        apdu.setOutgoingLength(numBytes);        Util.arrayCopy(TheBuffer,(short)1,buffer,(short)0,(short)numBytes);        apdu.sendBytes((short)0,(short)numBytes);        return;}</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>public void selectApplet() throws CardServiceException{    try    {        allocateCardChannel();        sendAPDU(selectRoot);        sendAPDU(selectApp);    } catch(Exception e)    {        e.printStackTrace();        throw new CardServiceException();    } finally    {        releaseCardChannel();    }    appletSelected = true;    return;</pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five</H4><pre>private ResponseAPDU sendAPDU(byte[] apdu) throws CardTerminalException{     // Set up the command APDU     CommandAPDU commandAPDU = new CommandAPDU(apdu);     ResponseAPDU responseAPDU=getCardChannel().sendCommandAPDU(commandAPDU);     return (responseAPDU);}</pre><P><A HREF="#rl5">Back to Article</A></P><H4><A NAME="l6">Listing Six</H4><pre>public SimpleStringCardServiceFactory()     {     try {          cyberFlexCID = new CardID (cyberFlexATR);     } catch ( Exception e ) {     }}</pre><P><A HREF="#rl6">Back to Article</A></P><H4><A NAME="l7">Listing Seven</H4><pre>// register card service with OCFstatic {        services_.addElement(SimpleStringCardService.class);}</pre><P><A HREF="#rl7">Back to Article</A></P><H4><A NAME="l8">Listing Eight</H4><pre>protected Enumeration cardServiceClasses(CardID cid){    return services_.elements();}public boolean knows(CardID cardID){    // check whether the factory knows the smartcard OS    if (cardID.equals(cyberFlexCID))    {         return true;    } else    {         return false;    }}</pre><P><A HREF="#rl8">Back to Article</A></P><H4><A NAME="l9">Listing Nine</H4><pre>// initialize OCFSmartCard.start();CardRequest cr = new CardRequest(SimpleStringCardService.class);// wait for card supporting SimpleStringCardServiceSmartCard sc = SmartCard.waitForCard(cr);// instantiate card serviceSimpleStringCardService ssp = (SimpleStringCardService)sc.                        getCardService(SimpleStringCardService.class, true);</pre><P><A HREF="#rl9">Back to Article</A></P></body></html>