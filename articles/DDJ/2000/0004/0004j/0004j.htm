<html><head><title>Apr00: Programmer's Toolchest</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Examining the PyGtk Toolkit</h1><p><i>Dr. Dobb's Journal</i> April 2000</p><h2>A powerful environment for  rapidly developing GUI-based apps</h2><h3>By Mitch Chapman and Brian Kelley</h3><I>Mitch and Brian are researchers at Bioreason. They can be contacted at chapman@bioreason.com and kelley @bioreason.com, respectively.</I><hr><p>Gtk+ is a rich GUI toolkit with excellent interactive performance. It includes a variety of widgets, such as multicolumn lists and hierarchical trees, which are not found in older toolkits such as Tcl/Tk. However, Gtk+ is written in C, making it a relatively poor choice for rapid prototyping -- especially for programmers accustomed to the object-oriented facilities and automatic memory management of more modern languages. </p><p>Python, on the other hand, is a powerful, object-oriented programming language. Its reference-counted memory management, versatile built-in types, and strong run-time type checking make it suitable for everything from rapid prototyping to full-blown GUI applications. Python's default GUI toolkit, Tkinter, provides an interface to the Tcl/Tk widget set. While it's certainly powerful, many Python developers have nonetheless complained about the relatively low performance and aging widget set of Tcl/Tk.</p><DDJADVERTISEMENT INLINE><p>The PyGtk package addresses both of these problems. Developed by James Henstridge (http://www.daa.com.au/~james/ pygtk/), PyGtk provides a Python interface to Gtk+. It brings the benefits of a high-level programming language to Gtk+ developers, and gives Python programmers access to a modern, high-performance GUI toolkit. The result is a great environment for rapid development of GUI-based applications.</p><p>However, most of the effort in developing Gtk+ and PyGtk has gone to the code itself. While improving rapidly, the documentation still has many gaps. There are few published examples of how to perform common tasks such as creating modal dialogs, controlling <i>GtkCList</i>s, and the like.</p><p>At Bioreason, we use PyGtk extensively. Having learned the hard way how to take advantage of the toolkit, we'll share some techniques that you'll find useful as you move to PyGtk from Python's default Tkinter UI toolkit.</p><p>More specifically, we'll demonstrate several common PyGtk coding techniques and describe relatively unfamiliar widgets such as GtkCTree. All of the examples have been tested under Linux 2.0.36, using Python 1.5.2 (http://www.python .org/), Gtk+ 1.2.3, and PyGtk 0.6.2.</p><h3>Shutting Down an Application</h3><p>One of the first surprises in PyGtk programming is that, by default, an application doesn't exit when you close its main window.</p><p>When users close a window via the window manager, the <i>GtkWindow</i> widget emits a <i>delete_event</i>. By default, the event is ignored, but you can use the widget's <i>connect()</i> method to request a callback whenever a <i>delete_event</i> occurs. Your callback can cause application cleanup, then cause the application to exit by calling PyGtk's <i>mainquit()</i> function; see <A NAME="rl1"><A HREF="#l1">Listing One</A>.</p><h3>Aligning Widgets</h3><p>Widget alignment in PyGtk can be as simple as in Tkinter -- if you use <i>GtkTable</i> to manage the layout. However, you need to be careful about the order in which you make widgets visible and add them to tables.</p><p>You can allocate the number of rows and columns within a <i>GtkTable</i>, or let it grow as needed to accommodate added children. If you choose the latter approach, you may find yourself cursing at the inconsistent geometry management of <i>GtkTable</i>.</p><p><A NAME="rl2"><A HREF="#l2">Listing Two</A> shows one way to add labeled entries to a <i>GtkTable</i>. When class <i>UI</i> is instantiated, it creates a new <i>AppWindow</i> and adds a <i>GtkVBox</i> as its child. The top of the <i>GtkVBox</i> will hold the table of form entries, and the bottom will contain a button for adding new entries at run time. As each entry is added, it is appended to the UI's entry instance variable.</p><p>Method<i> UI.addEntry()</i> adds a new labeled entry to the <i>AppWindow</i>. It begins by figuring out which row of the table will contain the entry. Then it creates a <i>GtkLabel</i>, setting the horizontal alignment to 1.0 (that is, to the right edge of the label's allocated space) and the vertical alignment to 0.5 (centered). The label extends from column 0 to column 1 of the table. Next, a <i>GtkEntry</i> is added, extending from column 1 to column 2 of the same row. The <i>GtkEntry</i> is added to the list of entries contained in the UI instance.</p><p>Unfortunately, this implementation has a problem. If you run the program, you'll see a window with three entries. But if you click the Add Row button, you'll see a new entry, labeled Row 3, which doesn't have the correct vertical spacing. Click Add Row again, and you'll find that subsequent entries are added with the correct spacing; see <A NAME="rf1"><A HREF="0004jf1.htm">Figure 1</A>. This appears to be a bug in Gtk+. <A NAME="rl3"><A HREF="#l3">Listing Three</A> is a workaround: After adding each new entry row, explicitly set the spacing for that row.</p><p>The listings work around one other geometry-management idiosyncrasy of Gtk+: If you invoke the <i>show()</i> method of a <i>GtkWindow</i> before showing its children, it will not properly adjust its size to accommodate its children. That's why the <i>UI.mainloop()</i> method was added. It ensures that the application's main window becomes visible at the last possible moment, after the <i>show()</i> method has been invoked on its immediate children.</p><p>If you ever find yourself needing to add children to a <i>GtkWindow </i>after invoking its <i>show()</i> method, you can force it to recalculate its geometry, by invoking its <i>check_resize() </i>method.</p><h3>Controlling Spinbutton Limits</h3><p>Spinbuttons come in handy in applications such as database editors, where users want to browse through a set of available records. But in these applications, spinbuttons must be able to dynamically adjust their limits as the number of records in the database changes.</p><p><i>GtkAdjustment</i> widgets control the operating ranges of spinbuttons, scrollbars, text widgets, progress bars, and a host of other widgets. You can change the limits for a spinbutton, scrollbar, or scale widget by asking it for its adjustment widget, then manipulating the settings of the adjustment.</p><p>PyGtk 0.6.2 has a few bugs that make it difficult to change an adjustment in place. Fortunately, PyGtk does let you change the ranges for spinbuttons and the like, by creating new <i>GtkAdjustment</i>s<i> </i>and associating them with the widgets. You can even couple spinbuttons, scrollbars, and scales together by associating them with the same <i>GtkAdjustment</i> instance.</p><p><A NAME="rl4"><A HREF="#l4">Listing Four</A> shows one way to dynamically adjust the ranges of a spinbutton, scrollbar, and scale. The script defines a UI containing these elements, and sets all three elements to use the same <i>GtkAdjustment</i> (with a default upper limit of 10.0). Thanks to the <i>connect() </i>call in <i>UI.__init__()</i>, users can change the upper limit of all three widgets by typing a new value into the spinbutton's entry field and hitting return.</p><p>The <i>connect()</i> call causes <i>UI.spinEntryActivateCB()</i> to be invoked whenever the user hits return in the spinbutton's entry field. <i>spinEntryActivateCB()</i> starts by getting the current text value from the field and trying to convert it to a number. (The <i>get_text()</i> method is used instead of <i>get_value()</i> because the latter method clips the user's input to the current spinbutton bounds before converting it to a number.)</p><p><i>UI.setUpperBound()</i> checks to ensure the new upper bound is greater than the current lower bound; by default, spinbuttons have a lower bound of zero.</p><p>It should be possible to get at the spinbutton's <i>GtkAdjustment</i> widget by calling its <i>get_adjustment()</i> method. But, as noted, <i>GtkAdjustment.get_adjustment()</i> contains a bug, so <i>setUpperBound()</i> gets at the adjustment the hard way, using code from the <i>_gtk</i> module underlying PyGtk's <i>gtk</i> module.</p><p>Next, <i>setUpperBound()</i> constructs a new <i>GtkAdjustment</i> for the spinbutton to use. The new adjustment will be identical to the current adjustment, but it has a different upper limit (namely, the value provided by users).</p><p>By default, a new <i>GtkSpinButton</i> has a climb rate, or <i>step_increment</i>, of 1. But its associated <i>GtkAdjustment</i> has a <i>step_increment</i> of 0. So when creating the new <i>GtkAdjustment</i>, <i>setUpperBound()</i> takes care that the <i>step_increment</i>, <i>page_increment</i>, and <i>page_size</i> are greater than zero. Without this precaution, users would be faced with spinbuttons that never change their value, no matter how many times the up and down arrows are clicked.</p><p>Finally, <i>setUpperBound()</i> assigns the new <i>GtkAdjustment</i> instance to each of the UI widgets. Because they all refer to the same adjustment, when one of the widgets changes values, the others change in lockstep with it.</p><h3>Working with <i>GtkCTree</i>s</h3><p><i>GtkCTree</i> is one of the most useful and poorly documented of the Gtk+ widgets. <i>GtkCTree</i> is inherited from a <i>GtkCList</i> and shares all of the capabilities of the <i>CGtkList</i>. The main difference is that the first column of a <i>CTree</i> expands into a tree view; see <A NAME="rf2"><A HREF="0004jf2.htm">Figure 2</A>. A <i>CTree</i> is initialized exactly as a <i>CList</i> with the desired number of columns and list of column titles. Because the tree can be expanded by users and it is difficult to determine the full extent of the widget, a <i>GtkCTree</i> should be embedded in a <i>GtkScrolledWindow </i>widget. </p><p>Tree nodes can be inserted and removed dynamically, see <A NAME="re1"><A HREF="0004je1.htm">Example 1</A>(a). If a parent is given, the node is added as a child of the parent node. A value of <i>None</i> adds the node to the top level of the tree. Insertion requires that the value of all columns be specified. Each column must have a text value. However, pixmaps can also be specified. For example, insertion arguments <i>pixmap_closed</i>, <i>pixmap_opened</i>, <i>mask_closed</i>, and <i>mask_opened</i> can be used to specify the opened and closed pixmaps and masks for the node. For an easy way of creating <i>pixmap</i>s, see the function <i>gtk.create_pixmap_from_xpm()</i>. The parameter <i>is_leaf=1</i> appears to prevent children to be added to the node, and the parameter <i>expanded=1</i> expands the node's children by default.  </p><p>Inserting nodes dynamically requires some bookkeeping. If a node has no children, the expansion image (the plus or minus sign) is not displayed. For all intents and purposes, the node cannot be expanded. If a node's children are to be loaded dynamically, a bookkeeping child should be included in the tree so the node can be expanded. Once the children are loaded, this node can be removed. To assist this process, you can set the data of a node using the function <i>GtkCree.node_ set_row_data(node, data),</i> which is useful when using the <i>tree-expand</i> signal. Setting the data to an integer or string yields a hashable value for looking up the expanded node in a Python dictionary. Available electronically (see "Resource Center," page 5), you'll find a simple example of a file browser using this technique.</p><p>Each column in a <i>CTree</i> has a <i>GtkButton</i> widget that displays the column title. Pop-up menus can be bound to these menus to allow sorting or other operations. The <i>GtkButton</i> is available as the parent of the column widget and can be obtained as <i>GtkCTree.get_column_widget(column_index)["parent"]</i>. The process for actually determining this step required us to look at the PyGtk source and use Python interactively. Unfortunately, in this respect, the PyGtk hierarchy is not the same as the Gtk hierarchy, and it is in areas like this where the available documentation is lacking. </p><p>Like <i>GtkCList</i>, <i>GtkCTree</i> only displays a fixed number of columns. This can be annoying if information is dynamically loaded because rebuilding the <i>CTree</i> can be time consuming. Fortunately, just about everything in Gtk can be hidden, including the displayed columns using the <i>GtkCTree</i> method <i>set_column_visibility</i>. However, using features like these sometimes causes slowdowns when redrawing the tree. A workaround is to freeze the tree, perform the necessary operations, then thaw the tree. This prevents drawing every step along the way. Additionally, wrapping the freeze in a <i>try</i> block, in which the operations are performed, and thawing the tree in the final clause lets errors be caught and guarantees the screen will repaint; see <A NAME="re1"><A HREF="0004je1.htm">Example 1</A>(b). The full source to a <i>CTreeInsert</i> widget (where the titles are bound to pop-up menus and columns can be added dynamically) is available electronically.</p><h3>Defining Modal Dialogs</h3><p>In <i>Gtk+/GNOME Application Development</i> (accessible online at http://developer.gnome .org/doc/GGAD/ggad.html), Havoc Pennington cautions against overuse of modal dialogs. He notes that many users find them annoying. Nevertheless, there are times when you do need to implement modal dialogs. And developers familiar with writing modal dialogs in Python/Tkinter will find enough differences in the Gtk+ API to make the process confusing.</p><p>Until recently, the hard part of developing a Gtk+ modal dialog was discovering the right way to make it modal. The Gtk+ FAQ recommends using <i>grab_add()</i> and <i>grab_remove()</i> to route all user inputs to a modal dialog, but the API included a <i>gtk_window_set_modal()</i> function. Pennington recommends using <i>gtk_window_set _modal()</i>; because his book is likely to become the standard Gtk+ reference, perhaps the documentation conflict will be resolved soon.</p><p>After figuring out how to route all user inputs to the dialog, you still need a modal event loop. PyGtk provides a simple, if unintuitive, solution -- just invoke <i>mainloop()</i> recursively, and terminate the modal loop by invoking <i>mainquit()</i>; see <A NAME="re2"><A HREF="0004je2.htm">Example 2</A>.</p><p>A few more steps are needed to complete a PyGtk modal dialog. For example, you need to call <i>set_transient_for()</i> on the dialog to ensure that it remains stacked in front of the window that launched it. Otherwise, users could raise the window in front of the dialog, obscuring it and creating the appearance that your application is hung.</p><p>Finally, if you plan on reusing your dialog instances instead of creating a new dialog every time one is needed, then you need to protect the dialog against destruction, just as if it were a top-level window. If you don't supply your own handler for the dialog's <i>delete_event</i>, the widgets inside the dialog will be destroyed the first time users dismiss it. Thereafter, users will be faced with an empty window and a series of Gtk-CRITICAL error messages each time the dialog is re-displayed.</p><p>A <i>ModalDialog</i> class that does all of these basic steps is available electronically. In typical Python fashion, the module includes a <i>main()</i> function that is invoked when the module is run as a standalone program. The mainline serves both as an example of how to use the <i>ModalDialog</i> class, and as a simple unit test to verify that <i>ModalDialog</i> behaves correctly.</p><h3>Troubleshooting</h3><p>Say your PyGtk application isn't behaving as expected. You've checked the Gtk+ FAQ, scanned the PyGtk and Gtk+ mailing list archives, and still have no idea what the problem is. What should you do? We've found a couple of useful approaches.</p><p>One strategy is to use the source code, together with the online Gtk+ reference pages. So, if you're trying to learn how to work with a new widget class, start with the gtk.py source file. By looking at the class definitions, you can gain a rough idea of what the widget can do.</p><p>All too often, however, the method and parameter names by themselves fail to tell what a method may do; so your next stop should be the online Gtk+ reference. Increasingly, it provides good summaries of the corresponding Gtk+ functions and their parameter lists.</p><p>However, the Gtk+ documents are chasing a moving target. Often, they simply list the available functions and provide no description of their intent thus, it's a good idea to keep the Gtk+ source tree lying around. Once you know the name of the function in which you're interested and the widget class to which it applies, you can navigate directly to the implementation of the function to see how it works.</p><p>The main directory of the PyGtk distribution contains a module called "description.py." This module contains no executable code; instead, it provides stubbed definitions for Gtk+ classes such as <i>GtkCTreeNode</i> and <i>GdkColor</i>. These classes don't appear in gtk.py; they are implemented completely in ANSI C in gtkmodule.c, and usually appear only as the return values of other PyGtk methods. When you find yourself with a reference to one of these objects, description.py gives you some idea of what you can do with it.</p><p>But, in many cases, the quickest way to find out what a function does is to invoke it. After all, Python is an interpreted language, and you can usually throw together an exploratory program in just a few minutes. For example, we wrote short test programs to figure out what <i>GtkCTree</i>'s <i>get_column_widget()</i> was doing, by traversing the widget hierarchy it returned and printing out widget classes along the way.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>#!/usr/bin/env python"""AppWindow.py:This module provides an application window --a GtkWindow that knows when to quit."""import gtkclass AppWindow(gtk.GtkWindow):    """This is just a GtkWindow which exits its event loop when destroyed."""    def __init__(self, title=None):        """Initialize a new instance.        If specified, `title' will be displayed in the window's title bar."""        gtk.GtkWindow.__init__(self)        if title:            self.set_title(title)        self.connect("delete_event", self.quit)    def quit(self, *args):        """Exit the application -- or at least exit its event loop."""        gtk.mainquit()def main():    """Module mainline (for standalone execution)"""    win = AppWindow(title="Sample App Window")    label = gtk.GtkLabel("Hello, world.")    win.add(label)    label.show()    win.show()    gtk.mainloop()if __name__ == "__main__":    main()</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>#!/usr/bin/env python"""This module demonstates techniques for aligning labels in a form."""import gtkimport AppWindowclass UI:    """Builds a form consisting of several rows of labelled entries."""    def __init__(self):        """Initialize a new instance."""        self.top = AppWindow.AppWindow(title="Alignment Demo")        self.box = gtk.GtkVBox()        self.top.add(self.box)        self.box.show()        self.table = gtk.GtkTable(cols=2)        self.box.pack_start(self.table)        self.table.show()        self.addBtn = gtk.GtkButton("Add Row")        self.addBtn.connect("clicked", self.addBtnCB)        self.box.pack_end(self.addBtn, fill=gtk.FALSE, expand=gtk.FALSE)        self.addBtn.show()        # Keep a list of the entries added.        self.entry = []    def mainloop(self):        """Show the window and run the main event loop."""                # If you don't check_size() on the containing window after setting the        # border width, you may get a nasty surprise: a minimally-sized window.        # Work around the problem by setting the border width,        # spacing, etc. _after_ creating all of the tablel content and        # _before_ showing the containing window.        self.table.set_border_width(5)        self.table.set_col_spacings(5)        self.table.set_row_spacings(5)        self.top.show()        gtk.mainloop()    def addEntry(self, label):        """Add a new labelled entry.        `label' specifies the label to be displayed."""        # Add each new entry to the next available row.        row = len(self.entry)                l = gtk.GtkLabel(label + ":")        l.set_alignment(1.0, 0.5)        self.table.attach(l, 0, 1, row, row + 1)        l.show()        e = gtk.GtkEntry()        self.table.attach(e, 1, 2, row, row + 1)        e.show()        self.entry.append(e)        return e    def addBtnCB(self, *args):        """Callback invoked when the Add button is clicked."""        self.addEntry("Row %d" % len(self.entry))def main():    """Module mainline (for standalone execution)"""    ui = UI()    for label in ["Name", "Quest", "Favorite Color"]:        ui.addEntry(label)    ui.mainloop()if __name__ == "__main__":    main()</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>#!/usr/bin/env python"""This module shows ways of aligning labels in a form -- and also howto maintain spacing for dynamically-added labels."""import gtkimport AppWindowclass UI:    """Builds a form consisting of several rows of labelled entries."""    def __init__(self):        """Initialize a new instance."""        self.top = AppWindow.AppWindow(title="Alignment Demo")        self.box = gtk.GtkVBox()        self.top.add(self.box)        self.box.show()        self.table = gtk.GtkTable(cols=2)        self.box.pack_start(self.table)        self.table.show()        self.addBtn = gtk.GtkButton("Add Row")        self.addBtn.connect("clicked", self.addBtnCB)        self.box.pack_end(self.addBtn, fill=gtk.FALSE, expand=gtk.FALSE)        self.addBtn.show()        # Keep a list of the entries added.        self.entry = []    def mainloop(self):        """Show the window and run the main event loop."""        # If you don't check_size() on the containing window after setting the        # border width, you may get a nasty surprise: a minimally-sized window.        # Work around the problem by setting the border width,        # spacing, etc. _after_ creating all of the tablel content and        # _before_ showing the containing window.        self.table.set_border_width(5)        self.table.set_col_spacings(5)        self.table.set_row_spacings(5)                self.top.show()        gtk.mainloop()    def addEntry(self, label):        """Add a new labelled entry.        `label' specifies the label to be displayed."""        # Each new entry is added to the next available row.        row = len(self.entry)                l = gtk.GtkLabel(label + ":")        l.set_alignment(1.0, 0.5)        self.table.attach(l, 0, 1, row, row + 1)        l.show()                e = gtk.GtkEntry()        self.table.attach(e, 1, 2, row, row + 1)        e.show()        self.entry.append(e)        # set_row_spacings() affects only the rows of which the        # table is already aware, or so it seems.        # To work around this, set the spacing for each row as it is added.        if row &gt; 0:            self.table.set_row_spacing(row - 1, 5)        return e    def addBtnCB(self, *args):        """Callback invoked when the Add button is clicked."""        self.addEntry("Row %d" % len(self.entry))def main():    """Module mainline (for standalone execution)"""    ui = UI()    for label in ["Name", "Quest", "Favorite Color"]:        ui.addEntry(label)    ui.mainloop()if __name__ == "__main__":    main()</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>#!/usr/bin/env python"""This module shows how to adjust the limits on a GtkSpinButton, andhow to use GtkAdjustments to keep several widgets in lock step."""import gtk, GTK, AppWindowclass UI:    """Demonstrates how to control the limits on a spinbutton."""    def __init__(self, upperBound=10):        """Initialize a new instance."""        self.top = AppWindow.AppWindow(title="Spinbutton Limits")        self.table = gtk.GtkTable()        self.top.add(self.table)        self.table.show()        self.spinBtn = gtk.GtkSpinButton()        self.spinBtn.connect("activate", self.spinEntryActivateCB)        self.table.attach(self.spinBtn, 0, 1, 0, 1)        self.spinBtn.show()        self.scrollbar = gtk.GtkHScrollbar()        self.scrollbar['width'] = 200        self.table.attach(self.scrollbar, 0, 1, 1, 2)        self.scrollbar.show()        self.scale = gtk.GtkHScale()        self.table.attach(self.scale, 0, 1, 2, 3)        self.scale.show()        self.setUpperBound(upperBound)    def mainloop(self):        """Show the application window and run the main event loop."""        self.top.show()        gtk.mainloop()    def spinEntryActivateCB(self, *args):        """Callback invoked when the user enters a new value in the        spinbutton entry field."""        # Use get_text() and convert the value to a number; get_value() clips         # the value to the current spinbutton bounds before returning it.        self.setUpperBound(float(self.spinBtn.get_text()))    def setUpperBound(self, upperBound):        """Set a new upper bound for the spinbutton, scrollbar et al."""        # Ignore any upper bounds which are less than the current        # lower bound. (Default lower bound for a spinbutton is zero.)        if upperBound &lt;= 0:            return        # Apply the new upper bound, but keep all other adjustments        # at their current value.        # Can't use self.spinBtn.get_adjustment(), because it references        # a non-existent attribute ('sel' should be 'self').        o = self.spinBtn._o        adj = gtk._obj2inst(gtk._gtk.gtk_spin_button_get_adjustment(o))        # Create a new GtkAdjustment and tell spinbutton, etc, to use it.        newAdj = gtk.GtkAdjustment(adj.value, adj.lower, upperBound,                     max(1, adj.step_increment), max(1, adj.page_increment),                     max(1, adj.page_size))        self.spinBtn.set_adjustment(newAdj)        self.scrollbar.set_adjustment(newAdj)        self.scale.set_adjustment(newAdj)def main():    """Module mainline (for standalone execution)"""    ui = UI()    ui.mainloop()if __name__ == "__main__":    main()</pre><P><A HREF="#rl4">Back to Article</A></P></body></html>