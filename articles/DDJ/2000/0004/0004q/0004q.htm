<html><head><title>Apr00: Algorithm Alley</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Binary Search:  Algorithm, Code, and Caching</h1><p><i>Dr. Dobb's Journal</i> April 2000</p><h3>By Jon Bentley </h3><I>Jon is a Member of Technical Staff at Bell Labs. He can be reached at jlb@research.bell-labs.com.</I><hr><p>Caches are wonderful. My trusty old desktop computer runs at 400 MHz, or a 2.5-nanosecond cycle time. It has 128 MB of RAM, with a 70-nanosecond access time that is a factor of almost 30 slower than the cycle time. Two caches bridge that enormous chasm -- 32 KB of Level 1 (L1) cache that can be accessed in a single cycle, and 512 KB of Level 2 (L2) cache accessed in a few cycles. The system therefore combines the huge size and cheap price of the RAM with the blazing speed of the L1 cache. Usually.</p><p>Caching often works well, but sometimes fails utterly. In this column, I'll examine why that happens, and what you can do about it. I'll tackle this big-systems issue by concentrating on one tiny programming problem -- binary search. When I ignored the effects of caching, a simple experiment I conducted mispredicted the run time of a binary search by a factor of four. When I viewed caching properly, I was able to speed up a related binary search by a factor of two. I'll start by reviewing binary search, and then move to a simple program for experimenting on its run time.</p><DDJADVERTISEMENT INLINE><h3>The Algorithm</h3><p>I'm thinking of a number between 1 and 1000; you guess it. 500? Too low. 750? Too high. And so the game goes, until you get my number in about 10 guesses.</p><p>The optimal strategy for this game uses binary search, a textbook divide-and-conquer algorithm. Start with a known range, and use each probe to divide the range in half. Stop when you find the item, or when the range becomes empty.</p><p><b>Exercise 1.</b> Show that a binary search will take at most 1+<i>log</i><sub>2</sub><i>n</i><sup> </sup>probes to locate a given value among <i>n</i> inputs.</p><p>Fancy applications of a binary search examine complex structures, pruning a fixed portion of the search space with each probe. The most common use of a binary search in programs, though, is to look up an element in a sorted array.</p><p><b>Exercise 2.</b> Write code to determine whether the sorted array <i>x[0..n-1]</i> contains the target value <i>t</i>.</p><p>Solution 2 (at the end of this column) gives the simplest approach I know for binary search. It is easy to implement and relatively fast; I have used similar code in many programs. Unfortunately, if the array contains several copies of the target, the pseudocode might return any given one of them.</p><p>The rest of this column uses a binary search that always returns the first occurrence of many targets, or the place where it would be if it isn't present. The code uses the two integer indices <i>l</i> and <i>u</i> (for "lower" and "upper") to maintain the loop invariant shown in <A NAME="rf1"><A HREF="0004qf1.htm">Figure 1</A>. Each probe changes one of the two values, and the loop continues until the indices meet.</p><h3>The Code</h3><p>The binary search operates on objects of type <i>DataType</i>. <A NAME="rl1"><A HREF="#l1">Listing One</A> defines the type as: </p><blockquote><p>typedef int DataType;</p></blockquote><p>The sorted array <i>x</i> to be searched has <i>n</i> elements:</p><blockquote><p>DataType x[MAXN];</p><p>int n;</p></blockquote><p>The binary search has this specification:</p><blockquote><p>int binarysearch(DataType t, int lo, int hi)</p><p>/* pre:  lo &lt;= hi and x[lo..hi] is sorted   */</p><p>/* post: x[result-1] &lt; t and x[result] &gt;= t */</p></blockquote><p>The postcondition assumes that the array has the two fictitious elements <i>x[-1])=-<img src="dot12.gif" width="6" height="9" align="middle"></i> and <i>x[n])=<img src="dot12.gif" width="6" height="9" align="middle"></i>.</p><p><b>Exercise 3.</b> How would you add logical terms to the postcondition to avoid using the fictitious elements?</p><p>This function implements the specification using the invariant in the previous section:</p><blockquote><pre>int binarysearch(DataType t, int lo, int hi){   int l, u, m;    l = lo - 1;    u = hi + 1;    while (l+1 != u) {        m = (l + u) / 2;        if (x[m] &lt; t)            l = m;        else            u = m;    }    return u;}</pre></blockquote><p><b>Exercise 4.</b> How would you convince yourself that this delicate code is correct?</p><h3>Timing Tests</h3><p>Exercise 1 observes that a binary search in an array of <i>n</i> elements will use about <i>log</i><sub>2</sub><i>n</i> steps. How will that translate into processor time? </p><p>That question was easy to answer in the old days. A timing program reads a value for <i>n</i>, then fills the array with <i>n</i> values in order:</p><blockquote><p>for (i = 0; i &lt; n; i++)</p><p>    x[i] = 10*i;</p></blockquote><p>The measurement code starts a clock, searches for each value in turn, and computes the run time.</p><blockquote><pre>start = clock();for (i = 0; i &lt; n; i++) {    t = x[i];    pos = binarysearch(t, 0, n-1);    assert(pos == 0 || x[pos-1] &lt;  t);    assert(pos == n || x[pos]   &gt;= t);}clicks = clock() - start;nanosecs_per_search = 1e9*clicks        / ((float) CLOCKS_PER_SEC*n);</pre></blockquote><p>The <i>assert</i> statements ensure that the function meets its specification. The real code in fact iterates the main loop a number of times to get large enough clock values when <i>n</i> is small.</p><p>Before microprocessors had caches, such simple code was very useful. Running the experiment on eight evenly spaced values of <i>n</i> led to the well-behaved graph of 8086 run times in <A NAME="rf2"><A HREF="0004qf2.htm">Figure 2</A>. The data points all lie quite close to the line at 67+31<i>log</i><sub>2</sub><i>n</i> microseconds. That was a useful engineering approximation: Most searches took about that much time.</p><p>This experiment measures the cost of successful searches that find the values for which they search.</p><p><b>Exercise 5.</b> How would you measure the average cost of unsuccessful searches that do not find their target values?</p><h3>Cache-Sensitive Timing</h3><p>When I ran the experiment on several modern computers, I got similar lines, but with much smaller constants. But what do those times mean on a modern machine? Are they accurate predictors of the cost of typical searches?</p><p>If searches look for each element in order, the elements used by one binary search are almost exactly the elements used by the search before it. (On average, only two elements are different.) Those elements are usually in the L1 cache, and are therefore cheap to access.</p><p>Unfortunately, most real-world searches don't take place in rigid order. To model such searches, the next experiment will search for every element in the input vector in a random order.</p><p><b>Exercise 6. </b>Modify the timing scaffolding to perform the searches in a random order.</p><p></p><p><A NAME="rf3"><A HREF="0004qf3.htm">Figure 3</A> shows the results of the scrambled experiment on an AMD K6-2 processor. The ordered experiment gives the same straight line that was observed on a machine without caches. The scrambled times clearly show the effect of caching: They have almost the same cost as the ordered times through <i>n</i>=8000 (when the 32,000 bytes of 4-byte integers barely squeezes into the 32,000 L1 cache). At higher values, though, the data spills out into the L2 cache and finally into RAM, and the cost of each access rises from dozens to hundreds of nanoseconds.</p><p><b>Exercise 7.</b> Download the program and measure it on your machine. Can you spot the boundaries between L1, L2, and RAM?</p><p></p><p>When the data fits in the L1 cache, the ordered and scrambled searches cost about the same. For larger instances, the ordered searches are much cheaper. Like many difficulties, this problem can also be viewed as an opportunity.</p><p><b></p><p></b>Exercise 8. When is it possible to order queries to speed up a series of searches?</p><h3>Binary Search for a Range</h3><p>I was recently working on a program in which a sorted array contained many copies of some values. The bottleneck in the program boiled down to searching for the values equal to an input, and choosing one of them at random.</p><p>My first approach to the problem started with a binary search for the first value, and then sequentially scanned through subsequent equal values to choose one at random:</p><blockquote><pre>first = [binary search for first instance of t]i = 0;while (x[first+i] == t)    if (rand() % ++i == 0)        choice = first+i;</pre></blockquote><p>The program took more time than I expected, and I finally found that for my input data, the sequential search took the program from <i>O(n </i>log <i>n) to O(n</i><sup>2</sup><i>)</i> operations. I therefore replaced the sequential search with a second binary search:</p><blockquote><p>first = [binary search for t using &lt; ]</p><p>last  = [binary search for t using &lt;=] - 1</p><p>choice = random integer in first..last</p></blockquote><p>The first binary search uses the less-than operator (exactly as in the <i>binarysearch</i> function previously described) to find the first instance of <i>t</i> in the array. The second binary search changes that operator to less-than-or-equal to find the first value greater than <i>t</i>; subtracting one gives the last instance of <i>t</i>. This change restored the <i>O(n </i>log <i>n) </i>performance, and sped the program up by a factor of 10 on reasonable inputs.</p><p></p><p><b>Exercise 9. </b>Suppose that <i>m</i> of the <i>n</i> values in the array are equal to <i>t</i>. The first method (binary search then sequential search) uses about <i>m+log</i><sub>2</sub><i>n</i> comparisons, while the second method (two binary searches) uses about 2 <i>log</i><sub>2</sub><i>n</i> comparisons. Can you find a method that uses about <i>log</i><sub>2</sub><i>n</i>+2<i>log</i><sub>2</sub><i>m</i> comparisons?</p><h3>Paired Binary Searches</h3><p>When I implemented my program, I stumbled across a caching problem that gave me another factor of two. </p><p>When I first wrote the pair of binary searches, I used pseudocode like this:</p><blockquote><p>first = binarysearch(t, x, 0,     n-1, &lt; )</p><p>last  = binarysearch(t, x, first, n-1, &lt;=) - 1</p></blockquote><p>Without thinking, I used the result of the first search as a lower bound for the second search. I'll call this approach a "warm start" to contrast it with a "cold start," which always uses zero as a lower bound for the second search (by replacing the parameter <i>first</i> in the second call with zero). I used a warm start out of force of habit; I've learned to avoid paying for the same ground twice. But is that the right choice for today's processors?</p><p></p><p><b>Exercise 10.</b> How many comparisons will the warm start use compared to the cold start? What effect will each approach have on caching?</p><p>Solution 10 shows that, under reasonable assumptions, the warm start method should use about one or two fewer comparisons than the cold start. <A NAME="rf4"><A HREF="0004qf4.htm">Figure 4</A> illustrates the run time of the two methods on an AMD K6-2. When the data fits entirely in the L1 cache, the warm start is indeed faster (by about the one or two predicted comparisons). When the data spills out of the cache, though, the cold start grows a little, while the warm start grows a lot. Why is the cold start more cache-friendly than the warm start?</p><p>When the cold start performs the second binary search, it always uses the same starting comparison as the first search (the middle element of the array). The next comparisons are almost always the same, and so on until the final few comparisons. The cold start uses <i>2log<sub>2</sub>n</i> comparisons, but only accesses about <i>log<sub>2</sub>n</i> distinct elements. In the cold start, caching makes you a "buy one, get one free" offer. (As long as the second is very close to the first.)</p><p>The warm start, on the other hand, usually accesses a new element in its first comparison, and typically accesses new elements all the way down the search. So even though it uses one less comparison, it does so by accessing about <i>2log<sub>2</sub>n</i> or twice as many elements. The slope of the right part of the warm start curve in <A NAME="rf4"><A HREF="0004qf4.htm">Figure 4</A> is almost exactly twice the slope of the cold start curve. In the warm start, clever algorithm design makes the offer of, "Buy one, get two comparisons off the price of the second." Unfortunately, that negates the benefit of caching.</p><h3>Principles</h3><p>This column illustrates several important points about the important young field of "cache-conscious code tuning." </p><p></p><p><b>Measure Times on Appropriate Inputs.</b> Some inputs display enough locality to make them particularly efficient for caching; others don't. Be sure your test inputs accurately model the inputs your code will face in production.</p><p><b>Look for the Knees.</b> On the cacheless memories of my programming youth, run times were often straight lines to asymptopia, like the data in <A NAME="rf2"><A HREF="0004qf2.htm">Figure 2</A>. On machines with caches, though, run times usually have sharp bends like those in <A NAME="rf3"><A HREF="0004qf3.htm">Figures 3</A>, 4, and 5. Graph the run time of your program, and hunt for those twists. What is fast on one side of the curve may be slow on the other.</p><p><b>More Old Work May Be Cheaper Than Less New Work.</b> Out of habit, I used a warm start in my original pair of binary searches. When I thought hard about caching, I tried the cold start by changing one variable in the source code, and saw a speedup of close to a factor of two.</p><p><b>Machine-Independent Caching.</b> To tweak the last cycle of performance out of key inner loops, it is sometimes necessary to labor over each machine instruction. A basic awareness of caching is often sufficient to gain substantial speedups across a wide variety of machines.</p><h3>Further Reading</h3><p>I came across the problems described in this column as I was working on my book <i>Programming Pearls</i>, Second Edition (Addison-Wesley, 2000). The themes of this column run throughout the book; the index contains 14 entries for "binary search" and 10 entries for "cache sensitive code." The web site http://www .programmingpearls.com/ gives additional references to these topics, especially to Anthony LaMarca's important work on caches and algorithms.</p><h3>Solutions to Selected Exercises</h3><p><b>2.</b> This code searches the sorted array <i>x[0..n-1]</i> for the target value <i>t</i>:</p><blockquote><pre>lo = 0hi = n-1loop    if lo &gt; hi        return "not found"    mid = (lo + hi) / 2    case        x[mid] &lt;  t:  lo = mid + 1        x[mid] == t:  return "found at " m        x[mid] &gt;  t:  hi = mid - 1</pre></blockquote><p>The invariant of the loop is that if <i>t</i> is anywhere in the array, then it will be in <i>x[lo..hi]</i>.</p><p></p><p><b>3. </b>The strengthened conditions are shown in the scaffolding code on page 111.</p><p></p><p><b>6.</b> To scramble the searches, the permutation vector</p><blockquote><p>int p[MAXN];</p></blockquote><p>is initialized to index to the elements in order:</p><blockquote><pre>for (i = 0; i &lt; n; i++)    p[i] = i;</pre></blockquote><p>This code scrambles the elements to be a random permutation:</p><blockquote><pre>for (i = n-1; i &gt; 0; i -- ) {    j = rand() % (i + 1);    t = p[i]; p[i] = p[j]; p[j] = t;}</pre></blockquote><p>The new experiment chooses as the search value not the <i>i</i>th element in the array, but rather the <i>i</i>th scrambled element:</p><blockquote><p>t = x[p[i]];</p></blockquote><p><b>7. </b><A NAME="rf5"><A HREF="0004qf5.htm">Figure 5</A> shows the run time of a binary search on scrambled input data on a Pentium II processor with 32,000 of L1 data cache and 512,000 of L2 cache. The straight lines are drawn between the endpoints in the three regions, and seem to represent the data accurately. If all the queries are known in advance, sorting them could induce locality and thereby speed up the caching. If the queries are known in advance, though, a series of binary searches is probably not the most efficient algorithm for the job. (On other problems, however, I have ordered queries to induce locality and thereby sped up programs by a factor of four.)</p><p></p><p><b>10. </b>Assume that every array index is equally as the value of <i>first</i>. For the <i>n</i>/2 values less than the median, a warm start reduces the search cost by at most one comparison. For the <i>n/</i>4 values between the median and the 75th percentile, the cost is reduced by at most two comparisons. The next <i>n/</i>8 values save at most three comparisons, and so forth. This series sums to 2, so the search cost is reduced by at most that amount. A similar analysis shows that the search cost is reduced by at least one. To find the exact answer, mathematically inclined readers might try using Stirling's approximation to</p><blockquote><p>log<sub>2</sub>n!=log<sub>2</sub>n+log<sub>2</sub>n-1+ log<sub>2</sub>n-2+...+log<sub>2</sub> </p></blockquote><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>/* bsearch.c -- time binary search algorithms for cache effects    From Dr. Dobb's Journal, April 2000        Input lines:  algnum n numtests        Output lines: algnum n numtests scrambled clicks nanosecs_per_elem        See timedriver for algnum codes    bsearch gives scrambled tests; bsearch -o gives ordered*/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#define MAXN 10000000typedef int DataType;DataType x[MAXN];int n;/* Alg 1: From Programming Pearls, 2nd Ed., Column 8 */int binarysearch1(DataType t, int lo, int hi)    /* return least u s.t. x[u] &gt;= t */{       int l, u, m;        l = lo - 1;        u = hi + 1;        while (l+1 != u) {                m = (l + u) / 2;                if (x[m] &lt; t)                        l = m;                else                        u = m;        }        return u;}/* Algs 2 and 3: Return range of equal values */typedef struct range {        int lo, hi;} Range;int warmstart = 0;  /* 1 to change start of second binary search */Range binarysearch2(DataType t, int lo, int hi)    /* pre: sorted(0, n-1)           post: bsl = min l s.t. x[l] &gt;= t                 bsu = max u s.t. x[u] &lt;= t     */{       int l, u, m;        Range answer;        l = lo - 1;        u = hi + 1;        while (l+1 != u) {                m = (l + u) / 2;                if (x[m] &lt; t)                        l = m;                else                        u = m;        }        answer.lo = u;        l = lo - 1;  /* cold start */        if (warmstart)                l = answer.lo;        u = hi + 1;        while (l+1 != u) {                m = (l + u) / 2;                if (x[m] &lt;= t)                        l = m;                else                        u = m;        }        answer.hi = l;        return answer;}/* Timing */int p[MAXN];  /* permutation vector */void scramble(int n){       int i, j;        DataType t;        for (i = n-1; i &gt; 0; i--) { /* call 15-bit rand twice */                j = (RAND_MAX*rand() + rand()) % (i + 1);                t = p[i]; p[i] = p[j]; p[j] = t;        }}#define assert(v) { if ((v) == 0)                         printf("  binarysearch bug i=%d n=%d\n", i, n); }int main(int argc, char *argv[]){       int i, algnum, numtests, test, start, clicks;        int pos, b, e, wantscramble;        Range answer;        DataType t;        wantscramble = 1;        if (argc &gt; 1 &amp;&amp; argv[1][0] == '-' &amp;&amp; argv[1][1] == 'o')                                                    /* "ordered" searches */                wantscramble = 0;        while (scanf("%d %d %d", &amp;algnum, &amp;n, &amp;numtests) != EOF) {                x[0] = 0;                for (i = 1; i &lt; n; i++)                        x[i] = x[i-1] + rand() % 2;                for (i = 0; i &lt; n; i++)                        p[i] = i;                if (wantscramble)                        scramble(n);                start = clock();                for (test = 0; test &lt; numtests; test++) {                        for (i = 0; i &lt; n; i++) {                                t = x[p[i]];                                switch (algnum) {                                case 1:                                        pos = binarysearch1(t, 0, n-1);                                        assert(pos == 0 || x[pos-1] &lt; t);                                        assert(pos == n || x[pos] &gt;= t);                                        break;                                case 2:                                case 3:                                        warmstart = 0;                                        if (algnum == 3)                                                warmstart = 1;                                        answer = binarysearch2(t, 0, n-1);                                        b = answer.lo;                                        e = answer.hi;                                        assert(b &lt; 0   || x[b]   &gt;= t);                                        assert(b &lt; 1   || x[b-1] &lt;  t);                                        assert(e &gt; n-1 || x[e]   &lt;= t);                                        assert(e &gt; n-2 || x[e+1] &gt;  t);                                        break;                                }                        }                }                clicks = clock() - start;                printf("%d\t%d\t%d\t%d\t%d\t%g\n",                        algnum, n, numtests, wantscramble, clicks,                        1e9*clicks/((float) CLOCKS_PER_SEC*n*numtests));        }        return 0;}</pre><P><A HREF="#rl1">Back to Article</A></P></body></html>