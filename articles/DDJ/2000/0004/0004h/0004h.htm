<html><head><title>Apr00: Digital Filtering  and  Oversampling</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Digital Filtering  and  Oversampling</h1><p><i>Dr. Dobb's Journal</i> April 2000</p><h2>Increasing  performance while decreasing complexity</h2><h3>By Jim Ledin</h3><I>Jim is a consulting electrical engineer and can be contacted at jim@ledin.com.</I><hr><a name="rs1"><a href="0004hs1.htm">Decibels</a><hr><p>Filters are used in a wide variety of applications, many of which are not apparent to a product's users. Telephones, television sets, stereos, and automobiles are a few of the everyday devices that use filters to some extent. Building analog filters from circuit components has been an accepted implementation technique for many applications in the past, but with advances in the capabilities of general-purpose CPUs and specialized DSP chips, it is becoming practical to use digital filtering in more and more applications.</p><p>Lowpass, highpass, and bandpass filters are common types of frequency-selective filters. A digital frequency-selective filter accepts an input signal consisting of a sequence of values equally spaced in time and produces an output sequence that has an altered frequency response.</p><DDJADVERTISEMENT INLINE><p>The use of digital filtering (as opposed to analog filtering) can provide higher overall system performance while simultaneously reducing circuit complexity. In this article, I'll take a look at the technique of oversampling, which can be used to gain these seemingly contradictory benefits. But first I'll discuss some of the design and implementation issues for a class of digital filters called "FIR" filters.</p><h3>FIR Filters</h3><p>There are many different types of digital filters, but I will focus on the finite impulse response (FIR) filter because it is conceptually simple to implement and possesses some attractive attributes. FIR filters are digital filters that produce an output value each time a new input value becomes available by computing the dot product of a constant coefficient vector with a vector of the most recent input signal values. </p><p>Let <i>n</i> indicate the integer sample number, so that <i>n</i>=0, 1, 2, and so on. <A NAME="rf1"><A HREF="0004hf1.htm">Figure 1</A> shows how the output <i>y</i> at time step <i>n</i> is computed from the filter coefficient vector <i>h</i> and the most recent <i>N</i>+1 values of the input signal <i>x</i>. The <i>h</i> vector is a set of <i>N</i>+1 constant values that determine the filter's response. The order of the filter is <i>N</i>, and in practical applications the value of <i>N</i> might range from 1 to more than 1000, depending on the filtering requirements and computational resources available.</p><p>The FIR filter's name derives from the fact that if the filter's input is a single nonzero value followed by a sequence of zero values, the output will go to zero <i>N</i>+1 samples later and stay there. In other words, the response to an impulse input goes to zero in a finite length of time.</p><p>The tricky part of FIR filters lies in selecting the values of the coefficient vector <i>h</i>. Fortunately there is a technique called the "Remez exchange algorithm" that computes the coefficient vector <i>h</i>, given a specification of the desired filter frequency response. The resulting filter will be optimal in the sense that the maximum error in the frequency response will be minimized. </p><p>An important feature of FIR filters is that they possess linear phase. This means that all signal frequencies pass through the filter at the same speed and phase distortion is avoided. Most other filter types (digital and analog) generate some distortion due to nonlinear phase, which is usually undesirable.</p><p>Probably the most common implementation of a frequency selective filter is the lowpass filter. A lowpass filter attempts to eliminate frequencies above a selected cutoff frequency while passing frequencies below the cutoff unaltered. While I only discuss lowpass filters here, FIR filters and the Remez exchange algorithm can be used to implement a much wider variety of digital filters.</p><h3>Antialiasing</h3><p>Embedded systems often include interfaces between the digital computer and the analog world. The input processing of analog signals typically requires some form of filtering operation for best performance. There are tradeoffs between performing filtering purely in circuitry versus using a filter circuit plus a digital-filtering algorithm.</p><p>To interface an embedded system with an analog input signal, an analog-to-digital converter (ADC) must be employed. When performing analog-to-digital conversion, a loss of signal fidelity occurs because the converted signal is only sampled at discrete points in time and the digital samples have finite resolution. For example, sampling a person's speech 8000 times per second (an 8-KHz rate) with 8 bits of ADC resolution results in telephone-quality sound, which is noticeably different from the sound of the original voice.</p><p>Another problem that arises when sampling an analog signal is called "aliasing." Aliasing occurs when there are components of the ADC input signal with frequencies higher than half the sampling rate (the half-sampling-rate frequency is called the "Nyquist frequency"). When these high frequencies are sampled, they appear in the sampled output as if they had been reflected about the Nyquist frequency. If the sampling rate were 8 KHz then the Nyquist frequency would be 4 KHz. An analog input signal consisting of a pure 5-KHz sine wave would become a 3-KHz sine wave after sampling due to aliasing.</p><p>Aliasing is undesirable because it distorts the desired signal, so steps must be taken to minimize it. The most straightforward way to deal with the problem is to place a filter between the analog signal source and the ADC input; see <A NAME="rf2"><A HREF="0004hf2.htm">Figure 2</A>.</p><p>This lowpass filter, called an "antialias" filter, has the job of eliminating signal components with frequencies greater than the Nyquist frequency while allowing signal components at lower frequencies to pass through undisturbed. An ideal lowpass filter would perform this job exactly as in <A NAME="rf3"><A HREF="0004hf3.htm">Figure 3</A>, but unfortunately, it is impossible to implement this perfect filter. However, it is possible to come arbitrarily close to the ideal frequency response by using a high-order filter.</p><p>An ideal antialias filter must also possess the linear phase property to avoid phase distortion. Given these ideal characteristics, the goal now is to implement a filter that approximates this ideal frequency and phase response as closely as possible while minimizing hardware cost, computational resource requirements, and development effort.</p><h3>Analog Antialias Filter</h3><p>Continuing the speech sampling example, one approach is to build a high-order analog filter to block signals above 4 KHz while the ADC samples the input signal at 8 KHz. I'll design a fairly complex analog filter to do this and examine its performance.</p><p>The first step in the process is to specify the requirements that the lowpass filter must meet. These specifications include the passband and stopband frequency edges, the allowable amount of error in amplitude in the passband, and the required suppression in the stopband. Another source of error is the phase distortion in the passband, which I won't attempt to specify, though I will show the phase distortion in the resulting filter design. I will assume that the filter can have an order no higher than 8 due to limitations of circuit complexity. I'll specify that the output amplitude of any aliased signal can be no larger than 1/1000 of its amplitude at the input, equivalent to 60 dB of suppression in the stopband (see the accompanying text box entitled "Decibels") and I'll allow a maximum of 1 dB of amplitude distortion in the passband.</p><p>Using an equiripple filter design program in Matlab, the resulting filter's frequency response is shown in <A NAME="rf4"><A HREF="0004hf4.htm">Figure 4</A>. The gray areas indicate the regions where the frequency response must be excluded for the specifications to be met. The frequency response must begin decreasing at 3.6 KHz in order for it to be suppressed by 60 dB at 4 KHz. The region from 3.6 to 4 KHz is called the "transition band." The equiripple design technique produces the smallest transition band of all the common analog filter design algorithms for a given filter order.</p><p><A NAME="rf5"><A HREF="0004hf5.htm">Figure 5</A> shows the filter's phase response over the passband, with the ideal linear phase response shown as a straight line.</p><p>In summary, this analog antialias filter has the drawbacks of attenuating the desired signal in the range 3.6 to 4 KHz and introducing phase distortion, in addition to the fairly complex circuitry that is required to implement it.</p><h3>Oversampling</h3><p>An approach that improves on the drawbacks of the analog filter involves the use of oversampling. Oversampling is the technique of sampling a signal at a higher rate than would be required to just preserve the desired signal frequencies. It is typically referred to as a multiple of the desired sampling rate such as 2&times; or 4&times; oversampling. The oversampled signal is then sent through a digital filter before being downsampled to the desired sample rate. <A NAME="rf6"><A HREF="0004hf6.htm">Figure 6</A> is a diagram of this type of system.</p><p>There are some significant advantages to oversampling a signal. For the antialiasing application, oversampling allows the lowpass filtering operation to be split between the analog domain and the digital domain. This split allows better filtering performance while simultaneously reducing the complexity and performance requirements of the analog filter and ADC.</p><p>Of course, the drawbacks to the oversampling approach are that the ADC must operate at the higher sampling rate and the processor must handle this higher data rate while performing additional processing on the data to implement the digital filter. Given the high performance of today's processors, it is reasonable to make this tradeoff for many applications.</p><p>An oversampling design still requires an analog filter on the input signal to the ADC, but the requirements for this filter will be significantly relaxed compared to the pure analog filter approach.</p><p>The oversampling multiplier must be selected based on the ability of the ADC and CPU to convert and process the data at higher rates. I'll assume that 4&times; oversampling will be used in this example, which means that the ADC will sample its input at 32 KHz.</p><p>The analog filter still should pass signals unaltered up to 4 KHz, but now it does not have to suppress the input signal by 60 dB until 28 KHz. Why is this? The desired signal lies in the band 0-4 KHz and the Nyquist frequency is now 16 KHz. Frequencies above the Nyquist frequency will reflect back to lower frequencies, but only those frequencies above 28 KHz will reflect back into the desired signal band and contaminate it. The analog filter attenuates these frequencies so that now the full desired signal band is passed with minimal distortion.</p><p><A NAME="rf7"><A HREF="0004hf7.htm">Figure 7</A> shows the frequency response of a 4th order Butterworth analog filter with 1 dB of error in the 0-4-KHz passband and 60-dB attenuation at 28 KHz. <A NAME="rf8"><A HREF="0004hf8.htm">Figure 8</A> shows this filter's phase distortion in the 0-4-KHz band. This is clearly an improvement over the aforementioned purely analog filter.</p><p>This filter has done a good job of preserving the passband with minimal distortion, but there is still the region from 4 KHz up to 16 KHz that must be eliminated to leave only the desired signal. This is the job of the digital filter.</p><p>A digital lowpass filter is required. It passes frequencies up to a cutoff at 1/4 of the Nyquist frequency and attenuates frequencies above that. It must have 60 dB attenuation at the cutoff frequency. Using the Remez design program described here, I designed a 178th order FIR filter to perform this task. The design parameters are the filter order, transition bandwidth, and ratio of passband to stopband ripple. <A NAME="rf9"><A HREF="0004hf9.htm">Figure 9</A> shows the frequency response of the FIR filter.</p><p>After passing the input signal through the 4th order analog filter, sampling it, and passing it through the FIR filter, it must be downsampled to the desired 8-KHz frequency. This means that every fourth output of the FIR filter is retained, and the other three are discarded. In practice, you would only compute every fourth filter output and not compute the other three.</p><p>Another benefit of oversampling is that it effectively increases the resolution of the ADC. Oversampling at 4&times; adds one bit of resolution to the ADC, oversampling at 16&times; adds 2 bits of resolution, and so on. With an 8-bit ADC, the output of the digital filter will have 9 bits of effective resolution. Alternatively, a 7-bit ADC could be used to achieve the desired 8 bits of resolution.</p><p>The computation requirements for the digital filter can now be determined. From <A NAME="rf1"><A HREF="0004hf1.htm">Figure 1</A>, an <i>N</i>th order filter requires <i>N</i>+1 multiplies and <i>N</i> adds. An interesting property of linear-phase FIR filters is that they are always symmetrical about the midpoint. This means that the first coefficient and last coefficient are identical, the second coefficient and next to last coefficient are identical, and so on. By adding the signal values that multiply identical coefficients prior to multiplying by the coefficient the number of multiplies is cut in half, as in <A NAME="rf10"><A HREF="0004hf10.htm">Figure 10</A>, which assumes that <i>N</i> is an even number.</p><p>Using this formula, an <i>N</i>th order filter (with <i>N</i> even) has <i>N</i>/2+1 multiplies and <i>N</i> adds for each output computed. For the example design, <i>N</i> is 178 so there are 90 multiplies and 178 adds for each output, which occurs at an 8-KHz rate. Thus there are 720,000 multiplies and 1,424,000 adds required per second. These computations can be done using floating-point or appropriately scaled integer operations. Given these requirements, a processor can be selected for the application.</p><p>If this is too much arithmetic for your processor to handle, it may make sense to use less stringent filter requirements and design a lower order digital filter. A nice thing about digital filters is that it is easy to make tradeoffs between filter performance and computational requirements by changing the parameters and generating a new filter design.</p><p><A NAME="rf11"><A HREF="0004hf11.htm">Figures 11</A> and <A NAME="rf12"><A HREF="0004hf12.htm">12</A> show the passband frequency response and phase response of the complete oversampled system. Although there is more total phase delay in this system, it is much more linear than the analog 8th order filter. For the digital filter, there is a delay between the input and the output of <i>N</i>/2 samples, or 2.8 milliseconds, but all frequencies are delayed the same length of time so there is no added phase distortion. In addition, the hardware complexity of the analog filter has been cut in half and the effective ADC resolution has been improved by 1 bit.</p><h3>Remez Filter Design Program</h3><p>I modified a freely available Remez exchange filter design program (written by Jake Janovetz, janovetz@uiuc.edu) to allow the specification of the parameters for an FIR filter design in a text file. The program (available electronically in source code and Win32 executable form; see "Resource Center," page 5) processes the file and produces an output file in C that contains data definitions for the FIR filter implementation. <A NAME="re1"><A HREF="0004he1.htm">Example 1</A> is the input file that generates the 178th order filter used here.</p><p>Frequencies in the input file are normalized so that 1.0 is the Nyquist frequency. In <A NAME="re1"><A HREF="0004he1.htm">Example 1</A>, the passband is from 0 to .226, which is 0 to 3616 Hertz if the sampling frequency is 32 KHz. The amplitude in the passband is 1 and the error weight in the passband is 1/40 of the error weight in the stopband. The stopband begins at 0.25 (4 KHz) and the desired amplitude in the stopband is zero.</p><p>It's possible to develop more complex filters than simple lowpass or highpass filters by specifying multiple bands of varying amplitude in the input file. </p><h3>Conclusion</h3><p>The use of digital filtering is becoming more widespread as general-purpose CPUs and specialized DSP chips become faster and cheaper. If you take full advantage of this capability, your designs can achieve enhanced performance while reducing hardware cost.</p><p></p><p><b>DDJ</b></p></body></html>