<html><head><title>Apr00: An Efficient Algorithm for Magnitude Operation</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>An Efficient Algorithm for Magnitude Operation</h1><p><i>Dr. Dobb's Journal</i> April 2000</p><h2>An alternative approach </h2><h3>By S. Manivannan</h3><I>The author is a senior software engineer for Siemens Information Systems Limited in Bangalore, India. He can be contacted at sp.manivannan@sisl.co.in.</I><hr><p>In the field of signal processing, the signal contains information in amplitude and phase and is represented as complex variables. The energy of the signal is proportional to the magnitude of the signal. Magnitude operation is, therefore, widely used in signal and data processing for signal detection and power estimation. Systems where magnitude operations are frequently used include real-time displays for sensors, radars, sonars, scanners for medical imaging systems, and the like. These systems work with multiple modes, where the objects are displayed in circular and cartesian coordinate systems. Frequent operations in the display processor are:</p><p></p><DDJADVERTISEMENT INLINE><ul>  <li>Conversion of signals in time domain into spatial domain (for different coordinate systems).  <li>Conversion of signals from one coordinate to another in spatial domain.  <li>Conversion of spatial domain to rasters. These operations always involve high-speed magnitude computations.</ul><p>Magnitude operation is generally implemented as lookup tables in real-time applications, with all possible combinations of input arguments as address locations. However, these lookup tables consume huge amounts of memory. While high-speed methods are available, the results they produce are only approximations for magnitude. In "A Baker's Dozen Magnitude Approximations and Their Detection Statistics," (<i>IEEE Transactions on Aerospace and Electronic Systems</i>, January 1976), A.E. Filip notes 13 approximations for magnitude in which the least accurate has a peak error of 27.3 percent and the most accurate has a peak error of 0.97 percent. In this article, I present an alternative approach to magnitude operation that is both fast and efficient in terms of memory. This approach, which is based on the Successive Approximation principle, predicts each bit of the result from MSB to LSB, and corrects it based on feedback. In addition, I've implemented this algorithm in C++ source code; see <A NAME="rl1"><A HREF="#l1">Listing One</A>.</p><h3>Algorithm Description</h3><p>The algorithm itself is fairly straightforward. Note that in this article, I represent magnitude as <i>M(a,b)</i>. If <i>Z</i> is a complex number given by <i>Z=a+i&times;b</i> where <i>i</i> is imaginary unity, and <i>Z'</i> is its conjugate given by <i>Z=a-i&times;b</i>, then <i>Z&times;Z'=M&times;M</i>. Furthermore, the magnitude of two numbers <i>(a,b)</i> is defined as <i>SquareRoot(a&times;a+b&times;b)</i>.</p><p>For two integers <i>(a,b)</i>, <i>M(a,b)</i> have the boundaries in <A NAME="rf1"><A HREF="0004ff1.htm">Figure 1</A>, where <i>a </i>is the larger number, see <A NAME="rf1"><A HREF="0004ff1.htm">Figure 1</A>(a), and <i>b </i>is the smaller number; see <A NAME="rf1"><A HREF="0004ff1.htm">Figure 1</A>(b). You define <i>r </i>such that <i>r=M</i>-<i>a</i>; as in <A NAME="rf1"><A HREF="0004ff1.htm">Figure 1</A>(c). This implies <A NAME="rf1"><A HREF="0004ff1.htm">Figure 1</A>(d). Therefore, if r is computed successively, such that <i>b</i>2=<i>r</i>2 +2<i>&times;a&times;r</i>, then <i>(r+a) </i>will give <i>M(a,b)</i>. To compute r successively, in each iteration, 1 bit is added to it. Assume this increment is <i>d. </i>This yields <A NAME="rf1"><A HREF="0004ff1.htm">Figure 1</A>(e). <A NAME="rf2"><A HREF="0004ff2.htm">Figure 2</A> provides a proof of the theorem in <A NAME="rf1"><A HREF="0004ff1.htm">Figure 1</A>(b).</p><p>The steps to compute <i>M(a,b)</i> are:</p><p>1. Compute <i>b<sup>2</i></sup> using shift and add operations. This takes <i>N</i> iterations, where <i>N</i> is the number of bits in <i>b</i>.</p><p>2. Set the initial value of increment <i>d</i> to 2<sup><i>n</i></sup>, where <i>n=(N-1)<sup>th</i></sup> bit.</p><p>3. Set <i>r</i>=0.</p><p>4. Compute <i>(r+d)<sup>2</sup>+2&times;a&times;(r+d)</i>, by computing <i>(d<sup>2</sup>+2&times;r&times;d+2&times;a&times;d)</i> and adding to previous value of <i>(r<sup>2</sup>+2&times;a&times;r)</i>. Since <i>d</i> is always a power of 2, this can be computed using shift and add operations.</p><p>5. If <i>(r+d)<sup>2</sup>+2&times;a&times;(r+d)&lt;= b<sup>2</i></sup>, update <i>r</i> to <i>r+d</i>; or else do not update.</p><p>6. Reduce the increment <i>d</i> to next bit -- <i>2<sup>(n-1)</sup>.</i></p><p>7. Repeat steps 4 to 6 until <i>d</i> becomes 1, (<i>N</i>-1 iterations).</p><p>8. Return <i>M=r+a</i>.</p><p></p><p>You can see that the number of iterations depends on the smallest number <i>b,</i> and the result is accurate to 1 LSB. Again, <A NAME="rl1"><A HREF="#l1">Listing One</A> is C++ code that implements this. In this example, validation of input arguments are omitted.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>unsigned long imag(unsigned int a, unsigned int b){ unsigned int  l, r, d; unsigned long d2, b2, R, D; R = 0; l = 0; b2 = 0; r  = b; do {  d = 1L &lt;&lt; l;  if(b &amp; d)  {   b2 += (b &lt;&lt; l);  }  l++;    // find the number of bits in b }while(r &gt;&gt;= 1); l--; while(l --) {  d   = 1L &lt;&lt; l;   // setting the increment  d2  = d &lt;&lt; l;  D   = d2 + ((a + r) &lt;&lt; (l + 1));// D = d**2 + 2*r*d + 2*a*d;  if((R + D) &lt;= b2)  {   r += d;   // updating value of r.   R += D;  } } return (r + a);}</pre><P><A HREF="#rl1">Back to Article</A></P></body></html>