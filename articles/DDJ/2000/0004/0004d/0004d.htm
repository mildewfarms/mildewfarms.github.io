<html><head><title>Apr00: The Fastest Sorting Algorithm?</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>The Fastest Sorting Algorithm?</h1><p><i>Dr. Dobb's Journal</i> April 2000</p><h2>Sorting n integers in time proportional  to n log log n</h2><h3>By Stefan Nilsson</h3><I>Stefan is a lecturer in the Department of Computer Science at the Royal Institute of Technology (KTH) in Stockholm, Sweden. He can be reached at snilsson@nada.kth.se.</I><hr><a name="rs1"><a href="0004ds1.htm">How to Avoid Initializing Memory</a><hr><p>Which sorting algorithm is the fastest? Ask this question to any group of programmers and you'll get an animated discussion. Of course, there is no one answer. It depends not only on the algorithm, but also on the computer, data, and implementation. However, if you count the number of operations needed to sort integer numbers on a standard von Neumann computer, there is a clear winner -- the algorithm presented in the paper "Sorting In Linear Time?" by A. Andersson, T. Hagerup, S. Nilsson, and R. Raman (<i>Proceedings of the 27th Annual ACM Symposium on the Theory of Computing</i>, 1995). It sorts <i>n</i> integers in time proportional to <i>n log log n</i>. In this article, I'll give you a complete description of this algorithm.</p><p>Can it be done even faster? No one knows. We only know that it can't possibly be done using less than <i>n</i> operations: An algorithm using fewer operations than that can't look at each of the <i>n</i> numbers and, therefore, might leave some of the numbers out of order.</p><DDJADVERTISEMENT INLINE><p>Even though the <i>n log log n</i> time-sorting algorithm came about as a theoretical game, its real-life performance is good. A C implementation like nloglogn.c ( available electronically; see "Resource Center," page 5) with no particular optimizations runs faster on a typical 32-bit machine than many standard textbook sorting algorithms. </p><h3>The Problem </h3><p>To achieve agreement when discussing the speed of a sorting algorithm, it's necessary to establish some common ground. How do we measure speed? There is a well-established model -- the von Neumann computer, or unit-cost RAM model -- widely used by computer scientists to evaluate algorithms without introducing all the complexities of real-world computers. This model doesn't account for some important things, such as the performance gap between RAM and CPU, but typically gives good approximations of real-life performance.</p><p>There is nothing strange about the unit-cost RAM model. It's probably similar to your mental image of a computer. The computer has a RAM divided into words of <i>w</i> bits -- the "word length" of the machine. Each word has an address, and a word can be accessed in constant time given its address. The computer has a CPU capable of performing a small number of instructions, such as reading and writing words in RAM, and performing basic arithmetical and logical operations. Each of these operations can be performed in a constant number of machine cycles.</p><p>If you don't use the full power of the RAM model, but only consider sorting algorithms that operate by comparing elements pairwise, it's well known that at least <i>n log n</i> comparisons are needed to sort <i>n</i> elements in the worst case. There are plenty of algorithms, such as mergesort and heapsort, that achieve this bound.</p><p>Other sorting techniques may be faster. For example, using radix sorting, you can sort <i>n</i> word-sized integers by scanning the data a few bits at a time. Each scan can be done in linear time, and the number of scans depends on the word length <i>w</i>. Hence, the time for radix sorting is proportional to <i>nw</i>. Here, it's easy to make a mistake. On most computers, <i>w</i> is a small number (typically 32 or 64), and you might be tempted to state that radix sorting is a linear time sorting algorithm. Not so. The algorithm will only work if <i>w&gt;=log n</i>. If not, you wouldn't even be able to store the numbers. Since each memory address is a word consisting of <i>w</i> bits, the address space won't accommodate <i>n</i> numbers if <i>w&lt;log n</i>. Hence, in the unit-cost RAM model, radix sort also runs in time proportional to <i>n log n</i>.</p><p>I'll now describe an algorithm that does not depend on the word length. For any word length <i>w</i>, <i>w &gt;=log n</i>, it sorts <i>n</i> word-sized integers in time proportional to<i> n log log n.</i></p><h3>The Algorithm</h3><p>With this algorithm, the sorting is performed in two phases. In the first phase, you reduce the size of the numbers using radix sorting techniques. The elements become smaller and the number of elements doesn't increase. In fact, in linear time, it's possible to cut the number of bits of each number in half.</p><p>In the second phase, you perform a mergesort on the shortened numbers. Because the numbers are now much shorter, several numbers will fit in a single machine word. With several numbers in one word, it's possible to do several operations on these numbers in parallel using the shift and bitwise AND/OR/XOR operations found on most computers. In fact, using a scheme known as "packed merging," you can merge two sorted sequences of <i>k</i> numbers, each of which fits in one word, in time proportional to <i>log k</i>. This is an improvement on the standard merging algorithm, which requires time proportional to <i>k</i>.</p><p>Given these building blocks, we are almost done. In the first phase, you perform <i>log log n</i> reductions. This is done in <i>n log log n</i> time, because each reduction takes linear time. After halving the number of bits <i>log log</i> <i>n</i> times, the numbers will be so small that you can fit <i>k=log n</i> numbers within one word.</p><p>In the second phase, you use the packed merging as a subroutine in a standard mergesort. You perform the merging bottom up. Start by sorting subsequences of length <i>k</i>. Each of the <i>n/k</i> subsequences is sorted in <i>k log k</i> time using a standard comparison-based algorithm, such as mergesort. Plugging in <i>k=log n</i>, you see that this adds up to  <i>n log log n</i>.</p><p>You now combine these sorted sequences pairwise using packed merging, and thereby create longer sorted sequences. Each sequence is packed in a single machine word. In this first round, you need to merge <i>n/2k</i> pairs, each merging is done in <i>log k</i> time using packed merging. This sums up to <i>n/2k</i>&times;<i>log </i>k.</p><p>In the next round, you need to merge <i>n/4k</i> pairs, each consisting of two words. This is done in <i>n/4k</i>&times;<i>2 log k=n/2k</i>&times;<i>log k</i> time, the same time bound as before. In fact, you'll get the same result for each round.</p><p>Because the length of the sequences double in each round, the number of rounds is <i>log n/k</i>. Hence, the total time for this version of mergesort is <i>log n/k</i>&times;<i>n/2k</i>&times;<i>log k</i>. Plugging in <i>k=log n</i>, you see that this expression is also no more than <i>n log log n</i>.</p><p>At this point, the data is sorted and no more than <i>n log log n</i> time has elapsed, since both the reduction phase and the mergesorting phase run in time proportional to <i>n log log n</i>.</p><h3>Reducing the Number Size</h3><p>There are several alternative algorithms that can be used for reducing a sorting problem to one with shorter numbers. Which to chose depends on whether you want to optimize the rate of reduction, the speed of the algorithm, or the amount of memory required. Here, I'll show you a simple algorithm that reduces the number of bits by a factor of 2. It runs in linear time, but uses plenty of memory.</p><p>Assume that you want to sort <i>n</i> <i>b</i>-bit numbers. I'll use a bucketing scheme with two bucket tables: High and Low. Each table entry can hold a linked list of numbers. I'll explain the algorithm using a small example. In <A NAME="rf1"><A HREF="0004df1.htm">Figure 1</A>, you see seven 6-bit numbers to be sorted. <A NAME="rf1"><A HREF="0004df1.htm">Figure 1</A> also shows the two bucket tables and a batch list used to record which buckets are actually being used. This is necessary because you cannot afford to inspect every single bucket: The number of buckets may be much larger than the number of elements.</p><p>The first step in <A NAME="rf1"><A HREF="0004df1.htm">Figure 1</A> is to perform bucketing on the high-order bits; in this example, the first 3 bits of each number. Every time a bucket is used for the first time, the number of this bucket is recorded in the batch list.</p><p><A NAME="rf2"><A HREF="0004df2.htm">Figure 2</A> shows the second step of the algorithm, where you traverse each non-empty bucket in the High bucket table, moving elements into the Low bucket table. There are several important things to note.</p><ul>  <li>You use the batch to find the nonempty buckets. In this way, the whole operation can be performed in linear time.  <li>When a Low bucket is used for the first time, the bucket is recorded in the batch.  <li>You don't move all of the elements. The minimum element in each High bucket is left behind. This is crucial. The batch will be our reduced sorting problem and it must not contain more than <i>n</i> elements. By leaving one element behind in each nonempty High bucket, you ensure that the total number of nonempty buckets, and hence the number of entries in the batch, is at most <i>n</i>.</ul><p>The next step is to sort the batch. This is the reduced sorting problem -- the batch contains at most <i>n</i> numbers and each number has <i>b/2</i> bits.</p><p>Using the sorted batch, it's straightforward to assemble the numbers in ascending order. You start by moving numbers back from the Low bucket list to the High bucket list. <A NAME="rf3"><A HREF="0004df3.htm">Figure 3</A> is the result. Once again, you use the batch to find the nonempty buckets. But because the batch is now sorted, the Low buckets will be visited in order. Hence, each High bucket will end up containing a sorted list.</p><p>Finally, you traverse the nonempty High buckets, once again using the sorted batch, to produce the final sorted list.</p><p>You might have noticed a problem with this algorithm. How do you know if a bucket is empty? The obvious solution is to initialize each bucket to a null pointer. But you can't afford that: The number of buckets might be larger than <i>n</i> and the algorithm is supposed to run in linear time. The solution is a bit tricky; see the accompanying text box entitled "How to Avoid Initializing Memory." </p><h3>Fast Merging of Short Numbers </h3><p>All that remains is to merge short sequences of short numbers fast. The idea is to use a parallel algorithm that only requires very simple operations. If the algorithm is simple enough, it may be possible to simulate the parallelism using the inherent parallel nature of bitwise logical operations. For example, the bitwise OR operation performs <i>w</i> OR operations in parallel in just one machine cycle.</p><p>Batcher's bitonic merging fulfills the requirements. The algorithm is based on a property of so called "bitonic sequences." A bitonic sequence is almost sorted: It is the concatenation of an ascending and a descending sequence, or it can be obtained by a rotation (cyclic shift) of such a sequence. For example, the sequence 2, 3, 4, 3, 2, 1 is bitonic since it is the concatenation of the ascending sequence 2, 3, 4 and the descending sequence 3, 2, 1. The sequence 3, 4, 3, 2, 1, 2 is also bitonic, because it can be obtained by rotating the previous bitonic sequence. Bitonic sequences have a special property described in the lemma in <A NAME="rf5"><A HREF="0004df5.htm">Figure 5</A>. In other words:</p><p>1. Start with any bitonic sequence with an even number of elements, cut it in half, and form two new sequences by comparing the two halves element by element.</p><p>2. Form one sequence, <i>L</i>, containing the minimum elements of each pair and an other, <i>R</i>, which contains the maximum elements.</p><p>3. Then the sequences <i>L</i> and <i>R</i> will both be bitonic and each element of <i>L</i> will be smaller than or equal to each element of <i>R</i>.</p><p></p><p>Using this lemma, you can efficiently merge sorted sequences. For instance, by reversing one sequence in <A NAME="rf6"><A HREF="0004df6.htm">Figure 6</A> and appending the other, you get a bitonic sequence. In the first phase of the merging, you use the lemma to produce two subsequences <i>L</i> and <i>R</i>, where each element of <i>L</i> is no larger than each element of <i>R</i>. To complete the merging, you only need to sort <i>L</i> and <i>R</i> and concatenate the two sequences. This can be done using the lemma once again. Remember that both <i>L</i> and <i>R</i> are bitonic, so in the second phase, you can apply the bitonic lemma to each of them. The process is repeated recursively until the subsequences consist of just one element.</p><p>Packing all of the numbers in one machine word, it's possible to perform each phase of this merging algorithm in constant time; see <A NAME="rf7"><A HREF="0004df7.htm">Figure 7</A>. In this example, the numbers consist of 3 bits. You'll also need a special test bit for each number, so you can fit eight numbers into one 32-bit word. The special bitmask <i>N</i>, which indicates which elements are smaller, is computed using subtraction and the basic bitwise AND/OR operations. The second phase of the merging can be performed in a similar fashion. In fact, both subproblems can be solved in parallel using the same technique. (The full details can be found in nloglogn.c, available electronically.) </p><p>Each phase of this merging algorithm is implemented using just a constant number of basic operations so the total time to merge <i>k</i> numbers, small enough to fit within one word, is proportional to <i>log k</i>.</p><p><b>DDJ</b></p></body></html>