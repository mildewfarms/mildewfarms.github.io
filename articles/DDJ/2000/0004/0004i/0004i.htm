<html><head><title>Apr00: Lore: A Database Management System  for XML</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Lore: A Database Management System  for XML</h1><p><i>Dr. Dobb's Journal</i> April 2000</p><h2>A SQL-like  system for XML data</h2><h3>By Roy Goldman, Jason McHugh,  and Jennifer Widom</h3><I>Jennifer is a professor, and Roy and Jason are Ph.D. candidates in the department of computer science at Stanford University. The Lore team can be contacted at lore@db.stanford.edu, and more information about Lore and related XML data management projects can be found at http://www-db.stanford.edu/lore/.</I><hr><p>HTML revolutionized the way we specify the appearance of data on the Internet. Today, XML (the eXtensible Markup Language) is changing the way we specify the meaning of data. As XML continues to proliferate, new technologies are needed for managing, searching, and querying XML data. At Stanford University, we have developed Lore, a database management system (DBMS) designed specifically for XML. In the same way that SQL enables powerful queries in a relational DBMS, Lore provides the query language Lorel for issuing expressive queries over XML data. The Lore query engine uses specialized indexes and a cost-based query optimizer to process each query as efficiently as possible. Lore also includes a new keyword-based search technique that takes full advantage of XML's structured data format. </p><p>Lore is a multiuser DBMS, supporting crash recovery, materialized views, bulk loading of sets of related XML documents, and a declarative update language. Lore also has an external data manager that enables XML data from external sources to be fetched dynamically and combined with local data during query processing. All in all, the Lore system is composed of over 150,000 lines of C++ code. Lore executables for Linux and Sun Solaris are available for public use at http://www-db.stanford .edu/lore/. An online demo lets you query, search, and browse sample XML databases. If you are working on a project that requires source code, please contact us at lore@db.stanford.edu.</p><DDJADVERTISEMENT INLINE><h3>Overview of XML</h3><p>XML lets document authors define their own markup tags and attribute names to assign meaning to the data elements in the document. Further, XML elements can be nested and include references to indicate data relationships, as in <A NAME="rl1"><A HREF="#l1">Listing One</A>.</p><p>Unlike HTML, XML markup tags do not describe how to render the data. Rather, they provide descriptions of the data, allowing software to understand the meaning of the data automatically. (XSL, the eXtensible Stylesheet Language, is a separate language for specifying the presentation of XML documents. See "Rendering XML Documents Using XSL," by Sean McGrath, <i>DDJ</i>, July 1998.) If we store data for many movies in the aforementioned format, it becomes possible for software systems to answer queries such as "What were the titles of the 1999 films that grossed more than $200 million in the USA?" Without XML, it is more difficult to identify the meaning of data in a document. For example, if the number "$100,000,000" appears somewhere in an HTML document, is it referring to a movie's revenue or budget? It may be possible to guess the correct answer based on document context, but such techniques are error-prone and brittle. XML markup eliminates such uncertainty, letting content providers specify the meaning of their data as they create it, and allowing content consumers to easily process the data automatically.</p><p>Well-formed XML does not require tags or attributes to be predeclared, and XML places no limits on how you nest different elements. The two movies in our example have some (but not all) attributes and subelements in common. For instance, we have only domestic revenue data for one movie; the same movie lacks information about its producers, and the other movie doesn't specify its running time. Sometimes, it may be desirable to restrict the structure of XML data. XML authors can optionally supply a Document Type Definition (DTD) to serve as a grammar that valid XML documents must adhere to.</p><p>XML documents are essentially tree structured, as dictated by the nesting of elements. However, real-world data often is graph structured -- a single data element may be referenced in multiple ways. Though we omit the details here, XML offers special ID and IDREF attribute types to enable any XML element to reference another element. Further, proposed standards such as XLink (see "XLink: The XML Linking Language," by Sean McGrath, <i>DDJ</i>, December 1998) and XPointer permit references across documents. Thus, we can generically view any set of XML documents as a directed, ordered graph of interrelated data elements and attributes.</p><h3>Querying XML with Lore</h3><p>Despite the popularity and power of both relational databases and search engines, neither technology is completely appropriate for XML. Traditionally, business data has been stored in relational databases, and SQL is the standard query language. Relational databases generally require data to be much more rigidly structured than XML. A database schema must be designed carefully before any data is loaded. It is difficult to manage data that does not adhere to predefined table structures, and if the structure of the data changes in any way, then the schema must be modified as well. While object-oriented databases do not require rigid table structures, they still rely heavily on predefined, immutable schemas. At the other extreme, search engines are extremely efficient at indexing many documents for keyword-based searches. Unfortunately, search engines are based on linear text and cannot take advantage of the rich structure and data relationships afforded by XML.</p><p>Five years ago, we set out to build a new DBMS designed specifically for semistructured data (such as XML, though it did not exist at the time) -- data that includes some structure beyond plain text, yet is irregular or changes too often to be modeled easily as relational or object-oriented data. Our system is called "Lore," and is a rich prototype DBMS for managing XML data. Lore decomposes XML data into its individual elements and attributes, storing a graph physically on disk. In Lore, DTDs are not required; that is, the XML loaded into Lore need not conform to any predefined grammar or schema.</p><p>Just as SQL is used to query relational databases, we have developed "Lorel," a declarative query language for XML. Lorel leverages SQL's familiar Select/From/ Where syntax, augmenting the language with powerful path expressions for specifying traversals through the XML graph. Lorel is closely related to OQL, the standard query language for object-oriented database systems.</p><p>To illustrate, the following query expresses the aforementioned English query: Find the titles of 1999 films with domestic revenue over $200 million. We assume that all movies in our data set follow the general format in <A NAME="rl1"><A HREF="#l1">Listing One</A>.</p><blockquote><p>SELECT M.Title</p><p>FROM MovieDB.Movie M, M.Revenue R</p><p>WHERE M.Year = 1999 AND R.Type = "Domestic" AND R.USD &gt; 200000000</p></blockquote><p>To understand this query, it's easiest to start with the <i>FROM</i> clause, which iterates over each <i>MovieDB.Movie</i> path, binding the <i>Movie</i> to the variable <i>M</i>. For each element bound to <i>M</i>, we bind each of its <i>Revenue</i> elements to <i>R</i>. Given each pair of bindings, we check the filtering conditions in the <i>WHERE</i> clause. If the pair of bindings passes the checks, we return the title of the movie as the query result in the <i>SELECT</i> clause.</p><p>By default, Lorel queries traverse both XML elements and attributes with matching tags or attribute names. In the aforementioned query, <i>R.USD</i> refers to the <i>USD</i> attribute and all USD subelements of the element bound to <i>R</i>. Lorel provides an optional syntax for restricting traversals to elements or attributes only.</p><p>Lore doesn't assume that any particular structure or patterns exists within the XML data. Hence, Lorel includes some features to help users write queries when they aren't exactly sure of the database's structure. For example, the following Lorel query finds movies that involve "George Lucas" in any way.</p><blockquote><p>SELECT M</p><p>FROM DB.Movie M</p><p>WHERE M.# = "George Lucas"</p></blockquote><p>The <i>#</i> is a shortcut that represents any number of any tags or attribute names -- if there is some path in the data graph from a movie element to the string "George Lucas," the query returns that movie.</p><p>Lorel also gracefully handles situations where data is incomplete. If a path mentioned in a query does not appear in the data, the system does not generate an error. Rather, the system just ignores that path expression and continues to process the rest of the query. Lore does have a warning system that can diagnose queries when unexpected results are returned. Among other features, the warning system can notify users when an nonexistent path expression has been entered.</p><p>Lorel is a powerful language with numerous features not illustrated here, including an expression calculator, subqueries, existential and universal quantification, and aggregation.</p><h3>Query Execution</h3><p>In any DBMS, the query engine is responsible for translating declarative queries into query results. The heart of the Lore query engine involves matching path expressions in the query to paths in the database. A naive approach would be a top-down execution strategy: Starting at the root of our database, we could exhaustively check all possible paths to find the elements that satisfy our query. This approach can be extremely inefficient, however, depending on the database and/or the query.</p><p>As with typical DBMSs, Lore supports indexes to speed up specific types of database accesses. For example, users might create an index on movie revenue values to improve the performance of the aforementioned query that finds the high-grossing films. The disadvantage of an index is that database updates become more expensive, because the index must be updated as well. Still, indexes can offer dramatic improvements in query performance. </p><p>Lore supports several different types of indexes. The value index enables fast location of values satisfying specified conditions (as with movie revenue). The edge index quickly locates elements or attributes with a specific tag or name. The path index enables fast identification of all elements reached by a specific path (all <i>DB.Movie.Revenue</i> elements, for instance). </p><p>In Lore, data is stored as a directed graph: The physical links between elements are only in one direction. To enable backward navigation, Lore has one more index -- the link index -- which returns the parents of a given XML element. Lore also has several specialized indexes to enhance keyword-based searches.</p><p>By leveraging these indexes, the Lore execution engine can consider many strategies beyond the top-down approach. As the next example demonstrates, the best execution strategy for a given query depends on the shape of the database being queried.</p><p>Consider the query to "find all elements reachable via A.B.C whose value is 5." In <A NAME="rf1"><A HREF="0004if1.htm">Figure 1</A>(a), there is only one path matching the tags <i>A.B.C</i>, and the value of the element reachable along that path is indeed 5. In this case, top-down evaluation from the root is the best strategy, since we won't explore any paths that don't satisfy the query.</p><p><A NAME="rf1"><A HREF="0004if1.htm">Figure 1</A>(b) shows a database where there are many <i>A.B.C</i> paths. In this case, a top-down execution strategy will perform poorly and will in fact be forced to examine the entire database. Suppose, however, that you first use a value index to locate all elements with value 5, and then traverse the graph backwards to find all matching paths. We call this a "bottom-up" strategy. For the database in <A NAME="rf1"><A HREF="0004if1.htm">Figure 1</A>(b), such a strategy is ideal, because you again need only check one (correct) path to find the query result. In <A NAME="rf1"><A HREF="0004if1.htm">Figure 1</A>(a), a bottom-up strategy would perform poorly: Our index would return all leaf elements, and we would have to traverse the database all the way up to the root before eliminating most of the paths from the query result.</p><p>Finally, <A NAME="rf1"><A HREF="0004if1.htm">Figure 1</A>(c) shows a sample database where neither top-down nor bottom-up performs well. A top-down strategy will have to check many <i>A.B.C</i> paths. A bottom-up strategy begins with just one <i>C</i> element with the value 5, but as it traverses backwards to identify matching paths, it will incorrectly follow many <i>B</i> parents that themselves have <i>D</i> parents rather than the <i>A</i> parents needed to match the query. Indeed, in this case, a hybrid strategy is best. First, we traverse top-down to locate all elements reachable by <i>A.B. </i>Next, we use an index to find the <i>C</i> element with value 5, but we traverse only one step backwards; that is, we do not traverse the <i>B</i> edges. Finally, we take the intersection of our two intermediate results to form the single complete path in our answer.</p><p>In general, there may be many different options for executing a query. Lore has a query optimizer that evaluates many different strategies and ultimately chooses the query plan that it predicts will yield the best performance. The strategies considered by the query optimizer are highly dependent on which indexes have been created for a given database. For example, if we hadn't created any indexes on the databases in <A NAME="rf1"><A HREF="0004if1.htm">Figure 1</A>, we would have no choice but to use the top-down execution plan. It is just as important that the optimizer has some idea of the shape of the database so that it can choose the best execution strategy. To this end, Lore has a module that periodically gathers important statistics about the database. This statistics module can answer questions for the optimizer such as:</p><ul>  <li>If we traverse <i>A.B</i>, what are the odds of finding a <i>C</i>?  <li>What is the distribution of integer <i>C </i>values in the database?  <li>How many instances are there of the <i>A.B.C</i>?</ul><p>By combining such information with a cost model for predicting the time required for different execution strategies, the optimizer works to select the best execution strategy for any query and any state of the database.</p><h3>DataGuides</h3><p>Neither XML nor Lore requires the structure of the data to be fixed ahead of time (that is, a DTD is not required). Without some idea of the tag and attribute patterns in a database, it can be difficult for users to formulate meaningful queries. Similarly, the execution engine also needs some understanding of a database's structure in order to process a query efficiently. Hence, Lore supports a novel feature called the "DataGuide" -- a concise, dynamically generated structural summary of an XML database. In many ways, a DataGuide serves the role of a DTD or a database schema: End users and the system itself can consult the DataGuide for useful information about the overall structure of the database. However, in Lore, the relationship is flipped around. Instead of data being required to conform to the schema or DTD, the system automatically maintains the DataGuide such that it always accurately summarizes the current structure of the database.</p><p>A DataGuide can itself be represented in XML. Each tag/attribute path in the original database appears exactly once in the DataGuide, and every path in the DataGuide appears in the original database. For our <i>Movie</i> data set, <A NAME="rl2"><A HREF="#l2">Listing Two</A> represents its DataGuide.</p><p>Even though our original data set might contain thousands of movies, the path <i>MovieDB.Movie</i> appears only once in the DataGuide. Because DataGuide elements and attributes represent many database instances, we leave actual data values out of the DataGuide. </p><p>The DataGuide has the useful property that allows you to check whether or not a path exists in the database in time proportional to the length of the path independent of the size of the database. Also, we can use the DataGuide to store many of the statistics needed for query processing, and we use it to support the path index mentioned earlier. From a user's perspective, DataGuides are a visible component of our web-based user interface to Lore: A Java applet lets users explore the DataGuide interactively and then formulate Lorel queries directly from it.</p><h3>Keyword and Proximity Search</h3><p>While declarative languages such as Lorel enable expressive queries, they are hardly aimed at the typical end user. An interactive DataGuide makes it easier to formulate queries, but the Web has shown that casual users are comfortable typing keywords to initiate a search. To this end, Lore has a specialized text index that, given a specific keyword, can quickly identify data containing that keyword in its tag, attribute name, or atomic value. </p><p>For XML, a much more interesting issue is how to handle a search over multiple keywords. If you are interested in movies involving "Liam Neeson," you might try to search for "movie near Neeson." Search engines such as AltaVista handle such a search by finding HTML pages that contain both words close to each other in the document text. But in XML, the structural relationships may be much more important than the physical layout of the XML text. In our small example, the string "Liam Neeson" is actually fewer characters away from <i>The Sixth Sense</i> than from <i>Star Wars</i>. But if you take the structure of the data into account, you know that Neeson is closely related to <i>Star Wars</i> and unrelated to <i>The Sixth Sense</i>.</p><p>Generalizing this example, you would like the <i>near</i> operator in XML to measure proximity based on the logical relationships between data elements instead of by text alone. Lore includes an innovative approach for performing this kind of structural proximity search, where the distance between elements is measured as the shortest path between those elements in the database graph. Usage experiments show that this definition does a good job of matching our intuition for what the <i>near </i>operator should do in XML. Computing the shortest paths among database elements can be very expensive computationally. Hence, we have developed a specialized compact index that enables fast proximity searches.</p><h3>References and Related Work</h3><p>An overview of XML is available at http:// www.w3.org/TR/WD-xml-lang-970331.html, December 1997. The Lore system is described in J. McHugh, S. Abiteboul, R. Goldman, D. Quass, and J. Widom: "Lore: A Database Management System for Semistructured Data." <i>SIGMOD Record</i>, 26(3):54-66, September 1997. The Lorel language is covered in detail in S. Abiteboul, D. Quass, J. McHugh, J. Widom, and J. Wiener: "The Lorel Query Language for Semistructured Data." <i>International Journal on Digital Libraries</i>, 1(1):68-88, April 1997.</p><p>Originally, Lore was designed for a data model that is similar, but not identical, to XML. (XML did not exist at the time Lore was conceived.) The changes required to migrate Lore to fully support XML are described by R. Goldman, J. McHugh, and J. Widom in "From Semistructured Data to XML: Migrating the Lore data Model and Query Language," in <i>Proceedings of the 2nd International Workshop on the Web and Databases</i> (WebDB '99), June 1999.</p><p>Lore' s query optimizer, DataGuides, and proximity search feature, are described at the Lore web site, http://www-db.stanford .edu/lore. There are other active efforts toward developing query languages for XML. XQL has been supported by many companies. See J. Robie, J. Lapp, and D. Schach's "XML Query Language (XQL)," in <i>Proceedings of QL '</i>98: The Query Languages Workshop, December 1998. Papers are available at http://www.w3.org/TandS/ QL/QL98/.</p><p>XML-QL is another XML query language. See A. Deutsch, M. Fernandez, D. Florescu, A. Levy, and D. Suciu, "A Query Language for XML," in <i>Proceedings of the Eighth International World Wide Web Conference</i> (WWW8), 1999. Lorel, XQL, and XML-QL have many common features; we anticipate that any future XML query language standardization efforts will borrow heavily from these languages.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>&lt;MovieDB&gt;   &lt;Movie Title = "Star Wars: Episode I - The Phantom Menace" Year = "1999"&gt;        &lt;Director&gt;George Lucas&lt;/Director&gt;        &lt;Producer&gt;George Lucas&lt;/Producer&gt;        &lt;Producer&gt;Rick McCallum&lt;/Producer&gt;        &lt;Writer&gt;George Lucas&lt;/Writer&gt;        &lt;Actor&gt;Ewan McGregor&lt;/Actor&gt;        &lt;Actor&gt;Liam Neeson&lt;/Actor&gt;        &lt;Revenue Type="Domestic" USD="427600000"/&gt;        &lt;Revenue Type="International" USD="352100000"/&gt;    &lt;/Movie&gt;    &lt;Movie Title="The Sixth Sense" Year="1999" Runtime= "106"&gt;        &lt;Director&gt;M. Night Shyamalan&lt;/Director&gt;        &lt;Writer&gt;M. Night Shyamalan&lt;/Writer&gt;        &lt;Actor&gt;Bruce Willis&lt;/Actor&gt;        &lt;Revenue Type="Domestic" USD="264000000"/&gt;    &lt;/Movie&gt;&lt;/MovieDB&gt;</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>&lt;/MovieDB&gt;    &lt;Movie Title="" Year="" Runtime= ""&gt;        &lt;Director/&gt;        &lt;Writer/&gt;        &lt;Actor/&gt;        &lt;Revenue Type="" USD=""/&gt;    &lt;/Movie&gt;&lt;/MovieDB&gt;</pre><P><A HREF="#rl2">Back to Article</A></P></body></html>