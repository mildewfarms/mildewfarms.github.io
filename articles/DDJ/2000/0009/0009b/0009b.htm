<html><head><title>Sep00: The Generic Graph Component Library</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>The Generic Graph Component Library</h1><p><i>Dr. Dobb's Journal</i> September 2000</p><h2>Generic programming for graph algorithms</h2><h3>By Jeremy G. Siek, Lie-Quan Lee, and Andrew Lumsdaine</h3><I>The authors are members of the scientific computing lab at the University of Notre Dame. They can be contacted at jsiek@lsc.nd.edu, llee1@ lsc.nd.edu, and lumsg@lsc.nd.edu, respectively.</I><hr><p>The Standard Template Library has established a solid foundation for the development of reusable algorithms and data structures in C++. It has provided programmers with a way to think about designing reusable components (generic programming), and has demonstrated the programming techniques necessary to build efficient implementations. However, there are many problem domains beyond those addressed by the STL; consequently, there are many opportunities for applying generic programming. One particularly important domain is that of graph algorithms and data structures. The graph abstraction is widely used to model structures and relationships in many fields. Graph algorithms are extremely important in such diverse application areas as design automation, transportation, optimization, and databases. Our own interest in graph algorithms originates with our work on sparse matrix ordering algorithms for scientific computing.</p><p>The domain of graph algorithms is ripe for the application of generic programming. There is a large existing body of useful algorithms, yet the number of ways that people use to represent graphs in memory almost matches the number of applications that use graphs. The ability to freely interchange graph algorithms with graph representations would be an important contribution to the field, and this is what generic programming has to offer.</p><DDJADVERTISEMENT INLINE><p>In January, 1999, we did a survey of existing graph libraries. Some of the libraries we looked at were LEDA (by Kurt Mehlhorn and Stefan Naeher, http:// www.mpi-sb.mpg.de/LEDA/leda.html), the Graph Template Library (GTL) (by Michael Forster, Andreas Pick, and Marcus Raitner, http://www.fmi.uni-passau.de/ Graphlet/GTL/), Combinatorica (see <i>Implementing Discrete Mathematics</i>, by Steven Skiena, Addison-Wesley, 1990), and Stanford GraphBase (see <i>Stanford GraphBase: A Platform for Combinatorial Computing</i>, by Donald E. Knuth, ACM Press, 1994). We also looked at software repositories such as Netlib (http://www .netlib.org/), which include graph algorithms. These libraries and repositories represent a significant amount of potentially reusable algorithms and data structures. However, none of the libraries applied the principles of generic programming and consequently did not receive the associated benefits of flexibility and efficiency. Therefore, we began construction of our own graph library, the Generic Graph Component Library (GGCL) (see "Generic Graph Algorithms for Sparse Matrix Ordering," ISCOPE '99, and "The Generic Graph Component Library," OOPSLA '99, both by Lie-Quan Lee, Jeremy G. Siek, and Andrew Lumsdaine), drawing on previous experience with the development of the Matrix Template Library (see "The Matrix Template Library: A Generic Programming Approach to High-Performance Numerical Linear Algebra," International Symposium on Computing in Object-Oriented Parallel Environments, 1998; and "Modern Software Tools in Scientific Computing," <i>A Modern Framework for Portable High-Performance Numerical Linear Algebra</i>, Birkhauser, 1999, both by Jeremy G. Siek and Andrew Lumsdaine). The most important aspect of designing the library was to define an interface that allowed for maximum flexibility. This is a list of our initial requirements:</p><ul>  <li>Provide a collection of useful generic graph algorithms.  <li>Enable almost any underlying graph data structure to be used with the generic graph algorithms.  <li>Provide a single generic interface to access graph vertex and edge properties, while at the same time not prescribing how the properties are stored in memory.  <li>Provide a mechanism for user-defined extensions to graph algorithm functionality (that is, the way functors make STL algorithms extensible).  <li>Define a syntax and naming scheme that is a close match to existing libraries and to notations used in graph algorithm literature.</ul><h3>The Graph Traversal Interface </h3><p>When designing a generic library, one starts by analyzing how the data structures are used in the algorithms. <A NAME="rl1"><A HREF="#l1">Listings One</A>, Two, Three, and Four show pseudocode for simple algorithms that demonstrate different ways graph structures are typically accessed. (The initialization step has been omitted from the algorithms. Also, the depth-first search algorithm [<A NAME="rl1"><A HREF="#l1">Listing One</A>] does not show the operations that would be invoked to do some useful task during the search.) The access patterns can be categorized as follows:</p><p></p><ul>  <li>Traverse all of the vertices in a graph.  <li>Traverse all of the edges in a graph.  <li>For some vertex, visit the out-edges.  <li>For some vertex, visit the adjacent vertices. (Accessing adjacent vertices is really the same access pattern as for out-edges. The adjacent vertex is just the target vertex of the out-edge.)   <li>Access the edge (if it exists) connecting vertex <i>u</i> and <i>v</i>.</ul><p>The pseudocode from the graph algorithms and the derived categories of graph traversal provide a reasonable basis for defining the actual interface to be used by the generic algorithms. The only real challenge in defining the interface is in taking care not to define (prescribe) too much. For example, an object-oriented approach to a graph library interface might define a particular vertex list class to provide access to all the vertices in a graph:</p><blockquote><p>class Graph {</p><p>   // ...</p><p>   list&lt;Vertex&gt; adj();</p><p>   // ...</p><p>};</p></blockquote><p>However, in the interest of flexibility, we do not necessarily want to define the graph interface based on a particular set of classes. Instead, we should define a set of minimal requirements that any type must meet to be considered a graph. As with STL iterators, the requirements are expressed as a set of valid expressions and associated types (that are accessed through a traits class). We use the term "concept" to refer to a collection of these requirements. By defining the interface in this way we greatly increase the opportunities for reuse. Many different graph data structure implementations (typically optimized for different situations) can all share this common interface and be used by the same generic algorithms. The interface we present here is the third revision of the graph interface. With each revision we have fine-tuned the interface to be more generic and easier to use. This revision (which should be the final one) is a result of collaborations with Dietmar K&uuml;hl and other members of the Boost group whom we are working with to define a standard graph interface. </p><p>As with the iterator concepts of the STL, we factor the graph into several concepts (<i>InputIterator</i>, <i>RandomAccessIterator, </i>etc). This enables us to succinctly state the requirements for algorithms without overstating them.</p><p>The graph concepts are listed in <A NAME="rf1"><A HREF="0009bf1.htm">Figure 1</A>. The arrows denote the refinement relation, where one concept adds to the requirements of another concept. The requirements for each of the graph concepts is in <A NAME="rt2"><A HREF="0009bt2.htm">Table 2</A>. The notation used in the requirements table is in <A NAME="rt1"><A HREF="0009bt1.htm">Table 1</A>. There are several references in the requirements table to concepts such as <i>Assignable</i>, whose definitions can be found in the online documentation for the SGI STL implementation or in Austern's book, <i>Generic Programming and the STL</i>. </p><p>In addition to the graph concepts, one new iterator concept had to be created -- the <i>MultiPassInputIterator</i>. This concept is a refinement of <i>InputIterator</i> and adds the requirements that the iterator can be used to make multiple passes through a range, and that if <i>it</i>1<i>==it</i>2 and <i>it</i>1 is dereferenceable then <i>++it</i>1<i>==++it</i>2. All of the functions in the graph traversal interface are assumed to be amortized constant time and space. That is, the stated complexity for graph algorithms will be valid so long as the graph traversal operations are amortized constant time. </p><h3>Property Accessors</h3><p>Graph algorithms need to access properties associated with the vertices and edges of a graph. For example, problem data (such as the length or capacity of an edge) is used by the algorithms, as well as auxiliary data flags (like color) to indicate whether a vertex has been visited. There are many possibilities for how these properties can be stored in memory ranging from members of vertex and edge objects, to arrays indexed by some index, to properties that are computed when needed, such as the distance between two vertices in a graph with Euclidian distances. To relieve generic algorithms from the details of the underlying property representation, property accessor abstraction is introduced. (In previous papers describing GGCL, the property accessor concept was named <i>Decorator</i> and used <i>operator[]</i> instead of <i>put()</i> and <i>get()</i>. In Kuhl's masters thesis, property accessors are called "data accessors.")</p><p>Several categories of property accessors provide different access capabilities: </p><ul>  <li><i>	readable.</i> The associated property data can only be read. The data is returned by value. Many property accessors defining the problem input (such as edge weight) can be defined as readable property accessors.  <li><i>	writeable.</i> The associated property can only be written to. The parent array used to record the paths in a breadth-first search tree is an example of a property accessor that would be defined writeable.   <li><i>	read/write.</i> The associated property can both be written and read. The distance property use in Dijkstra's shortest paths algorithm (<A NAME="rl2"><A HREF="#l2">Listing Two</A>) would need to provide both read and write capabilities.  <li><i>	lvalue.</i> The associated property is actually represented in memory and it is possible to get a reference to it. The property accessors in the <i>lvalue</i> category also support the requirements for read/write property accessors.</ul><p><A NAME="rt4"><A HREF="0009bt4.htm">Table 4</A> lists the requirements for the respective categories of property accessors, while <A NAME="rt3"><A HREF="0009bt3.htm">Table 3</A> lists the notation used in the property accessor table. In addition to the requirements in the table, property accessors must meet the requirements of <i>CopyConstructible</i>. To use property accessors, it is necessary to have some object identifier that is passed to the property accessor. The description of property accessors is purposefully vague on the exact type of the identifier, mainly to allow for flexibility. Since the property accessor operations are global functions, it is possible to overload the accessor functions such that nearly arbitrary object identifiers can be used. In the context of graph algorithms, the object identifiers are typically the vertex and edge descriptors described in <A NAME="rt2"><A HREF="0009bt2.htm">Table 2</A>. </p><h3>Graph Visitors </h3><p>In the same way that function objects or functors are used to make STL algorithms more flexible, we can use functor-like objects to make the graph algorithms more flexible. (As of this writing, the <i>GraphVisitor</i> concept has not been considered for part of the Boost graph interface.) We use the name "GraphVisitor" for this concept because the intent is similar to the Gang of Four Visitor pattern (see <i>Design Patterns, </i>by Gamma et al.). We wish to add operations to be performed on the graph without changing the source code for the graphs or for the generic algorithms. <A NAME="rt5"><A HREF="0009bt5.htm">Table 5</A> shows the definition of the <i>GraphVisitor</i> concept. In the table, <i>v</i> is a visitor object, <i>u </i>and <i>s</i> are vertices, <i>e</i> is an edge, <i>g</i> is a graph, and <i>bag</i> is a bag (a container with the methods <i>push()</i>, <i>pop()</i>, and <i>top()</i>, such as a stack or queue). </p><p>The <i>GraphVisitor</i> is more complex than a function object, since there are several well-defined entry points at which the user may want to introduce a call-back. For example, <i>discover()</i> is invoked when an undiscovered vertex is encountered within the algorithm. The <i>process()</i> method is invoked when an edge is encountered. The <i>GraphVisitor</i> concept plays an important role in the GGCL algorithms.</p><h3>The Generic Graph Component Library </h3><p>The Generic Graph Component Library is a collection of algorithms and data structures that meet the interface requirements described in the previous sections. Currently, the algorithms include many of the classical graph algorithms and several sparse matrix ordering algorithms, though the list is continually growing. A recent addition (see <A NAME="rt6"><A HREF="0009bt6.htm">Table 6</A>) is the Self Avoiding Walk (SAW) used in adaptive mesh refinement algorithms.</p><p>Perhaps one of the most exciting aspects of the GGCL implementation (at least from the implementor's point of view) is the way it takes advantage of the internal reuse that naturally occurs within graph algorithms. The basis of this reuse is the graph search pattern that underlies most graph algorithms. </p><p>With the use of the <i>GraphVisitor</i> concept, it is possible for GGCL to actually define a generalized graph <i>search()</i> function, which can then be used to implement most other graph algorithms. The code for <i>graph_search()</i> is given in <A NAME="rl6"><A HREF="#l6">Listing Six</A>. The <i>tie()</i> function used in <i>graph_search()</i> is a nice utility function created by Jaakko Jarvi that lets the values of a pair (or <i>n</i>-tuples) be assigned to variables in a way reminiscent of the language ML. </p><p>With the use of the <i>graph_search()</i> function, the implementation of <i>breadth_ first search()</i> and <i>depth_first search()</i> becomes somewhat trivial. The BFS uses a queue while DFS uses a stack, and they both use the coloring visitor to keep track of which vertices have been visited. The implementation of BFS and DFS is given in <A NAME="rl7"><A HREF="#l7">Listing Seven</A>, and the coloring visitor in <A NAME="rl8"><A HREF="#l8">Listing Eight</A>. The template argument <i>Super</i> in the coloring visitor may appear somewhat mystifying at first. We are using the Mixin technique to layer visitors, allowing multiple visitors to be applied during a single traversal of the graph. </p><p>The implementation of topological <i>sort()</i> is a great example of the power of graph visitors. As described in <i>Introduction to Algorithms</i>, by Thomas H. Cormen, Charles E. Leiserson, and Ronald L. Rivest (MIT Press, 1990), a topological sort can be accomplished with a depth-first search, where each vertex is output as it is finished. The GGCL algorithm is coded exactly in this way, as in <A NAME="rl9"><A HREF="#l9">Listing Nine</A>. </p><h3>GGCL Graph Data Structures </h3><p>The GGCL data structures components are highly modular, designed to provide plug-and-play levels of flexibility. There are facilities for attaching properties to GGCL graphs in a variety of ways, and GGCL graphs are designed to work well with the STL containers (or customized containers) as the underlying storage. For example, the <i>vec_adj_list</i> GGCL module turns a <i>std::vector&lt;EdgeList&gt;</i> into a type that conforms to the GGCL graph interface. It does this without wrapping <i>std::vector&lt;EdgeList&gt; </i>in an adaptor object. Instead, it merely overloads a few global functions. The <i>std::vector&lt;EdgeList&gt;</i> can then be passed as is to the GGCL graph algorithm. We call this technique "external adaptation."</p><p>The graph interface is defined solely in terms of global functions, so GGCL provides overloads for the interface functions and specifies <i>std::vector&lt;EdgeList&gt;</i> as the graph argument. An object of type <i>std::vector&lt;EdgeList&gt;</i> can then be passed as is to a GGCL graph algorithm. <A NAME="rl10"><A HREF="#l10">Listing Ten</A> gives a short example of this.</p><p>GGCL also provides support for many of the other common graph representations, including adjacency matrices and pointer-based (dynamic) graphs. </p><h3>Efficiency and Performance</h3><p>Efficiency is typically advertised as yet another advantage of generic programming -- and these claims are not simply hype. The efficiency that can be gained through the use of generic programming is astonishing. For example, the Matrix Template Library, a generic linear algebra library written completely in C++, is able to achieve performance as good as or better than vendor-tuned math libraries.</p><p>The flexibility within the GGCL is derived exclusively from static polymorphism (templates), not from dynamic polymorphism. As a result, all dispatch decisions are made at compile time, allowing the compiler to inline every function in the GGCL graph interface. Hence the abstraction penalty of the GGCL interface is completely eliminated. The machine instructions produced by the compiler are equivalent to what would be produced from hand-coded graph algorithms in C or Fortran. </p><h3>Comparison to General-Purpose Libraries </h3><p>Using a concise predefined implementation of adjacency list graph representation in GGCL, we compare the performance of the BFS algorithm (calculating the distance from the source and the predecessor for each vertex) with those in LEDA (Version 3.8), a popular object-oriented graph library, and those in GTL.</p><p><A NAME="rf2"><A HREF="0009bf2.htm">Figure 2</A> shows the results of the BFS applied to randomly generated graphs having a varying number of edges and a varying number of vertices. The y-axis is logarithmic. All results were obtained on a Sun Microsystems Ultra 30 with the UltraSPARC-II 296MHz microprocessor. For these experiments, GGCL is 5 to 7 times faster than LEDA. </p><h3>Comparison to Special-Purpose Library </h3><p>In addition, we demonstrate the performance of a GGCL-based implementation of the multiple minimum degree algorithm using selected matrices from the Harwell-Boeing collection and the University of Florida's sparse matrix collection. Our tests compare the execution time of our implementation against that of the equivalent SPARSPAK Fortran algorithm (GENMMD). For each case, our implementation and GENMMD produced identical orderings. The performance of our implementation is essentially equal to that of the Fortran implementation and even surpasses the Fortran implementation in a few cases. </p><h3>Availability </h3><p>The source code and complete documentation for the GGCL can be downloaded from the GGCL web site at http://www .lsc.nd.edu/research/ggcl and from <i>DDJ</i> (see "Resource Center," page 5). The graph interface described here can be found at the Boost home page at http://www.boost.org/. </p><h3>References</h3><p>Austern, Matthew H. <i>Generic Programming and the STL</i>. Addison-Wesley-Longman, 1998.</p><p>Gamma, Erich, Richard Helm, Ralph Johnson, and John Vlissides. <i>Design Patterns: Elements of Reusable Object-Oriented Software</i>. Addison-Wesley, 1994.</p><p>George, Alan, and Joseph W.H. Liu. "User's Guide for SPARSPAK: Waterloo Sparse Linear Equations Packages," <i>Technical Report, Department of Computer Science,</i> University of Waterloo, Waterloo, Ontario, 1980.</p><p>Heber, G., R. Biswas, and G.R. Gao. "Self-Avoiding Walks Over Adaptive Unstructured Grids," <i>Parallel and Distributed Processing</i>. Springer-Verlag, 1999.</p><p>Jarvi, Jaakko "Ml-style Tuple Assignment in Standard C++: Extending the Multiple Return Value Formalism," Technical Report 267, <i>TUCS, </i>April 1999.</p><p>Kuhl, Dietmar. <i>Design Patterns for the Implementation of Graph Algorithms</i>, Technische Universität Berlin, July 1996.</p><p>Liu, Joseph W.H. "Modification of the Minimum-degree Algorithm by Multiple Elimination," <i>ACM Transaction on Mathematical Software</i>, 1985.</p><p>Lo Russo, Graziano. "An Interview with Alexander Stepanov," <i>Edizioni Infomedia srl</i>, 1997.</p><p>Myers, Nathan. "A New and Useful Template Technique: Traits," <i>C++ Report</i>, June 1995.</p><p>Samaragdakis, Yannis and Don Batory. "Implementing Layered Designs With Mixin Layers," <i>Europe Conference on Object-Oriented Programming</i>, 1998.</p><p>Siek, Jeremy G. and Andrew Lumsdaine. "The Matrix Template Library: A Generic Programming Approach to High- performance Numerical Linear Algebra," <i>International Symposium on Computing in Object-Oriented Parallel Environments</i>, 1998.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>depth_first_search(Graph G, Color color){   for each vertex u in vertices(G) {     color[u] = white;     visit(u, color);   }}visit(Vertex u, Color color){   color[u] = gray;   for each vertex v in adj(u) {      if (color[v] = white)         visit(v);   }   color[u] = black;}</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>dijkstra_shortest_paths(Graph G, Vertex s, Distance d, Weight w, Parent p){   PriorityQueue Q;   push(s, Q);   while (Q is not empty) {      vertex u = pop(Q);      for each edge e=(u,v) in out-edges(u)        if (d[v] &gt; d[u] + w(e))           p[v] = u;   }}</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>bellman_ford_shortest_paths(Graph G, Weight w, Distance d, Parent p){   for k = 0...num_vertices(G)      for each edge e=(u,v) in edges(G)          if (relax(e, g, w, d))              p[v] = u;    for each each e=(u,v) in edges(g)      if (d[u] + w[e] &lt; d[v])         return false;}</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>extend_shortest_paths(AdjacencyMatrix G, Distance d, Weight w){   for (i=1...N)      for (j=1...N)         for (k=1..N) {           edge e_ij = G(i,j), e_ik = G(i,k), e_kj = G(k,j);           d[e_ij] = min( d[e_ij], d[e_ik] + w[e_kj];       }}</pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five</H4><pre>// WRONG! Overspecified requirementstemplate &lt;class RandomAccessIter1, class RandomAccessIter2&gt;void copy(RandomAccessIter1 first, RandomAccessIter1 last,        RandomAccessIter2 result){    while (first != last)       *first++ = *result++;}// Just righttemplate &lt;class InputIterator, class OutputIterator&gt;void copy(InputIterator first, InputIterator last, OutputIterator result){   while (first != last)       *first++ = *result++;}</pre><P><A HREF="#rl5">Back to Article</A></P><H4><A NAME="l6">Listing Six</H4><pre>template&lt;class IncidenceGraph, class Vertex, class Bag, class Visitor&gt;void graph_search(IncidenceGraph&amp; g, Vertex s, Bag&amp; bag, Visitor visitor){   Vertex u;   typename graph_traits&lt;IncidenceGraph&gt;::incidence_iterator i, end;   visitor.start(s);   bag.push(s);   while (! bag.empty()) {      u = bag.top();      if (visitor.is_undiscovered(u)) {          visitor.discover(u, bag);          for (tie(i,end) = out_edges(u,g); i != end; ++i)            visitor.process(*i, g, bag);      } else {        visitor.finish(u);        bag.pop();      }   }}</pre><P><A HREF="#rl6">Back to Article</A></P><H4><A NAME="l7">Listing Seven</H4><pre>template  &lt;class IncidenceGraph, class Vertex, class Color, class Visitor&gt;void breadth_first_search(IncidenceGraph&amp; g,                  Vertex s, Color color, Visitor visitor){    boost::queue&lt;Vertex&gt; q;    graph_search(g, s, q, visit_color(color, visitor));}template&lt;class VertexListGraph, class Color, class Visitor&gt;void depth_first_search(VertexListGraph&amp; g, Color color, Visitor visitor){   std::stack&lt;Vertex&gt; std;   typename graph_traits&lt;VertexGraph&gt;::vertex_iterator i, end;   for (tie(i,end) = vertices(g); i != end; ++i)       graph_search(g, *i, stk, visit_color(color, visitor));}</pre><P><A HREF="#rl7">Back to Article</A></P><H4><A NAME="l8">Listing Eight</H4><pre>template &lt; class Color, class Super = null_visitor&gt;class coloring_visitor : public Super {   // constructors and typedefs ...   template &lt;class Vertex&gt;   void initialize(Vertex u) {      set(color, u, color_tr::white());      Super::initialize(u);   }   template &lt;class Vertex, class Bag&gt;   void discover(Vertex u, Bag&amp; bag) {      set(color, u, color_tr::gray());      Super::discover(u, bag);   }   template &lt;class Vertex&gt;   void finish(Vertex u) {      if (get(color, u) != color_tr::black()) {      set(color, u, color_tr::black());      Super::finish(u);   }}template &lt;class Edge, class Graph, class Bag&gt;bool process(Edge e, Graph&amp; g, Bag&amp; bag) {   typedef typename graph_traits&lt;Graph&gt;::vertex_descriptor Vertex;   Vertex v = target(e, g);   if ( is_undiscovered(v) ) {      bag.push(v);      Super::process(e, g, bag);      return true;    } else if ( FocusOnEdge )      Super::process(e, g, bag);      return false;   }   template &lt;class Vertex&gt;   bool is_undiscovered(Vertex u) {       return (get(color,u) == color_tr::white());   }protected:   Color color;};// Helper class for creating color visitorstemplate &lt;class Color, class Super&gt;coloring_visitor&lt;Color, Super&gt;visit_color(Color c, Super b) {   return coloring_visitor&lt;Color, Super&gt;(c, b);}</pre><P><A HREF="#rl8">Back to Article</A></P><H4><A NAME="l9">Listing Nine</H4><pre>template&lt;class VertexListGraph, class OutputIter, class Color, class Visitor&gt;void topological_sort(   VertexListGraph&amp; G, OutputIter result, Color color, Visitor visitor){   topo_sort_visitor&lt;OutputIter, Visitor&gt; topo_visit(c, visitor);   depth_first_search(G, topo_visit, color);}template &lt;class OutputIterator, class Super = null_visitor&gt;struct topo_sort_visitor : public Super {   //constructors ...   template &lt;class Vertex&gt;   void finish(Vertex u) {      *result = u; ++result;      Super::finish(u);   }   OutputIterator result;};</pre><P><A HREF="#rl9">Back to Article</A></P><H4><A NAME="l10">Listing Ten</H4><pre>#include &lt;ggcl/vec_adj_list.hpp&gt;// ...typedef std::vector&lt; std::list&lt;int&gt; &gt; Graph;Graph g(N);// fill the graph...std::vector&lt;int&gt; color(N, WHITE), discover(N), finish(N);depth_first_search(g, color.begin(),     visit_time(discover.begin(), finish.begin()));</pre><P><A HREF="#rl10">Back to Article</A></P></body></html>