<html><head><title>Sep00: Algorithm Alley</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Exploiting  64-Bit Parallelism</h1><p><i>Dr. Dobb's Journal</i> September 2000</p><h3>By Ron Gutman</h3><I>Ron is a senior software engineer for AirFlash. He can be contacted at ron@  airflash.com.</I><hr><p>Sixty-four bits happen. Intel's 64-bit Itanium processor is being sampled, and Java anticipates 64-bit architectures with its 64-bit integer. Besides performing 64-bit memory fetches, stores, and arithmetic, you can expect 64-bit processors to perform shift and bitwise operations 64 bits at a time. The 64-bit operations provide some parallelism  -- twice as much as 32-bit CPUs offer -- to be exploited. In "The Fastest Sorting Algorithm?" (<i>DDJ</i>, February 2000), Stefan Nilsson presents an algorithm that uses bitwise operations to perform a merge sort. In this article, I'll present my technique for exploiting the parallelism of bitwise operations to speed up some other kinds of computing tasks. </p><h3>Bit Reversal in<i> log N</i> Time</h3><p>To illustrate, how about reversing the order of bits in a value? The obvious approach has execution times that are linear in the number of bits; that is, one iteration of a loop per bit. In contrast, the technique I describe here needs only <i>log</i>2(<i>N</i>) iterations for <i>N </i>bits. That means four iterations for 16 bits, five iterations for 32 bits, and six iterations for 64 bits. So, as the word size of the CPU becomes larger, the technique becomes more compelling. </p><DDJADVERTISEMENT INLINE><p>Why would you reverse the order of bits in a 32-bit or 64-bit value? Bit reversal can be useful in a variety of contexts. It's useful in image processing for flipping a black-and-white image to create a mirror image. To flip an image horizontally, the pixels in a row of the image must be placed in reverse order. Fast 64-bit bit reversal can be used in the process of reversing a row of black-and-white pixels. Similarly, 64-bit bit reversal is useful for rotating a black and white image 180 degrees. </p><p>Because Java guarantees that a long integer is 64 bits long, all code examples I present here are static Java methods. The code for C functions would be similar, but if you want to take advantage of 64-bit CPU operations in C, your code would not be portable to all C platforms since not all support 64-bit values. The Java methods will work even when the underlying hardware does not provide 64-bit operations.</p><h3>Implementations of Bit Reversal</h3><p>The reverse method in <A NAME="rl1"><A HREF="#l1">Listing One</A> reverses the order of bits in a 64-bit value. This simple method reverses one bit per loop iteration. (C programmers: The &gt;&gt;&gt; operator is just a right shift without sign extension; bits vacated on the left are filled with zeros. This is a workaround for the absence of an unsigned integer in Java.)</p><p><A NAME="rl2"><A HREF="#l2">Listing Two</A> is another implementation of reverse that uses a divide-and-conquer approach. It uses a recursive method, <i>reversen(V,n)</i>, presented as pseudocode in <A NAME="re1"><A HREF="0009ne1.htm">Example 1</A>. The method breaks <i>n</i> bits of <i>V</i> into an upper and lower part, reverses each part, then puts the two parts back together in reverse order. </p><p>As with all the recursive calls, this algorithm is very slow. What's important is the way it subdivides the problem. For 64 bits, seven levels of recursion are needed. At the top level, <i>n</i>=64. Below that are levels where <i>n</i>=32, 16, 8, 4, 2, and 1. A few bitwise operations can perform all of the reversals of a single level in parallel. For example, the following Java code performs all of the reversals for <i>n</i>=8:</p><blockquote><p>bits = ((bits&amp;0x0f0f0f0f0f0f0f0fL) &lt;&lt; 4) | </p><p>        ((bits&amp;0xf0f0f0f0f0f0f0f0L) &gt;&gt;&gt; 4);</p></blockquote><p>At this level, 4-bit groups exchange places with adjacent 4-bit groups; some groups are shifted left, some are shifted right. All that's needed to perform the entire reversal are six statements like the one above -- one statement for each level of recursion, except the bottom level, which only serves to terminate the recursion. <A NAME="rl3"><A HREF="#l3">Listing Three</A> shows the bit parallel version of the reverse method. In effect, the recursion has been unrolled into six inline statements. The result is very fast, about 10 times faster than the linear method of <A NAME="rl1"><A HREF="#l1">Listing One</A>.</p><p>To be fair, a table could be used to speed up the linear approach by reversing many bits at a time with a single table lookup. But there are complications. For one, a table must be initialized. <A NAME="rl4"><A HREF="#l4">Listing Four</A> shows an implementation that uses a table lookup to reverse 8 bits at a time. This time, the reverse method is not a static method. It must be called using an object of the <i>BitTable</i> class like this:</p><blockquote><p>BitTable table = new BitTable();</p><p>long result = table.reverse(bits);</p></blockquote><p>Forcing the use of the constructor ensures that the table is initialized.</p><p>The extra effort does not provide any speed up compared to the bit parallel approach. In fact, I timed the bit parallel approach at 30 to 50 percent faster for 64 bits. </p><p>If 128-bit processors ever come into being, then the table approach will take twice as long as for 64 bits. In contrast, the bit parallel approach will require one more line of code and take 7/6 times as long as for 64 bits; it would leave the table approach in the dust. The table approach could counter by doing 16 bits at a time, but at the cost of a much larger table. This shows how a <i>log N</i> approach eventually prevails over a linear approach.</p><h3>Bit Counters</h3><p>In a previous job, I found a need to count the number of an integer's bits set to 1. I was writing code to manage cache slots for data representing the road network for automobile navigation. A 32-bit integer served as a bitmap for the cache slots. Each slot could be allocated to a disk block. Each cached disk block could participate in one or more regions of the road network which I called "neighborhoods." A neighborhood in the cache was represented by a 32-bit bitmap. When new cache slots were needed for a new neighborhood, I wanted to choose them in such a way as to keep the most recently used neighborhoods in the cache. I used a sequence of bitwise operations on 32-bit bitmaps to produce bitmaps each representing a possible solution, that is, which slots to free up and which to leave alone. I needed to count bits in these bitmaps to determine whether enough cache slots would be freed for the new neighborhood.</p><p>Bitmaps are a common technique and, no doubt, the utility of counting the bits in them arises in contexts more easily described than my neighborhood caching. Some relational databases use bitmaps to index data that satisfy given conditions. Bit counting could be used to respond to SQL queries that ask for a count of records satisfying the conditions.</p><p>The count method in <A NAME="rl1"><A HREF="#l1">Listing One</A> shows the linear method for counting bits. It's short, but not fast. </p><p>At first, it seems that a bit parallel approach cannot be applied here. However, the recursive approach can be easily modified to count bits; see <A NAME="re2"><A HREF="0009ne2.htm">Example 2</A>. But how can bitwise operations total the bit counts in parallel? </p><p>The solution hinges on the order in which the six levels are handled. The six statements in the bitwise reverse method can be performed in an order reversed from that shown in <A NAME="rl3"><A HREF="#l3">Listing Three</A>. In fact, they can be performed in any order and still yield the same results. The bit counting function, in contrast, cannot be performed in the order from the top level to the bottom level, but it can be performed in the reverse order, bottom to top. <A NAME="rl3"><A HREF="#l3">Listing Three</A> shows how. Before the first statement of count in <A NAME="rl3"><A HREF="#l3">Listing Three</A> executes, each bit is its own count. If a bit is 1, there is 1 bit set at that bit position. If it's 0, there are 0 bits set. The first statement aggregates the counts for individual bits into counts for pairs of bits. The second statement aggregates the counts for pairs of bits into counts for 4-bit groups. This continues until the last statement, which adds the count for the upper 32 bits with the count for the lower 32 bits to yield the grand total.</p><p>The parallel addition works because, at each stage, a count of bits cannot overflow into the next count. The count for 2 bits, for example, is at most 2 and never overflows into a 3rd bit. </p><h3>Morton Keys</h3><p>The <i>mortonKey</i> method in <A NAME="rl3"><A HREF="#l3">Listing Three</A> computes Morton keys. (For more information on Morton keys, see my article "Space-Filling Curves in Geospatial Applications," <i>DDJ</i>, July 1999, where I explain how they can be used in spatial indexing. ) </p><p>Morton keys are computed from the coordinates of a point. If the point lies in a two-dimensional<i> xy</i> plane, the Morton key is computed by interleaving the bits of the <i>x</i>- and <i>y-</i>coordinates. The <i>mortonKey</i> and <i>spreadBits</i> methods in <A NAME="rl3"><A HREF="#l3">Listing Three</A> show how to use a bit parallel approach to compute a Morton key from two 32-bit values, <i>x</i> and <i>y</i>. The actual interleaving is performed by <i>mortonKey</i> with just a bitwise OR operation. The hard work is performed by <i>spreadBits,</i> which takes a 32-bit value and spreads its bits out into the even numbered bits of a 64-bit value. After doing this to <i>x </i>and <i>y, </i>it only takes a shift and a bitwise OR to interleave them.</p><p><A NAME="rf1"><A HREF="0009nf1.htm">Figure 1</A> shows the masks used to spread 16 bits farther apart with each iteration of the algorithm until they occupy the even-numbered bits of a 64-bit value.</p><h3>Conclusion</h3><p>I've described a technique that uses the parallelism of bitwise operations to turn some computing tasks requiring linear time into computing tasks requiring only <i>log N</i> time. If you discover new ways to apply this bit parallel technique, it would be fun to hear about them, so drop me an e-mail.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>public class BitLinear  {   public static long reverse (long bits) {        long rl = 0;        for (int i = 0; i &lt; 64; i++) {           rl = (rl &lt;&lt; 1) + (bits &amp; 1);           bits = bits &gt;&gt;&gt; 1;        }         return rl;    }      public static int count (long bits) {        int cnt = 0;        while (bits != 0) {            cnt += bits &amp; 1;            bits = bits &gt;&gt;&gt; 1;        }         return cnt;   } } </pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>public class BitRecursive{   // reverse leftmost n bits of V   static long reversen (long V, int n) {        if (n &lt;= 1)            return V;        int n2 = n/2;        // reverse rightmost n/2 bits        long right = reversen( V &amp; ((1L&lt;&lt;n2)-1), n2);         // reverse lefttmost n/2 bits        long left =  reversen( V &gt;&gt;&gt; n2, n2);         // combine in reverse order        return (right &lt;&lt; n2) | left;                     }    public static long reverse (long bits) {        return reversen (bits, 64);   } } </pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>public class BitLogN {   public static long reverse (long bits) {       // &gt;&gt;&gt; fills bits on the left with 0 (no sign extension)       bits = ((bits&amp;0x00000000ffffffffL) &lt;&lt;  32) |               ((bits&amp;0xffffffff00000000L) &gt;&gt;&gt; 32);       bits = ((bits&amp;0x0000ffff0000ffffL) &lt;&lt;  16) |              ((bits&amp;0xffff0000ffff0000L) &gt;&gt;&gt; 16);       bits = ((bits&amp;0x00ff00ff00ff00ffL) &lt;&lt;   8) |              ((bits&amp;0xff00ff00ff00ff00L) &gt;&gt;&gt;  8);       bits = ((bits&amp;0x0f0f0f0f0f0f0f0fL) &lt;&lt;   4) |               ((bits&amp;0xf0f0f0f0f0f0f0f0L) &gt;&gt;&gt;  4);       bits = ((bits&amp;0x3333333333333333L) &lt;&lt;   2) |              ((bits&amp;0xccccccccccccccccL) &gt;&gt;&gt;  2);       bits = ((bits&amp;0x5555555555555555L) &lt;&lt;   1) |              ((bits&amp;0xaaaaaaaaaaaaaaaaL) &gt;&gt;&gt;  1);       return bits;    }    public static int count (long bits) {       bits = (bits&amp;0x5555555555555555L) +             ((bits&amp;0xaaaaaaaaaaaaaaaaL) &gt;&gt;&gt;  1);       bits = (bits&amp;0x3333333333333333L) +             ((bits&amp;0xccccccccccccccccL) &gt;&gt;&gt;  2);       bits = (bits&amp;0x0f0f0f0f0f0f0f0fL) +             ((bits&amp;0xf0f0f0f0f0f0f0f0L) &gt;&gt;&gt;  4);       bits = (bits&amp;0x00ff00ff00ff00ffL) +             ((bits&amp;0xff00ff00ff00ff00L) &gt;&gt;&gt;  8);       bits = (bits&amp;0x0000ffff0000ffffL) +             ((bits&amp;0xffff0000ffff0000L) &gt;&gt;&gt; 16);       bits = (bits&amp;0x00000000ffffffffL) +             ((bits&amp;0xffffffff00000000L) &gt;&gt;&gt; 32);       return (int) bits;   }    public static long mortonKey (int x, int y) {       /* In C++, the calls to spreadBits could be made in-line    */       /* to avoid function call overhead.                         */       /* In C, make the function a macro (admittedly an ugly one) */       return (spreadBits(x) &lt;&lt; 1) | spreadBits(y);   }    // For j = 1 to 31, shift bit j j positions to the left    static long spreadBits (int i) {       long bits = i;       // shift bits 16 to 31 16 bits       bits = (bits &amp; 0x000000000000ffffL) |             ((bits &amp; 0x00000000ffff0000L) &lt;&lt; 16);       // shift originally odd-numbered bytes 8 bits       bits = (bits &amp; 0x000000ff000000ffL) |             ((bits &amp; 0x0000ff000000ff00L) &lt;&lt;  8);       // shift originally odd-numbered nibbles 4 bits       bits = (bits &amp; 0x000f000f000f000fL) |             ((bits &amp; 0x00f000f000f000f0L) &lt;&lt;  4);       // shift originally odd-numbered bit pairs 2 bits       bits = (bits &amp; 0x0303030303030303L) |             ((bits &amp; 0x0c0c0c0c0c0c0c0cL) &lt;&lt;  2);       // shift originally odd-numbered bit pairs 1 bits       bits = (bits &amp; 0x1111111111111111L) |             ((bits &amp; 0x2222222222222222L) &lt;&lt;  1);       return bits;   } } </pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>public class BitTable {   short[] table = new short[256];   public BitTable() {       BitLinear lin = new BitLinear();       for (int i = 0; i &lt; 256; i++) {           table[i] = (short) (lin.reverse(i) &gt;&gt;&gt; 56);      }    }       public long reverse (long bits) {       long rl = 0;       rl =             table[(int)(bits &amp; 255)]; bits = bits &gt;&gt;&gt; 8;       rl = (rl &lt;&lt; 8) | table[(int)(bits &amp; 255)]; bits = bits &gt;&gt;&gt; 8;       rl = (rl &lt;&lt; 8) | table[(int)(bits &amp; 255)]; bits = bits &gt;&gt;&gt; 8;       rl = (rl &lt;&lt; 8) | table[(int)(bits &amp; 255)]; bits = bits &gt;&gt;&gt; 8;       rl = (rl &lt;&lt; 8) | table[(int)(bits &amp; 255)]; bits = bits &gt;&gt;&gt; 8;       rl = (rl &lt;&lt; 8) | table[(int)(bits &amp; 255)]; bits = bits &gt;&gt;&gt; 8;       rl = (rl &lt;&lt; 8) | table[(int)(bits &amp; 255)]; bits = bits &gt;&gt;&gt; 8;       rl = (rl &lt;&lt; 8) | table[(int)(bits &amp; 255)];                  return rl;    }  } </pre><P><A HREF="#rl4">Back to Article</A></P></body></html>