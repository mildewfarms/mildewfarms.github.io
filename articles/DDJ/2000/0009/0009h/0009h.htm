<html><head><title>Sep00: Microcontrollers & CORDIC Methods</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Microcontrollers &amp; CORDIC Methods</h1><p><i>Dr. Dobb's Journal</i> September 2000</p><h2>Elementary functions for embedded systems</h2><h3>By Michael Pashea</h3><I>Michael is a senior electrical engineer at Basler Electric and part-time lecturer in the Department of Electrical and Computer Engineering at Southern Illinois University at Edwardsville. He can be contacted at mikepashea@basler.com or mpashea@ ee.siue.edu.</I><hr><p>Many times in designing software for microcontroller-based systems, you need to make calculations that involve elementary functions such as <i>sin(x)</i>, <i>cos(x)</i>, or <i>log</i><sub>10</sub>(<i>x</i>). For example, many temperature sensors are logarithmic in nature; that is, the sensor output voltage may increase by <i>x</i> volts each time the temperature doubles. In this case converting the sensor voltage to a linear temperature scale requires the calculation of 2<sup><i>x</i></sup>.</p><p>Calculation of an elementary function is often times done by using a look-up table. While look-up tables are by far the fastest way to make the computation, the precision of the result is directly related to the size of the look-up table. High-precision look-up tables require large amounts of nonvolatile memory to store the table. If the table size is reduced to save memory, precision is also reduced.</p><DDJADVERTISEMENT INLINE><p>Power series may also be used to calculate these same functions without using look-up tables, however, these calculations have the disadvantage of being slow to converge to a desired precision. In effect, the look-up table size is being traded at the expense of computation time. </p><p>CORDIC methods of computation represent a compromise between these two methods. The CORDIC technique uses a one-bit-at-a-time approach to make computations to an arbitrary precision. In the process, relatively small look-up tables are used for constants necessary for the algorithm. Typically, these tables require only one to two entries per bit of precision. CORDIC algorithms also use only right shifts and additions, minimizing the computation time.</p><h3>Fundamentals of CORDIC Algorithms</h3><p>All CORDIC algorithms are based on the fact that any number may be represented by an appropriate alternating series. For example, an approximate value for <i>e</i> can be represented as: <i>e»</i>3-0.3+0.02-0.002+ 0.0003=2.7183. In this case, each digit gives an additional power of 10 resolution to the approximation of the value for <i>e</i>. Also, if the series is truncated to a certain number of terms, the resulting value will be the same as the value obtained by rounding the true value of <i>e</i> to that number of digits. In general, the series obtained for a value by this method does not always alternate regularly. The series for p, for example, is <i>p»</i>3+0.1+0.04+0.002- 0.0004-0.00001=3.14159. The series for <i>e</i> is also irregular if the expansion is continued for a few additional terms.</p><p>The CORDIC technique uses a similar method of computation. A value to be computed, such as <i>sin(x) </i>or <i>log</i><sub>10</sub>(<i>x</i>), is considered to be a truncated series in the format in <A NAME="rf1"><A HREF="0009hf1.htm">Figure 1</A>. In this case, the values for <i>a<sub>i</i></sub> are either 0 or 1 and represent bits in the binary representation of <i>z</i>. The value for <i>z</i> is determined 1 bit at a time by looking at the previously calculated value for <i>z</i>, which is correct to <i>i</i>-1 bits. If this estimate of <i>z</i> is too low, you correct the current estimate by adding a correction factor, obtained from a look-up table, to the current value of <i>z</i>. If the current estimate of <i>z</i> is too high, you subtract a correction factor, also from the look-up table. Depending on whether you add or subtract from the current value of <i>z</i>, the <i>i</i><sup>th</sup> bit is set to the correct value of 0 or 1. The less significant bits from <i>i</i>+1 to <i>B</i> may change during this process because the estimate for <i>z</i> is only accurate to <i>i</i> bits.</p><p>Because of the trigonometric relationship between the <i>sin(x) </i>and <i>cos(x) </i>functions, it is often possible to calculate both of these values simultaneously. If the <i>cos(x) </i>is considered as a projection onto the <i>x</i>-axis and <i>sin(x) </i>as a projection onto the <i>y</i>-axis, the iteration process amounts to the rotation of an initial vector. It is from this vector rotation that the CORDIC algorithm derives its name -- COordinate Rotation DIgital Computer.</p><h3>Algorithms for  Multiplication and Division</h3><p>A CORDIC algorithm for multiplication can be derived using a series representation for <i>x</i>, as in <A NAME="rf2"><A HREF="0009hf2.htm">Figure 2</A>. From this, <i>z</i> is composed of shifted versions of <i>y</i>. The unknown value for <i>z</i>, may be found by driving <i>x</i> to zero 1 bit at a time. If the <i>i</i><sup>th</sup> bit of <i>x</i> is nonzero, <i>y<sub>i</i></sub> is right shifted by <i>i</i> bits and added to the current value of <i>z</i>. The <i>i</i><sup>th</sup> bit is then removed from <i>x</i> by subtracting 2<sup>-<i>i</i></sup> from <i>x</i>. If <i>x</i> is negative, the <i>i</i><sup>th</sup> bit in the twos complement format would be removed by adding 2<sup>-<i>i</i></sup>. In either case, when <i>x</i> has been driven to zero all bits have been examined and <i>z</i> contains the signed product of <i>x</i> and <i>y</i> correct to <i>B</i> bits. </p><p>This algorithm is similar to the standard shift and add multiplication algorithm except for two important features. </p><ul>  <li>Arithmetic right shifts are used instead of left shifts, allowing signed numbers to be used.   <li>Computing the product to <i>B</i> bits with the CORDIC algorithm is equivalent to rounding the result of the standard algorithm to the most significant <i>B</i> bits. </ul><p><A NAME="rl1"><A HREF="#l1">Listing One</A> is the final multiplication algorithm. This calculation assumes that both <i>x</i> and <i>y</i> are fractional within the domain-1 to 1. The algorithm is valid for other domains as long as the decimal point is allowed to float. With a few extensions, this algorithm would work well with floating-point data. </p><p>A CORDIC division algorithm is based on rewriting the equation <i>z=x/y</i> into the form <i>x-y*z=</i>0. If <i>z</i> is expanded into its series representation, the second version of the equation takes the form in <A NAME="rf3"><A HREF="0009hf3.htm">Figure 3</A>(a), which, after some manipulation, yields <A NAME="rf3"><A HREF="0009hf3.htm">Figure 3</A>(b). This final form of the equation shows that the quotient <i>z</i> may be estimated 1 bit at a time by driving <i>x</i> to zero using right-shifted versions of <i>y</i>. If the current residual is positive, the <i>i</i><sup>th</sup> bit in <i>z</i> is set. Likewise, if the residual is negative the <i>i</i><sup>th</sup> bit in <i>z</i> is cleared; see <A NAME="rl2"><A HREF="#l2">Listing Two</A>.</p><p>The convergence of this division algorithm is trickier than the multiplication algorithm. While <i>x</i> may be either positive or negative, the value for <i>y</i> is assumed to be positive. As a result, the division algorithm is only valid in two quadrants. Also, if the initial value for <i>y</i> is less than the initial value for <i>x</i> it will be impossible to drive the residual to zero. This means that the initial <i>y</i> value must always be greater than <i>x</i>, resulting in a range of 0<i>&lt;z&lt;</i>1. The algorithm may be modified as in <A NAME="rl3"><A HREF="#l3">Listing Three</A> for four quadrant division with <i>-</i>1<i>&lt;z&lt;</i>1.</p><p>As with all division algorithms, the case where <i>y</i> is zero should be trapped as an exception. Once again, a few extensions would allow this algorithm to work well with floating-point data.</p><h3>Algorithms for <i>Log</i><sub>10</sub><i>(x)</i> and 10<sup><i>x</i></sup></h3><p>To calculate the base 10 logarithm of a value <i>x</i>, it is convenient to use the identity in <A NAME="rf4"><A HREF="0009hf4.htm">Figure 4</A>(a). If the <i>b<sub>i</i></sub> are chosen such that <i>x*b</i>1<i>*b</i>2<i>*b</i>3<i>...*bB=</i>1, the left side reduces to <i>log</i><sub>10</sub>(1), which is 0. With these choices for <i>bi</i>, you are left with the equation in <A NAME="rf4"><A HREF="0009hf4.htm">Figure 4</A>(b) for <i>log</i><sub>10</sub><i>(x)</i>. Since quantities for <i>log</i><sub>10</sub><i>(b<sub>i</sub>)</i> may be stored in a look-up table, the base 10 logarithm of <i>x</i> may be calculated by summing selected entries from the table.</p><p>The trick now is to choose the correct <i>b<sub>i</i></sub> such that you drive the product of <i>x</i> and all of the <i>b<sub>i</i></sub> to 1. This may be accomplished by examining the current product. If the current product is less than 1, you choose coefficient <i>b<sub>i</i></sub> such that <i>b<sub>i</i></sub> is greater than 1. On the other hand, if the current product is greater than 1 the coefficient should be chosen such that its value is less than 1. An additional constraint is that the <i>b<sub>i</i></sub> should be chosen such that multiplication by any of the <i>b<sub>i</i></sub> is accomplished by a shift and add operation. Two coefficients that have the desired properties are: <i>b<sub>i</sub>=</i>1+2<sup><i>-i</sup> </i>if<i> x*b</i><sub>1</sub><i>*b</i><sub>2</sub><i>...b<sub>i-</i>1</sub> <i>&lt;1 </i>and <i>b<sub>i</sub>=</i>1-2<sup><i>-i</sup> </i>if<i> x*b</i><sub>1</sub><i>*b</i><sub>2</sub><i>...bi<sub>-</i>1</sub><i>&gt;1</i>. In choosing these values for the <i>b<sub>i</i></sub>, the limit, as <i>i</i> approaches infinity of the product of <i>x</i> and the <i>b<sub>i</sub>s,</i> will be 1 as long as <i>x</i> is in the domain (see <A NAME="rf4"><A HREF="0009hf4.htm">Figure 4</A>(c)). This represents the domain of convergence for this algorithm, which may be calculated as approximately 0.4194<i>&lt;x&lt;</i>3.4627. If you want to calculate logarithms outside of this domain, either the input must be prescaled or the range of the <i>i</i> values must be changed. The final algorithm becomes <A NAME="rl4"><A HREF="#l4">Listing Four</A>. </p><p>To calculate the inverse of this algorithm, or 10<sup><i>x</i></sup>, you only modify the existing algorithm such that <i>x</i> is driven to zero while <i>z</i> is multiplied by the successive coefficients, <i>b<sub>i</i></sub>. This follows from the fact that if <i>z=</i>10<sup><i>x</i></sup> then <i>z=b<sub>i</sub>*</i>10<sup><i>(x- log</i><sub>10</sup><i>(b</sub>i<sup>))</i></sup>. As the exponent is driven to zero, <i>z</i> is seen to approach the product of all the successive coefficients.</p><blockquote><p><i> B</i></p><p> '<i>b<sub>i</i></sub></p><p><i>i</i>=1</p></blockquote><p><A NAME="rl5"><A HREF="#l5">Listing Five</A> is the final algorithm. The domain of convergence for this algorithm is determined by the possible values for which <i>x</i> can be driven to zero. By inspection of the algorithm this is determined to be <A NAME="rf4"><A HREF="0009hf4.htm">Figure 4</A>(d) or <i>x</i> is limited to the domain <i>-</i>0.5393<i>&lt; x&lt;0.3772. </i>As in the previous algorithm, the domain may be extended by scaling the initial value of <i>z</i> by (1+2<sup><i>i</i></sup>) or (1-2<sup><i>i</i></sup>).</p><h3>The Circular  Functions <i>sin(x) </i>and <i>cos(x)</i></h3><p>The rotation matrix in <A NAME="rf5"><A HREF="0009hf5.htm">Figure 5</A>(a) rotates a vector </p><blockquote><p><i>  x</i><sub>0</sub></p><p>[<i> y</i><sub>0</sub><i> </i>]</p></blockquote><p>counterclockwise by a radians in two-dimensional space. If this rotation matrix is applied to the initial vector </p><blockquote><p><i>  </i>1</p><p>[<i> </i>0<i> </i>]</p></blockquote><p>the result will be a vector with coordinates of</p><blockquote><p><i>  cos a</i></p><p>[<i> sin a </i>]</p></blockquote><p>It is easily seen that the CORDIC method could be applied to calculate the functions <i>sin</i>(<i>x</i>) and <i>cos</i>(<i>x</i>) by applying successive rotations to the initial vector </p><blockquote><p><i>  </i>1</p><p>[<i> </i>0<i> </i>]</p></blockquote><p>and gradually driving the angle <i>a</i> to zero.</p><p>However, a problem arises when an attempt is made to set up the rotation matrix such that all rotations are accomplished by right shifts. If <i>a<sub>i</i></sub> is chosen such that <i>cos(a<sub>i</sub>)=2<sup>-i</i></sup>, the <i>sin(a<sub>i</sub>)</i> is not necessarily a power of 2. It is not possible to choose the successive angle rotations, <i>a<sub>i</i></sub>, such that both the <i>cos(a<sub>i</sub>)</i> and <i>sin(a<sub>i</sub>)</i> amount to right shifts.</p><p>In working around this problem, you can modify the rotation matrix by bringing a <i>cos(a)</i> term out of the matrix; see <A NAME="rf5"><A HREF="0009hf5.htm">Figure 5</A>(b). Now the rotation angles <i>a<sub>i</i></sub> may be chosen such that <i>tan(a<sub>i</sub>)=</i>2<sup><i>-i</i></sup> or rather <i>a<sub>i</sub>=tan<sup>-1</sup>(</i>2<sup><i>-i</sup>)</i>. The result is the final incremental rotation matrix in <A NAME="rf5"><A HREF="0009hf5.htm">Figure 5</A>(c), where <i>a<sub>i</sub>=tan<sup>-1</sup>(</i>2<sup><i>-i</sup>)</i>. With these choices for the <i>a<sub>i</i></sub>, rotation is accomplished using only right shifts. If the <i>cos(a<sub>i</sub>)</i> term is neglected to avoid the multiplication operations, the length of the initial vector is increased each time it is rotated by using right shifts only. This increase may be compensated for by decreasing the length of the vector prior to rotation. Because the algorithm uses <i>B</i> successive rotations, all rotations may be compensated for initially using one collective length correction factor, <i>C</i>. The value of <i>C</i> is found by grouping all of the <i>a<sub>i</i></sub> terms together as in <A NAME="rf5"><A HREF="0009hf5.htm">Figure 5</A>(d).</p><p>For <i>B</i>=16 bits, <i>C</i> may be calculated as approximately 0.6072. <A NAME="rl6"><A HREF="#l6">Listing Six</A> presents the final algorithms, <i>x</i> and <i>y</i> represent vector coordinates, while <i>z</i> is now the angle register. It can be determined that the previous two algorithms will converge as long as <A NAME="rf5"><A HREF="0009hf5.htm">Figure 5</A>(e) or <i>-</i>1.7433<i>&lt;z&lt;</i>1.7433. </p><p>Since the domain of convergence includes both the first and fourth quadrants, the algorithms will converge for any <i>z</i> such that <i>-p/</i>2<i>&lt;z&lt;p/</i>2.</p><h3>Mapping CORDIC Algorithms  to Microcontrollers </h3><p>The previously discussed algorithms show that CORDIC-based computation methods require minimal hardware features to implement:</p><p></p><ul>  <li>Three registers of length <i>B</i> bits.  <li>One, two, or three Adders/Subtractors.  <li>Several small ROM-based look-up tables.  <li>One, two, or three shift registers.</ul><p>When implementing CORDIC algorithms on microcontrollers, the shift registers will have the greatest effect on the overall throughput of the system. Multiplication by 2<sup>-<i>i</i></sup> requires that the shift register be capable of performing a right shift by <i>i</i> bits. Most microcontrollers are only capable of right shifting by 1 bit at a time. Shifting by <i>i</i> bits requires a software loop to repeat this task <i>i</i> times, greatly increasing the computation time. The 8051, 6805, and 68HC11 are typical examples of microcontrollers that require software loops to implement the shifter.</p><p>Other microcontrollers, such as the 68HC332, as well as most DSPs, have a feature known as "barrel shifters," which right shifts by <i>i</i> bits in one operation. Typically the shift is also accomplished in one clock cycle.</p><p>Another possibility for implementing a barrel shifter is to use a multiply instruction that has been optimized for speed. An example of this is the 68HC12, which has a 16&times;16 bit signed multiply, and EMULS that produces a 32-bit result in three clock cycles. A right shift by <i>i</i> bits could be accomplished by multiplying by 2<sup>16<i>-i</i></sup> and discarding the lower 16 bits of the result. One disadvantage of this scheme is that the data is restricted to 16 bits. Other word lengths would require additional cycles. </p><p>Once the processor and shift register style is chosen, the next choice to be made involves the data format. Since Standard C does not provide a fixed-point data type, you have a lot of freedom in choosing the format of the data. It is a good idea, however, to choose a format that fits into 16- or 32-bit words. Even though most CORDIC routines are written in assembly language for speed, 16- or 32-bit words allow data to be passed as either <i>int</i> or <i>long int</i> data types within higher level C subroutines. The format presented here uses a 16-bit format with 4 bits to the left of the decimal point and 12 fractional bits to the right, which is often referred to as "4.12 format." This allows constants such as <i>p</i>, <i>e</i>, and Ö2 to be easily represented without a moving decimal point. The 12 bits of fractional data amount to approximately 3.5 digits of decimal accuracy. The range of this format is calculated as <i>-</i>8<i>&lt; x&lt;</i>7.9997<i>.</i></p><p>The constants used are found by multiplying by 2<sup>12</sup> (4096), rounding, and converting to hexadecimal. Take the constant <i>e</i>, for example: 4096<i>*e=</i>11134.08»11134<i>= </i>0<i>x</i>267<i>e</i>. All of the data tables necessary for CORDIC computing may be built up this way using a calculator.</p><p>Finally, with the data format and constant tables established, coding of the algorithms proceeds in a straightforward manner. Available electronically (see "Resource Center," page 5) are source-code implementations of CORDIC algorithms for the 8051, 68HCll, and 68332 microcontrollers. This code was assembled with the Intel MCS-51 Macro-Assembler and Motorola Freeware Assemblers and tested on hardware development systems.</p><h3>Conclusion</h3><p>CORDIC algorithms have been around for some time. For instance, Jack Volder described them in "The CORDIC Trigonometric Computing" (<i>IRE Transactions Electronic Computers, </i>September 1959). The reasons for using CORDIC algorithms have not changed. The algorithms are efficient in terms of both computation time and hardware resources. In most microcontroller systems, especially those performing control functions, these resources are normally already at a premium. Using CORDIC algorithms may allow a single chip solution where algorithms using the look-up table method may require a large ROM size or where power series calculations require a separate coprocessor because of the computation time required.</p><p>The algorithms presented have been selected to represent a small core of functions commonly required in microcontroller systems, which could be discussed in detail. For each algorithm in this core, three areas have been covered: theory of operation, determining the domain of convergence for the algorithm, and finally, implementation of the algorithm on a typical microcontroller. Using these selected algorithms as a starting point, you can develop libraries containing many similar elementary functions. Among those possible with only minor modifications to the algorithms presented are: <i>lnx</i>, <i>ex</i>, <i>tan<sup>-</i>1</sup><i>x</i>, <i>Öx</i><sup>2</sup><i>+y</i><sup>2</sup>,<i> </i>and <i>e<sup>jq</i></sup>. Among the references, Jarvis gives an excellent table of the functions possible using CORDIC routines.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>multiply(x,y){            for (i=1; i=&lt;B; i++){      if (x &gt; 0)         x = x - 2^(-i)         z = z + y*2^(-i)      else           x = x + 2^(-i)         z = z - y*2^(-i)   }   return(z)}</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>divide(x,y){   for (i=1; i=&lt;B; i++){      if (x &gt; 0)         x = x - y*2^(-i);         z = z + 2^(-i);      else           x = x + y*2^(-i);         z = z - 2^(-i);   }   return(z)}</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>divide_4q(x,y){   for (i=1; i=&lt;B; i++){      if (x &gt; 0)        if (y &gt; 0)           x = x - y*2^(-i);           z = z + 2^(-i);        else           x = x + y*2^(-i);           z = z - 2^(-i);      else                   if (y &gt; 0)            x = x + y*2^(-i);            z = z - 2^(-i);         else            x = x - y*2^(-i);            z = z + 2^(-i);   }   return(z)}</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>log10(x){   z = 0;   for ( i=1;i=&lt;B;i++ ){      if (x &gt; 1)         x = x - x*2^(-i);         z = z - log10(1-2^(-i));       else         x = x + x*2^(-i);         z = z - log10(1+2^(-i));   }   return(z)}</pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five</H4><pre>10_to_power(x){   z = 1;   for ( i=1;i=&lt;B; i++ ){      if (x &gt; 0)         x = x - log10(1+2^(-i));         z = z + z*2^(-i);      else         x = x - log10(1-2^(-i));         z = z - z*2^(-i);   }   return(z)}</pre><P><A HREF="#rl5">Back to Article</A></P><H4><A NAME="l6">Listing Six</H4><pre>sin(z){     x = 0.6072;   y = 0;          for (i=0; i=&lt;B; i++){      if (z &gt; 0)         x = x - y*2^(-i)         y = y + x*2^(-i)         z = z - arctan(2^(-i))      else           x = x + y*2^(-i)         y = y - x*2^(-i)         z = z + arctan(2^(-i))   }   return(y)}cos(z){     x = 0.6072;   y = 0;   for (i=0; i=&lt;B; i++){      if (z &gt; 0)         x = x - y*2^(-i)         y = y + x*2^(-i)         z = z - arctan(2^(-i))      else         x = x + y*2^(-i)         y = y - x*2^(-i)         z = z + arctan(2^(-i))   }   return(x)}</pre><P><A HREF="#rl6">Back to Article</A></P></body></html>