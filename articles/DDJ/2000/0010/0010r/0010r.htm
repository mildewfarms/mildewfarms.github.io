<html><head><title>Oct00: Algorithm Alley</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Alphanumeric Ordering</h1><p><i>Dr. Dobb's Journal</i> October 2000</p><h3>By David Wincelberg</h3><I>David is a programmer/analyst at the UCLA Center for Digital Innovation and runs FileJockey Software. He can be reached at http://www.FileJockeySoftware.com/ or FileJockey@compuserve.com.</I><hr><p>There are many occasions when character strings, such as filenames, might contain sequence numbers. For example, images in a web page may be numbered since it is not always worthwhile to assign meaningful names. When such strings are sorted, they look wrong if they increase, while the numbers in these strings sometimes decrease. For example, the sequence Img1, Img10, Img2, ..., Img9 would look right and be easier to read if it were arranged as Img1, Img2, Img3, ..., Img10.</p><p>A program to sort strings combines a sorting algorithm such as <i>QuickSort()</i> with an ordering function such as C's <i>stricmp()</i>. When <i>stricmp()</i> or a similar ordering function is selected, the result is called "alphabetic sorting" because the program compares one character at a time from each string using the computer's alphabet.</p><DDJADVERTISEMENT INLINE><p>In contrast, an alphanumeric-ordering function treats digits in strings as parts of numbers, and orders these numbers properly. Then numbers within strings increase when the strings increase. The benefits of ordering in this way include ease of reading sorted strings and it being easier for a person to find the string containing a specified number or the highest number. In this article, I'll present a simple alphanumeric-ordering function and describe another function suitable for comparing long filenames.</p><h3>Workarounds</h3><p>There are two ways of formatting numbers within strings so that increasing alphabetically ordered strings have increasing numbers -- add leading zeros or leading spaces. These methods consist of deciding upon a maximum number of digits and prepending numbers that have fewer digits with either zeros or spaces.</p><p>How do you decide how many digits to use? If you guess wrong, you either type unnecessary character(s) for each string, have to rename all previous strings once you use a number with more than the selected number of digits, or accept some strings not being positioned properly. In addition, these methods cannot be used with read-only strings, may reduce readability, and are a nuisance to apply manually.</p><h3>Simple Alphanumeric Ordering</h3><p><A NAME="rl1"></a><A HREF="#l1">Listings One</A> and <A NAME="rl1"></a><A HREF="#l2">Two</A> are source code for simple alphanumeric ordering. These files are written in C and include the instructions needed for C++ compilation. If you compile for an operating system other than Windows, you may need to remove the call to <i>_strnicoll()</i> (this function provides locale-based caseless comparisons). In many cases, you will not notice a difference in the sorting order between using this function and subtracting lowercase characters.</p><p>To recognize digits within strings, I use the <i>isdigit()</i> function. Although this function works in a static library, I found that it fails when included in a DLL. If you use <i>isdigit()</i> in a DLL, test it to see if it works properly. If not, substitute something like <i>'0' &lt;= c </i>&amp;&amp;<i> c &lt;= '9'</i>. Instead of being defined as specified, <i>isdigit()</i> is defined in &lt;ctype.h&gt; using a bit mask. As a result, it may be slightly faster than using the previous pair of tests.</p><p>The function <i>SimpleANCompare()</i> in <A NAME="rl2"></a><A HREF="#l2">Listing Two</A> loops through a pair of strings based on their respective character positions. If both strings have a digit at their current position, then this function uses <i>atoi()</i> to compare the numbers within these strings. By design, <i>atoi()</i> reads characters until it encounters a character that is not part of a number. In contrast, Java's <i>Integer.parseInt()</i> requires a substring that contains only digits (other than a minus sign for the first character).</p><p>If the numbers in both strings are equal, then <i>SimpleANCompare()</i> moves past the digits and returns to the top of the loop. If not, this function returns an integer that is useful to a sorting algorithm. By convention, this integer is negative if parameter one is less than parameter two, zero if they are equal, and positive if parameter one is greater than parameter two.</p><p>If at least one string does not have a digit at its current position, then the current characters are compared alphabetically using either <i>_strnicoll()</i> or subtracting the lowercase equivalents of these characters. You can turn locale sorting on or off by calling <i>SetSNSLocaleSort()</i> with an integer that is nonzero or zero, respectively.</p><p><i>SimpleANCompare()</i> works when the first digits of whole numbers to be compared start at the current position in each string and these numbers are less than 2<sup>31</sup> or 2,147,483,648 (so that <i>atoi()</i> provides valid results). Notice that since this function moves past equal numbers, it can handle strings that contain several numbers in which the first ones are equal. As a result, it can compare strings that contain multiple dots between numbers, such as IP addresses. <A NAME="rf1"></a><A HREF="0010rf1.htm">Figure 1</A> shows the results of simple alphanumeric sorting applied to selected filenames.</p><h3>Full Alphanumeric Ordering</h3><p>Win32 began allowing filenames with up to 255 characters starting with Windows 95. These filenames have several features that affect how to order them alphanumerically. To begin with, as a result of being long, such filenames may contain numbers greater than 2<sup>31</sup>-1. Comparing such numbers cannot be done with <i>atoi()</i>.</p><p>When you copy a file and paste it into its current folder, Windows will make a file whose name starts with "Copy of." If you copy it again, the new filename will begin with "Copy (2) of." Subsequent copies will have increasing numbers in their parentheses. Handling a set of such filenames requires allowing for numbers in parentheses and dealing with the missing number.</p><p>In addition to allowing more characters in filenames, Windows now allows multiple dots in filenames. With this change, filenames could contain fractional (or decimal) numbers. An example is "Item 3.879.txt." At first it seems that the logic mentioned earlier for multiple-dot numbers would work here too. However, the fractional part should be sorted alphabetically so that 3.879 is less than 3.9.</p><p><A NAME="rf2"></a><A HREF="0010rf2.htm">Figure 2</A> shows how simple alphanumeric sorting works on selected filenames, and <A NAME="rf3"></a><A HREF="0010rf3.htm">Figure 3</A> shows how full alphanumeric sorting arranges these filenames. Notice that the full version addresses all of the problems previously mentioned. (You can download the SortNice demo program from http://www .hotfiles.com/?0011FB.)</p><h3>Windows Programming Attempts</h3><p>While attempting to incorporate alphanumeric ordering into Windows components, I found that the <i>ListBox </i>control did not provide useful WM_COMPAREITEM messages. (This may have been fixed by now.) In contrast, the <i>ListCtl</i> component does allow for substituting a comparison function to replace alphabetic ordering. As a result, I use this control in my SortNice application.</p><p>Using the Spy++ tool that comes with Visual C++, I determined that the filename-list window of the standard File Open/Save dialog box also uses a <i>ListCtl</i> component. However, I have not found a way to replace the ordering function used by this dialog box with my function.</p><p>Pursuing this matter further may not be worthwhile since incorporating alphanumeric ordering into some File Open/Save dialog boxes but not others would present an inconsistent experience to users. On the other hand, programs that show a list of files within an archive or sort other alphanumeric text would benefit from using alphanumeric ordering.</p><h3>Conclusion</h3><p>In many situations, the simple alphanumeric-ordering function presented can properly arrange strings containing numbers. Such strings include sequentially numbered filenames and IP addresses. When this function is not adequate, the full version may be needed. As shown here, this version is suited for Windows long filenames. Due to its generality, it should also work for filenames allowed by other operating systems. To provide a consistent experience to users, full alphanumeric ordering should be incorporated at the operating-system level and provided as an API function.</p><p></p><p><b>DDJ</b></p> <a name="l1"></a><h4>Listing One </h4><pre>// SNSimpleLib.h -- Alphanumeric Ordering#ifndef SNSIMPLELIB_H#define SNSIMPLELIB_H#ifdef __cplusplusextern "C" {#endifint  SimpleANCompare (const char *pszName1, const char *pszName2);void SetSNSLocaleSort (int bLocaleSort);#ifdef __cplusplus}#endif#endif  // SNSIMPLELIB_H</pre><p><a href="#rl1">Back to Article</a></p><a name="l2"></a><h4>Listing Two </h4><pre>// SNSimpleLib.c -- Alphanumeric Ordering#include <ctype.h>      // for isdigit, tolower#include <stdlib.h>     // for atoi#include <string.h>     // for _strnicoll (Windows)#include "SNSimpleLib.h"static int g_bLocaleSort = 1;// Action:  Simple alphanumeric comparisons.// Notes:   Works when there is a digit in the same starting place in//    each filename. Limited to numbers smaller than 2^31, around 2 billion.int SimpleANCompare (const char *pszName1, const char *pszName2) {    register const char *pszN1 = pszName1, *pszN2 = pszName2;    int nTest;    while (*pszN1 != '\0' && *pszN2 != '\0') {        if (isdigit (*pszN1) && isdigit (*pszN2)) {            if ((nTest = atoi (pszN1) - atoi (pszN2)))                return nTest;            // Moves past the numbers            while (isdigit (*pszN1)) pszN1++;            while (isdigit (*pszN2)) pszN2++;        }        else {            if (g_bLocaleSort)    // locale caseless match                nTest = _strnicoll (pszN1, pszN2, 1);                       else                  // caseless match                nTest = tolower (*pszN1) - tolower (*pszN2);            if (nTest)                return nTest;            else {                pszN1++;  pszN2++;            }        }    }    return (*pszN1 - *pszN2);   // one string has ended}   // SimpleANCompare// Action:  Turns locale sorting on or off.// Note:    This functionality may need to be removed for non-Windows OSes.void SetSNSLocaleSort (int bLocaleSort) {    g_bLocaleSort = bLocaleSort;}</pre><p><a href="#rl2">Back to Article</a></p></body></html>