<html><head><title>Oct00: The C# Programming Language</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>The C# Programming Language</h1><p><i>Dr. Dobb's Journal</i> October 2000</p><h2>Combining the power of C++with the ease of VB</h2><h3>By Scott Wiltamuth</h3><I>Scott is a member of the C# design team at Microsoft. He can be contacted at scottwil@microsoft.com.</I><hr><p>While C++ developers enjoy full control over how their programs execute, this power comes at a price. What C++ developer hasn't spent hours tracking down a memory leak, or wasted time puzzling over the effects of a stray pointer? Visual Basic developers, on the other hand, have benefited from higher productivity due to automatic memory management, close fit with the platform, and the wide availability of ActiveX components. But what VB developer hasn't at some point wanted more low-level control, or found it difficult or impossible to call a COM interface because of a data type problem?</p><p>Given that C++ developers have power but want higher productivity, and VB developers have higher productivity but often seek more power, it is natural for both sets of developers to wish for a language that delivers the best of C++ and VB -- productivity by default and power on demand. This is the void that C# aims to fill. </p><DDJADVERTISEMENT INLINE><p>C# (pronounced "C sharp") is part of Microsoft Visual Studio 7.0. (For details about C#, including release dates, see http://msdn.microsoft.com/vstudio/nextgen.) In addition to C#, Visual Studio supports Visual Basic, Visual C++, and the scripting languages VBScript and JScript. All of these languages provide access to the Microsoft .NET platform, which includes a common execution engine and class library.</p><p>The Microsoft .NET platform defines a Common Language Subset (CLS), as a sort of lingua franca that ensures seamless interoperability between CLS-compliant languages and class libraries. This means that C# developers have complete access to the same class libraries as are available with tools such as Visual Basic and Visual C++. In this article, I'll examine the C# language by implementing a <i>Stack</i> class, whose fundamental operations are:</p><ul>  <li><i>Push(object)</i>, a method that pushes an object onto the top of the stack.  <li><i>Pop()</i>, a method that removes the top item from the stack and returns it.   <li><i>Count</i>, a property that returns the number of items in the stack.</ul><p>This example is straightforward enough that its details won't distract you from the language description, yet complex enough that it meaningfully demonstrates important aspects of the language.</p><h3>Step 1: Getting Started</h3><p>I'll start by declaring an empty <i>Stack</i> class (see <A NAME="rl1"><A HREF="#l1">Listing One</A>) and writing an associated test program. Close examination of this program is illuminating:</p><p></p><ul>  <li>The <i>using System;</i> directive references a namespace called <i>System</i> that is provided by the Microsoft .NET class library. This namespace contains the <i>Console</i> class referred to in the <i>Main</i> method. Namespaces provide a hierarchical means of organizing the elements of a class library. A <i>using</i> directive enables unqualified use of the types that are members of the namespace. The "Hello, world" program uses <i>Console.WriteLine</i> as a shorthand for <i>System.Console.WriteLine</i>.   <li>The <i>Main</i> method is a member of the class <i>Test</i>. It has the static modifier, and so it is a method on the class <i>Test</i> rather than on instances of this class. The main entry point for a program -- the method that is called to begin execution -- is always a static method named <i>Main</i>.  <li>No constructor for the <i>Stack</i> class is provided, but it is still possible to instantiate <i>Stack</i> instances using the <i>new</i> keyword. If no constructor is provided for a class, then a parameterless constructor is provided automatically.</ul><p>For C and C++ developers, it is interesting to note a few things that do not appear in the "Hello, world" program.</p><ul>  <li>The program does not use a global method for <i>Main</i>. Methods and variables are not supported at the global level; such elements are always contained within type declarations.  <li>The program does not use either "::" or "-&gt;" operators. In fact, "::" is not an operator at all, and "-&gt;" is used in only a small fraction of programs.  <li>The program does not contain forward declarations. Forward declarations are never needed, as declaration order is insignificant.  <li>The program does not use <i>#include</i> to import program text. Dependencies among programs are handled symbolically rather than textually. This system eliminates barriers between programs written in different languages.</ul><h3>Step 2: Storing Elements</h3><p>A field is a member that represents a variable associated with an object or class. I'll use two fields to store the elements of the stack: an array that holds the elements and a size that holds the number of items in the stack. When a <i>Stack</i> instance is created, these variables are initialized. <A NAME="re1"><A HREF="0010ae1.htm">Example 1</A> shows one way of doing this. The <i>size</i> field is initialized to 0, since a <i>Stack</i> is initially empty. The <i>values</i> field is initialized to an array of type <i>object[]</i> that has 10 elements. Each element of this array is automatically initialized to null.</p><p>The use of an array of objects to store the elements of the stack raises an important issue: What sorts of items can be pushed onto the stack? To answer this question, you need to examine the two kinds of types that C# supports -- value types and reference types. Value types include simple types (<i>char</i>, <i>int</i>, and <i>float</i>, for example), <i>enum</i> types, and <i>struct</i> types. Reference types include class types, interface types, delegate types, and array types.</p><p>Value types differ from reference types in that variables of the value types directly contain their data, whereas variables of the reference types store references to objects. With reference types, it is possible for two variables to reference the same object, and thus possible for operations on one variable to affect the object referenced by the other variable. With value types, the variables each have their own copy of the data, and it is not possible for operations on one to affect the other. In the stack example, I use a field of a value type (<i>int</i>) and a field of a reference type (<i>object[]</i>). </p><p>The keywords <i>int</i> and <i>object</i> are examples of predefined types. Some predefined types are reference types, and some are value types. The predefined reference types are <i>object</i> and <i>string</i>. The type <i>object</i> is the ultimate base type of all other types, and the type <i>string</i> is used to represent Unicode string values. The predefined value types include signed and unsigned integral types, floating-point types, and the types <i>bool</i>, <i>char</i>, and <i>decimal</i>. The signed integral types are <i>sbyte</i>, <i>short</i>, <i>int</i>, and <i>long</i>; the unsigned integral types are <i>byte</i>, <i>ushort</i>, <i>uint</i>, and <i>ulong</i>; and the floating-point types are <i>float</i> and <i>double</i>.</p><p>C# provides a "unified type system." All types -- including value types -- derive from the type <i>object</i>. <A NAME="re2"><A HREF="0010ae2.htm">Example 2</A> shows that an<i> int</i> value can be converted to <i>object</i> and back again to <i>int</i>. These conversions are called "boxing" and "unboxing," respectively. When a variable of a value type needs to be converted to a reference type, an object box is allocated to hold the value, and the value is copied into the box. Unboxing is just the opposite. When an object box is cast back to its original value type, the value is copied out of the box and into the appropriate storage location. Type system unification provides value types with the benefits of object-ness without introducing unnecessary overhead. For programs that don't need <i>int</i> values to act like objects, <i>int</i> values are simply 32-bit values. For programs that need <i>int</i> values to behave like objects, this capability is available on-demand. This ability to treat value types as objects bridges the gap between value types and reference types that exists in most languages. Type system unification is important for our stack example, as it enables <i>Stack</i> to store elements of any type, including value types like <i>int</i>.</p><h3>Step 3: <i>Push</i>, <i>Pop</i>, <i>Count</i>, and <i>ToString</i></h3><p>At this point, I'll add support for the fundamental stack operations -- the <i>Push</i> method, <i>Pop</i> method, and <i>Count</i> property. In addition, I'll add two overloaded <i>ToString</i> methods: one that takes no parameters and is an override of a method introduced in <i>object</i>, and a second that takes a string delimiter.</p><p>To push an item onto the stack, you place it in the <i>values</i> array and increment <i>size</i>. To pop an item off of the stack, you extract the value from the <i>values</i> array, decrement <i>size</i>, and return the value. Error cases -- either pushing onto a full stack or popping from an empty stack -- cause exceptions to be thrown. <A NAME="rl2"><A HREF="#l2">Listing Two</A> implements the new <i>Stack</i>. The test program in <A NAME="rl3"><A HREF="#l3">Listing Three</A> creates a stack, pushes the numbers 1 through 5 onto it, and then pops them off. </p><p><A NAME="re3"><A HREF="0010ae3.htm">Example 3</A> deserves further comment, because it shows some of the string formatting behavior of <i>Console.WriteLine</i>, which takes a variable number of arguments. The first argument is a string, which may contain numbered placeholders like <i>{0}</i> and <i>{1}</i>. Each placeholder refers to a trailing argument. The placeholder <i>{0}</i> refers to the second argument, the placeholder <i>{1}</i> refers to the third argument, and so on. Before the output is sent to the console, each placeholder is replaced with the string representation of its corresponding argument.</p><p>The output of this test program is:</p><blockquote><p>Stack s = 5,4,3,2,1</p><p>Popped 5</p><p>Popped 4</p><p>Popped 3</p><p>Popped 2</p><p>Popped 1</p><p>Stack s = </p></blockquote><p>Just looking at this small example, you can examine a number of important language features, including:</p><ul>  <li>Methods (<i>Push</i>, <i>Pop</i>, and <i>ToString</i>, for example), including overloaded methods (<i>ToString</i>).  <li>Properties (such as <i>Count</i>).   <li>Virtual and override members, and their impact on versioning.  <li>Member accessibility.</ul><h3>Methods</h3><p>A method is a member that implements a computation or action that can be performed by an object or class. Methods have a list of formal parameters (which may be empty), a return value (or void), and are either static or nonstatic. Static methods are accessed through the class. Nonstatic methods, which are also called "instance methods," are accessed through instances of the class. Instance methods are either virtual or nonvirtual, and nonvirtual is the default. In the example, the methods <i>Push</i> and <i>Pop</i> are both virtual, and so could be overridden by a derived class.</p><p>Methods can be overloaded, which means that multiple methods may have the same name as long as they have unique signatures. The signature of a method consists of the name of the method and the number, modifiers, and types of its formal parameters. The signature of a method specifically does not include the <i>return</i> type. </p><p>The <i>ToString</i> methods provided by <i>Stack</i> are good examples of both overloading and overriding. The <i>ToString</i> method that takes no arguments is an override of a method provided by <i>object</i>. Overriding methods must include the <i>override</i> keyword. This helps eliminate programming errors (for instance, mistyping the formal parameters and accidentally introducing a new member rather than overriding an existing one), but more importantly, it allows for better versioning behavior.</p><p>Versioning is the process of evolving a component over time in a compatible manner. A new version of a component is source compatible with a previous version if code that depends on the previous version can, when recompiled, work with the new version. In contrast, a new version of a component is binary compatible if a program that depends on the old version can, without recompilation, work with the new version. C# supports both forms of compatibility, and includes language features that facilitate versioning.</p><p>One common versioning problem that occurs in C++ and some other object-oriented languages is "accidental overriding," in which a derived class introduces a new method, and a subsequent version of its base class introduces a virtual method with the same signature. This causes the derived class to accidentally override the base method. This is almost always an error, but is not caught in most languages. In C#, such a situation causes a compile-time warning. This warning lets you clearly specify the intent -- whether the method should override the base method or hide it.</p><h3>Properties</h3><p>A property is in some ways a combination of fields and methods. A property provides access to an attribute of an object or a class. Properties are like fields in that they are named members with associated types, and the syntax for accessing fields and properties is the same. However, unlike fields, properties do not denote storage locations. Instead, properties have accessors that specify the statements to execute to read/write their values. In this way, properties are like methods.</p><p>Properties are defined with property declarations. The first part of a property declaration resembles a field declaration. The second part includes a <i>get</i> accessor and/or a <i>set</i> accessor. <i>Stack</i>'s <i>Count</i> property is simple: it returns the value of the private size field.</p><blockquote><p>public virtual int Count {</p><p> get { return size; }</p><p>}</p></blockquote><p>There are several important benefits of using a property rather than exposing <i>size</i> directly. First, using a property lets you limit access -- you want client code to be able to find out the number of elements in the stack, but don't want client code to be able to change the number of elements except by pushing and popping elements. Second, using a property provides encapsulation and abstraction. You could change the implementation -- perhaps by using linked lists rather than arrays -- without disturbing client code.</p><h3>Accessibility</h3><p>Each member of a class has an associated accessibility, which controls the regions of program text that are able to access the member. There are five possible forms of accessibility: <i>public</i>, <i>protected</i>, <i>internal</i>, <i>protected internal</i>, and <i>private</i>. </p><p>The <i>Stack</i> example shows the two extremes: <i>public</i> and <i>private</i>. For members like <i>size</i> and <i>values</i> that have <i>private</i> accessibility, access is limited to the class in which they are declared. Members that have <i>public</i> accessibility are accessible to any code. The use of <i>private</i> accessibility for the <i>size</i> and <i>values </i>fields lets you hide the implementation details of <i>Stack</i> from consumers.</p><p>For <i>protected</i> members, access is limited to the containing class or types derived from the containing class. For <i>internal</i> members, access is limited to the containing program. It should be no surprise that the <i>protected internal</i> form of accessibility is a combination of <i>protected</i> and <i>internal</i>. Members that are <i>protected internal</i> can be accessed from types derived from the containing class (that's the "protected" part) and from the containing program (that's the "internal" part). <A NAME="rl4"><A HREF="#l4">Listing Four</A> provides the complete source code for Step 3.</p><h3>Step 4: Variable Capacity</h3><p>The stack as implemented to this point has a severe limitation -- it can hold only 10 elements. To implement variable capacity, I'll do the following:</p><ul>  <li>Add a <i>DefaultCapacity</i> constant.  <li>Provide two constructors -- one that takes no parameters, and one that takes a capacity hint from the client.  <li>Add a read/write <i>Capacity</i> property that lets the client examine the current capacity, and also suggest a new capacity.  <li>Modify the <i>Push</i> method so that it automatically grows the capacity.</ul><p>These <i>Stack</i> features will let you examine some interesting language features -- constants, constructors, and read/write properties. After I've implemented these features, you'll be able to run the test program in <A NAME="rl5"><A HREF="#l5">Listing Five</A>, which produces the output:</p><blockquote><p>10</p><p>2</p><p>100</p><p>Count=15, Capacity=20, Elements=15,14,13,12,11,10,9,8,7,6,5,4,3,2,1</p></blockquote><h3>Constants</h3><p>A constant is a class member that represents a constant value: a value that can be computed at compile time. Constants are implicitly static, and can be accessed through the class in which they are declared.</p><p>The initial stack had a default capacity of 10. For the new variable capacity stack, I'll define a constant for this default capacity. The use of a constant rather than a "magic number" makes the code easier to read and modify.</p><p>I'll call the constant <i>DefaultCapacity</i>. As <A NAME="re4"><A HREF="0010ae4.htm">Example 4</A> shows, both declaration and use of this member are straightforward.</p><h3>Constructors</h3><p>An instance constructor is a member that implements the actions required to initialize an instance of a class. If no constructor is supplied for a class, then a public constructor with no parameters is automatically provided.</p><p><i>Stack</i>, as currently implemented, does not contain a constructor declaration, and instead relies on the compiler to supply one automatically. The code in <A NAME="re5"><A HREF="0010ae5.htm">Example 5</A>(a) omits a constructor, and is equivalent to <A NAME="re5"><A HREF="0010ae5.htm">Example 5</A>(b), which includes an explicit constructor.</p><p>The first action taken by any constructor -- except the parameterless constructor for the class object -- is to call another constructor, whether in the same class or in the base class. Calls to constructors in the same class can be made using the <i>this</i> keyword, and calls to base constructors can be made using the <i>base</i> keyword. If neither this nor base constructor calls are included, then a <i>base()</i> call is automatically included.</p><p>Like methods, constructors can be overloaded. This comes in handy for the new and improved stack, as you need two constructors: one that takes no parameters, and one that takes a suggested capacity from the client; see <A NAME="rl6"><A HREF="#l6">Listing Six</A>. Note that the parameterless constructor calls the other constructor, passing <i>DefaultCapacity</i> as a suggested capacity.</p><h3>Properties</h3><p>Next, I'll expose the capacity of the stack -- the number of elements it can hold without performing a time-consuming reallocation -- by providing a read/write property named <i>Capacity</i>. To create a read/write property, you write a property that includes both a <i>get</i> accessor and <i>set</i> accessor. </p><p>A <i>set</i> accessor for a property has an implicit parameter named <i>value</i> that contains the proposed new value of the property. The setter for the <i>Capacity</i> property checks to make sure that the capacity is valid, and then resizes the stack by creating a new array and copying the stack's elements into it; see <A NAME="rl7"><A HREF="#l7">Listing Seven</A>.</p><h3>The<i> Push</i> Method</h3><p>To complete the variable capacity stack, I'll modify the behavior of the <i>Push</i> method. The fixed-size stack threw an exception when there was no room for the item being pushed. Now that a variable capacity has been implemented, you can automatically grow the stack rather than throw an exception. To do this, set the <i>Capacity</i> property, as in <A NAME="re6"><A HREF="0010ae6.htm">Example 6</A>. <A NAME="rl8"><A HREF="#l8">Listing Eight</A> presents the complete code for Step 4.</p><h3>Step 5: <i>foreach</i>-style Iteration</h3><p>C# supports iteration using a convenient <i>foreach</i> construct. I'll add support for this form of iteration, and in the process touch on a number of language features. Once I've completed these modifications, you'll be able to run the test program in <A NAME="rl9"><A HREF="#l9">Listing Nine</A>, which initializes a stack and then uses <i>foreach</i> to iterate over its elements.</p><p>To implement this support, I'll make the following changes:</p><ul>  <li>Have <i>Stack</i> implement the <i>System.Collections.Enumerable</i> interface.  <li>Add a <i>Changed</i> event to <i>Stack</i>. This event is raised when the stack is modified, whether from a <i>push</i> operation or a <i>pop</i> operation.  <li>Implement a nested class named <i>Enumerator</i> that implements the <i>System.Collections.IEnumerator</i> interface. This enumerator maintains the state for an enumeration. It is invalidated if the stack is modified.</ul><p>These <i>Stack</i> features will lead you to examine more interesting language features: events, delegates, interfaces, <i>foreach</i>, and nested classes.</p><h3>Events and Delegates</h3><p>The stack, as it is implemented so far, includes constructors, constants, fields, methods, and properties. Next, I'm going to add an event. As you'll see, the event I'm adding will be useful in implementing the enumerator for the stack.</p><p>An event is a member that enables an object or class to provide notifications. A class defines an event by providing an event declaration, which resembles a field declaration, though with an added <i>event</i> keyword. The type of this declaration must be a delegate type.</p><p>Delegates enable scenarios that C++ and some other languages have addressed with function pointers. Unlike function pointers, delegates are object oriented, type safe, and secure. Delegates are reference types that derive from a common base class: <i>System.Delegate</i>. A delegate instance encapsulates a method -- a callable entity -- which is specified when the delegate is instantiated. The callable entity can either consist of an instance and a method on the instance, or a class and a static method on the class. After the delegate is created, it can be called using normal method call syntax. <A NAME="rl10"><A HREF="#l10">Listing Ten</A> declares a delegate that takes no parameters and returns void. The <i>Main</i> method creates an instance of this delegate type and calls it. This example shows the three main steps in using a delegate: declaring the delegate type, creating a delegate instance, and calling the delegate.</p><p>Now I'll apply the new add delegate knowledge by adding an event named <i>Changed</i>, and raise this event whenever the stack changes -- when items are pushed and popped. To add this event, I'll declare two members: an event named <i>Changed</i> and a protected method named <i>OnChanged</i> which raises the event. The <i>OnChanged</i> method serves several purposes. First, it centralizes the steps involved in raising the event. This is important because you will need to raise the event from several different methods. Second, it enables derived classes to customize the behavior of the event.</p><p>Events can have state associated with them. The <i>Changed</i> event has no interesting state, so I'll use the base <i>EventHandler/EventArgs</i> provided by the .NET class library. The type of the <i>Changed</i> event is <i>EventHandler</i>; see <A NAME="rl11"><A HREF="#l11">Listing Eleven</A>. Next, I'll alter <i>Push </i>and <i>Pop</i> so that they raise the <i>Changed</i> event by calling the <i>OnChanged</i> method; see <A NAME="rl12"><A HREF="#l12">Listing Twelve</A>.</p><p>To test the <i>Changed</i> event, the test program in <A NAME="rl13"><A HREF="#l13">Listing Thirteen</A> creates a <i>Stack</i>, connects an event handler to it, and then modifies the stack.</p><h3>Interfaces and <i>foreach</i></h3><p>C#'s <i>foreach</i> support is implemented using two interfaces: <i>IEnumerable</i> and <i>IEnumerator</i>. The <i>IEnumerable</i> interface is used to obtain an "enumerator" for a collection -- an object that implements <i>IEnumerator</i>.</p><p>An interface defines a contract by specifying the members that must be implemented, and the semantics of these members. A class or struct that implements an interface must adhere to its contract. <A NAME="rl14"><A HREF="#l14">Listing Fourteen</A> presents the declarations of <i>IEnumerable</i> and <i>IEnumerator</i>.</p><p>The best way to describe the semantics of <i>foreach</i>-style iteration is to provide two examples. <A NAME="re7"><A HREF="0010ae7.htm">Example 7</A>(a) shows <i>foreach</i>-style iteration over a collection, while <A NAME="re7"><A HREF="0010ae7.htm">Example 7</A>(b) shows the equivalent "by hand" iteration, using the <i>IEnumerable</i> and <i>IEnumerator</i> interfaces. As you can see, <i>IEnumerable</i> is used to obtain an enumerator -- an object that implements <i>IEnumerator</i>. The iteration is done by calling the <i>MoveNext</i> method and accessing the <i>Current</i> property.</p><h3>Nested Classes and Interface Implementation</h3><p>A nested class is a class that is lexically nested in another class. Like other class members, a nested class has an associated accessibility. I'll use a nested class for <i>Stack</i>'s enumerator, and give this class private accessibility. It is appropriate to use a private nested class because the only way you want any code to access the enumerator is through the <i>GetEnumerator</i> method on <i>Stack</i>.</p><p>To expose the enumerator, you need to implement the <i>IEnumerator</i> interface on <i>Stack</i>. To do this, you add a "base list" to the declaration of <i>Stack</i>. The base list for a class declaration is a comma-separated list that includes a base class, a list of interfaces, or both. You can now sketch out the enumerator implementation (see <A NAME="rl15"><A HREF="#l15">Listing Fifteen</A>) and get on to do the real work -- implement <i>Enumerator</i>. The enumerator class maintains the following pieces of state:</p><ul>  <li><i>currIndex</i>, which is the index of the current element.  <li><i>dirty</i>, which indicates whether the underlying stack has been changed since the enumerator was created.  <li><i>stack</i>, which refers to the underlying stack.</ul><p><i>Enumerator</i> does not make a copy of the stack elements. Instead, it keeps a reference to the underlying stack and invalidates itself when this underlying stack changes. <A NAME="rl16"><A HREF="#l16">Listing Sixteen</A> presents the complete code for Step 5.</p><h3>Conclusion</h3><p>In implementing a simple stack, I've described quite a bit of the language: namespaces, classes, a variety of class members (constants, constructors, events, fields, methods, and properties), member accessibility, delegates, overloading, overriding, versioning, exceptions, interfaces, and <i>foreach</i>-style iteration.</p><p>More important, though, you've gained some insight into the design philosophy that underlies the language. C# adheres close to its C++ heritage in many areas, and both simplifies and modernizes it in others. The result is a language that enhances your productivity without taking away your power and control.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>using System;class Stack{}class Test{    public static void Main() {       Stack s = new Stack();       Console.WriteLine("Done");    }}</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>using System;class Stack{    private int size = 0;     private object[] values = new object[10];    public virtual int Count {         get { return size; }        }    public virtual object Pop() {        if (size == 0)             throw new InvalidOperationException();        else {            object ans = values[--size];            values[size] = null;             return ans;        }    }    public virtual void Push(object o) {        if (size == values.Length)            throw new InvalidOperationException();        values[size++] = o;         }    public override string ToString() {         return ToString(",");    }    public virtual string ToString(string delimiter) {         switch (size) {            case 0:                return "";            case 1:                return values[0].ToString();            default:                string ans = "";                for (int i = size-1; i &gt; 0; i--)                    ans += values[i].ToString() + delimiter;                ans += values[0];                return ans;        }    }}</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>using System;class Test{    static void Main() {        Stack s = new Stack();        for (int i = 1; i &lt;= 5; i++) {            s.Push(i);         }        Console.WriteLine("Stack s = {0}", s);        while (s.Count &gt; 0)             Console.WriteLine("Popped {0}", s.Pop());        Console.WriteLine("Stack s = {0}", s);    }}</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>using System;class Stack{    private int size = 0;     private object[] values = new object[10];    public virtual int Count {         get { return size; }        }    public virtual object Pop() {        if (size == 0)             throw new InvalidOperationException();        else {            object ans = values[--size];            values[size] = null;             return ans;        }    }    public virtual void Push(object o) {        if (size == values.Length)            throw new InvalidOperationException();        values[size++] = o;         }    public override string ToString() {         return ToString(",");    }    public virtual string ToString(string delimiter) {         switch (size) {            case 0:                return "";            case 1:                return values[0].ToString();            default:                string ans = "";                for (int i = size-1; i &gt; 0; i--)                    ans += values[i].ToString() + delimiter;                ans += values[0];                return ans;        }    }}class Test{    static void Main() {        Stack s = new Stack();        for (int i = 1; i &lt;= 5; i++) {            s.Push(i);         }        Console.WriteLine("Stack s = {0}", s);        while (s.Count &gt; 0)             Console.WriteLine("Popped {0}", s.Pop());        Console.WriteLine("Stack s = {0}", s);    }}</pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five</H4><pre>using System;class Test{    static void Main() {        Stack a = new Stack();        Console.WriteLine(a.Capacity);        Stack b = new Stack(2);        Console.WriteLine(b.Capacity);        Stack c = new Stack(100);        Console.WriteLine(c.Capacity);        for (int i = 1; i &lt;= 15; i++)            a.Push(i);        Console.WriteLine("Count={0}, Capacity={1}, Elements={2}",                     a.Count,                     a.Capacity,                     a.ToString());    }}</pre><P><A HREF="#rl5">Back to Article</A></P><H4><A NAME="l6">Listing Six</H4><pre>using System;class Stack{    private int size;    private object[] values;    public Stack(): this(DefaultCapacity) {}    public Stack(int capacity) {         if (capacity &lt;= 0)            throw new ArgumentOutOfRangeException();        values = new object[capacity];        size = 0;    }    public const int DefaultCapacity = 10;    ...}class Test{    static void Main() {        Stack a = new Stack();        Stack b = new Stack(10);        Stack c = new Stack(100);    }}</pre><P><A HREF="#rl6">Back to Article</A></P><H4><A NAME="l7">Listing Seven</H4><pre>class Stack{    ...    public virtual int Capacity {        get {             return values.Length;         }        set {            if ((value &lt;= size) || (value &lt;= 0))                throw new ArgumentOutOfRangeException();            object[] newValues = new object[value];            Array.Copy(values, 0, newValues, 0, size);            values = newValues;        }    }    ...}</pre><P><A HREF="#rl7">Back to Article</A></P><H4><A NAME="l8">Listing Eight</H4><pre>using System;class Stack {    private int size;    private object[] values;    public Stack(): this(DefaultCapacity) {}    public Stack(int capacity) {        if (capacity &lt;= 0)            throw new ArgumentOutOfRangeException();        values = new object[capacity];        size = 0;    }    public virtual int Capacity {        get {             return values.Length;         }        set {            if ((value &lt;= size) || (value &lt;= 0))                throw new ArgumentOutOfRangeException();            object[] newValues = new object[value];            Array.Copy(values, 0, newValues, 0, size);            values = newValues;        }    }    public virtual int Count {        get { return size; }    }    public const int DefaultCapacity = 10;    public virtual object Pop() {        if (size == 0)             throw new InvalidOperationException();        else {            object ans = values[--size];            values[size] = null;            return ans;        }    }    public virtual void Push(object o) {        if (size == values.Length)            Capacity = size * 2;        values[size++] = o;    }    public override string ToString() {        return ToString(",");    }    public virtual string ToString(string delimiter) {        switch (size) {            case 0:                return "";            case 1:                return values[0].ToString();            default:                string ans = "";                for (int i = size-1; i &gt; 0; i--)                    ans += values[i].ToString() + delimiter;                ans += values[0];                return ans;        }    }}class Test{    static void Main() {        Stack a = new Stack();        Console.WriteLine(a.Capacity);        Stack b = new Stack(2);        Console.WriteLine(b.Capacity);        Stack c = new Stack(100);        Console.WriteLine(c.Capacity);        for (int i = 1; i &lt;= 15; i++)            a.Push(i);        Console.WriteLine("Count={0}, Capacity={1}, Elements={2}",                     a.Count,                     a.Capacity,                     a.ToString());    }}</pre><P><A HREF="#rl8">Back to Article</A></P><H4><A NAME="l9">Listing Nine</H4><pre>class Test{    static void Main() {        Stack s = new Stack();        for (int i = 1; i &lt; 10; i++)            s.Push(i);        foreach (int i in s)            Console.WriteLine(i);    }}</pre><P><A HREF="#rl9">Back to Article</A></P><H4><A NAME="l10">Listing Ten</H4><pre>using System;delegate void EmptyDelegate();class Test{    static void F() {        Console.WriteLine("F");    }    static void Main() {        EmptyDelegate d = new EmptyDelegate(F);        d();    }}</pre><P><A HREF="#rl10">Back to Article</A></P><H4><A NAME="l11">Listing Eleven</H4><pre>using System;class Stack{    ...    public event EventHandler Changed;    protected virtual void OnChanged(EventArgs e) {        if (Changed != null)            Changed(this, e);    }    ...}</pre><P><A HREF="#rl11">Back to Article</A></P><H4><A NAME="l12">Listing Twelve</H4><pre>public virtual object Pop() {    if (size == 0)         throw new InvalidOperationException();    else {        object ans = values[--size];        values[size] = null;        OnChanged(EventArgs.Empty);        return ans;    }}public virtual void Push(object o) {    if (size == values.Length)        Capacity = size * 2;    values[size++] = o;         OnChanged(EventArgs.Empty);}</pre><P><A HREF="#rl12">Back to Article</A></P><H4><A NAME="l13">Listing Thirteen</H4><pre>using System;class Test {    static void Stack_Changed(object sender, EventArgs e) {        Console.WriteLine("The stack changed: {0}", sender);    }    static void Main() {        Stack s = new Stack();        s.Changed += new EventHandler(Stack_Changed);        for (int i = 1; i &lt;= 10; i++)            s.Push(i);        while (s.Count &gt;= 0)            s.Pop();    }}</pre><P><A HREF="#rl13">Back to Article</A></P><H4><A NAME="l14">Listing Fourteen</H4><pre>namespace System.Collections{    public interface IEnumerable    {        IEnumerator GetEnumerator();    }    public interface IEnumerator    {        object Current { get; }        bool MoveNext();        void Reset();    }}</pre><P><A HREF="#rl14">Back to Article</A></P><H4><A NAME="l15">Listing Fifteen</H4><pre>using System;using System.Collections;class Stack: IEnumerable {    public virtual IEnumerator GetEnumerator() {         return new Enumerator(this);    }    private class Enumerator: IEnumerator     {        public Enumerator(Stack stack) {...}        public virtual object Current { get {...} }        public virtual bool MoveNext() {...}        public virtual void Reset() {...}    }    ...}</pre><P><A HREF="#rl15">Back to Article</A></P><H4><A NAME="l16">Listing Sixteen</H4><pre>using System;using System.Collections;class Stack: IEnumerable{    private int size;    private object[] values;    public Stack(): this(DefaultCapacity) {}    public Stack(int capacity) {        if (capacity &lt;= 0)            throw new ArgumentOutOfRangeException();        values = new object[capacity];        size = 0;    }    public virtual int Capacity {        get {             return values.Length;         }        set {            if ((value &lt;= size) || (value &lt;= 0))                throw new ArgumentOutOfRangeException();            object[] newValues = new object[value];            Array.Copy(values, 0, newValues, 0, size);            values = newValues;        }    }    public event EventHandler Changed;    public virtual int Count {        get { return size; }    }    public const int DefaultCapacity = 10;    private class Enumerator: IEnumerator    {        private int currIndex;        private bool dirty;        private Stack stack;        private void Stack_Changed(object sender, EventArgs e) {            dirty = true;            stack = null;        }        public Enumerator(Stack stack) {            this.stack = stack;            stack.Changed += new EventHandler(Stack_Changed);            dirty = false;            Reset();        }        public virtual object Current {            get {                ThrowIfDirty();                if ((currIndex == stack.size) || (currIndex == -1))                    throw new InvalidOperationException();                return stack.values[currIndex];            }        }        public virtual bool MoveNext() {            ThrowIfDirty();            if (currIndex == -1)                return false;            return --currIndex &gt;= 0;        }        public virtual void Reset() {            ThrowIfDirty();            currIndex = stack.size;        }        private void ThrowIfDirty() {            if (dirty)                throw new InvalidOperationException();        }    }    public virtual IEnumerator GetEnumerator() {        return new Enumerator(this);    }    protected virtual void OnChanged(EventArgs e) {        if (Changed != null)            Changed(this, e);    }    public virtual object Pop() {        if (size == 0)             throw new InvalidOperationException();        else {            object ans = values[--size];            values[size] = null;            OnChanged(EventArgs.Empty);            return ans;        }    }    public virtual void Push(object o) {        if (size == values.Length)            Capacity = size * 2;        values[size++] = o;             OnChanged(EventArgs.Empty);    }    public override string ToString() {        return ToString(",");    }    public virtual string ToString(string delimiter) {        switch (size) {            case 0:                return "";            case 1:                return values[0].ToString();            default:                string ans = "";                for (int i = size-1; i &gt; 0; i--)                    ans += values[i].ToString() + delimiter;                ans += values[0];                return ans;        }    }}class Test{    static void Main() {        Stack s = new Stack();        for (int i = 1; i &lt; 10; i++)            s.Push(i);        foreach (int i in s)            Console.WriteLine(i);    }}</pre><P><A HREF="#rl16">Back to Article</A></P></body></html>