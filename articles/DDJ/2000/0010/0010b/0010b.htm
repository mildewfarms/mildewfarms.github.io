<html><head><title>Oct00: C++ Type Traits</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>C++ Type Traits</h1><p><i>Dr. Dobb's Journal</i> October 2000</p><h2>Maximizing the amount of generic code</h2><h3>By John Maddock and Steve Cleary</h3><I>John is an independent programmer in England with an interest in generic programming. Steve, who lives in Michigan, currently works on a variety of systems for Control Engineering Company. They can be contacted at john_maddock@compuserve .com and scleary@jerviswebb.com, respectively.</I><hr><p>Generic programming -- that is, writing code that works with any data type meeting a set of requirements -- has become the method of choice for delivering reusable code. However, there are times in generic programming when generic just isn't good enough -- sometimes the differences between types are too great for an efficient generic implementation. This is when the traits technique becomes important. By encapsulating those properties that need to be considered on a type-by-type basis inside a traits class, you can minimize the amount of code that has to differ from one type to another, and maximize the amount of generic code. </p><p>For example, when working with character strings, one common operation is to determine the length of a null-terminated string. Clearly, it's possible to write generic code that can do this, but it turns out that there are much more efficient methods available. The C library functions <i>strlen</i> and <i>wcslen</i>, for instance, are usually written in assembler, and with suitable hardware support can be considerably faster than a generic version written in C++. The authors of the C++ Standard Library realized this, and abstracted the properties of <i>char</i> and <i>wchar_t</i> into the class <i>char_ traits</i>. Generic code that works with character strings can simply use <i>char_ traits&lt;&gt;::length</i> to determine the length of a null-terminated string, safe in the knowledge that specializations of <i>char_traits</i> will use the most appropriate method available to them.</p><DDJADVERTISEMENT INLINE><h3>Type Traits</h3><p>Class <i>char_traits</i> is a classic example of a collection of type-specific properties wrapped up in a single class -- what Nathan Myers terms a "baggage class" (see "Traits," by Nathan Myers, <i>C++ Report</i>, June 1995). In the Boost type-traits library (http://www.boost.org/), we have written a set of very specific traits classes, each of which encapsulate a single trait from the C++ type system. For example, is a type a pointer or a reference type, or does a type have a trivial constructor, or a const qualifier? The type-traits classes share a unified design. Each class has a single member called<i> value</i> -- a compile-time constant that is <i>true </i>if the type has the specified property, and <i>false </i>otherwise. These classes can be used in generic programming to determine the properties of a given type and introduce optimizations that are appropriate for that case. </p><p>The type-traits library also contains a set of classes that perform a specific transformation on a type; for example, they can remove a top-level <i>const</i> or <i>volatile </i>qualifier from a type. Each class that performs a transformation defines a single <i>typedef</i>-member <i>type </i>that is the result of the transformation. All of the type-traits classes are defined inside namespace <i>boost</i>; for brevity, this namespace qualification is omitted in most of the code samples presented here.</p><h3>Implementation</h3><p>There are far too many separate classes contained in the type-traits library to give a full implementation here (see the source code in the Boost library for full details). However, most of the implementation is fairly repetitive anyway, so in this article we will give you a flavor for how some of the classes are implemented. Beginning with possibly the simplest class in the library, <i>is_void&lt;T&gt;</i> has a member <i>value </i>that is <i>true </i>only if <i>T</i> is void; see <A NAME="rl1"><A HREF="#l1">Listing One</A>. Here we have defined the primary version of the template class <i>is_void</i>, and provided a full specialization when <i>T</i> is void. </p><p>While full specialization of a template class is an important technique, you sometimes need a solution that is halfway between a fully generic solution, and a full specialization. This is exactly the situation for which the standards committee defined partial template-class specialization. To illustrate, consider the class <i>boost::is_pointer&lt;T&gt;</i>. Here we needed a primary version that handles all the cases where <i>T</i> is not a pointer, and a partial specialization to handle all the cases where <i>T</i> is a pointer; see <A NAME="rl2"><A HREF="#l2">Listing Two</A>.</p><p>The syntax for partial specialization is somewhat arcane and could easily occupy an article in its own right. Like full specialization, to write a partial specialization for a class, you must first declare the primary template. The partial specialization contains an extra &lt;...&gt; after the class name that contains the partial specialization parameters; these define the types that will bind to that partial specialization, rather than the primary template. The rules for what can appear in a partial specialization are somewhat convoluted, but as a rule of thumb, if you can legally write two function overloads of the form:</p><blockquote><p>void foo(T);</p><p>void foo(U);</p></blockquote><p>then you can also write a partial specialization of the form:</p><blockquote><p>template &lt;typename T&gt;</p><p>class c{ /*details*/ };</p><p>template &lt;typename T&gt;</p><p>class c&lt;U&gt;{ /*details*/ };</p></blockquote><p>This rule is by no means foolproof, but it is reasonably simple to remember and close enough to the actual rule to be useful for everyday use.</p><p>As a more complex example of partial specialization, consider the class <i>remove_bounds&lt;T&gt;</i>. This class defines a single <i>typedef</i>-member <i>type </i>that is the same type as <i>T</i> but with any top-level array bounds removed. This is an example of a traits class that performs a transformation on a type; see <A NAME="rl3"><A HREF="#l3">Listing Three</A>.</p><p>The aim of <i>remove_bounds</i> is this: Imagine a generic algorithm that is passed an array type as a template parameter, <i>remove_bounds</i> provides a means of determining the underlying type of the array. For example, <i>remove_bounds&lt;int[4][5]&gt; ::type</i> would evaluate to the type <i>int[5]</i>. This example also shows that the number of template parameters in a partial specialization does not have to match the number in the primary template. However, the number of parameters that appear after the class name do have to match the number and type of the parameters in the primary template.</p><h3>Optimized <i>copy</i></h3><p>As an example of how the type-traits classes can be used, consider the standard library algorithm <i>copy</i>:</p><blockquote><p>template&lt;typename Iter1, typename Iter2&gt;</p><p>Iter2 copy(Iter1 first, Iter1 last, Iter2 out);</p></blockquote><p>Obviously, there's no problem writing a generic version of <i>copy</i> that works for all iterator types <i>Iter1</i> and <i>Iter2</i>; however, there are some circumstances when the <i>copy</i> operation can best be performed by a call to <i>memcpy</i>. To implement <i>copy</i> in terms of <i>memcpy</i>, all of the following conditions need to be met:</p><ul>  <li>Both of the iterator types <i>Iter1</i> and <i>Iter2</i> must be pointers.  <li>Both <i>Iter1</i> and <i>Iter2</i> must point to the same type -- excluding <i>const</i> and <i>volatile</i> qualifiers.  <li>The type pointed to by <i>Iter1</i> must have a trivial assignment operator.</ul><p>By "trivial assignment operator," we mean that the type is either a scalar type (that is, an arithmetic type, enumeration type, pointer, pointer to member, or <i>const</i>- or <i>volatile</i>-qualified version of one of these types) or:</p><ul>  <li>The type has no user-defined assignment operator.  <li>The type does not have any data members that are references.  <li>All base classes, and all data member objects must have trivial assignment operators.</ul><p>If all these conditions are met, then a type can be copied using <i>memcpy</i> rather than using a compiler-generated assignment operator. The type-traits library provides a class <i>has_trivial_assign</i>, such that <i>has_trivial_assign&lt;T&gt;::value</i> is <i>true </i>only if <i>T</i> has a trivial assignment operator. This class "just works" for scalar types, but has to be explicitly specialized for class/struct types that also happen to have a trivial assignment operator. In other words, if <i>has_trivial_assign</i> gives the wrong answer, it will give the safe wrong answer -- that trivial assignment is not allowable. The code for an optimized version of copy that uses <i>memcpy</i> where appropriate is given in <A NAME="rl4"><A HREF="#l4">Listing Four</A>. The code begins by defining a template class <i>copier </i>that takes a single Boolean template parameter, and has a static template member function <i>do_copy</i>, which performs the generic version of copy (in other words the "slow but safe version"). Following that there is a specialization for <i>copier&lt;true&gt;</i>. Again, this defines a static template member function <i>do_copy</i>, but this version uses <i>memcpy</i> to perform an optimized copy. </p><p>To complete the implementation, what we need now is a version of <i>copy</i> that calls <i>copier&lt;true&gt;::do_copy</i> if it is safe to use <i>memcpy</i>, and otherwise calls <i>copier&lt;false&gt;::do_copy</i> to do a generic copy. This is what the version in <A NAME="rl4"><A HREF="#l4">Listing Four</A> does. To understand how the code works, look at the code for <i>copy</i> and consider first the two <i>typedef</i>s <i>v1_t</i> and <i>v2_t</i>. These use <i>std::iterator_traits&lt;Iter1&gt;::value_type</i> to determine what type the two iterators point to, and then feed the result into another type-traits class <i>remove_cv</i> that removes the top-level <i>const</i>- or <i>volatile</i> qualifiers: This will let <i>copy</i> compare the two types without regard to <i>const</i>- or <i>volatile</i>-qualifiers. Next, <i>copy</i> declares an enumerated value <i>can_opt</i> that will become the template parameter to copier -- declaring this here as a constant is really just a convenience -- the value could be passed directly to class copier. The value of <i>can_opt</i> is computed by verifying that all of the following are true: </p><ul>  <li>First, that the two iterators point to the same type by using a type-traits class <i>is_same</i>.  <li>Then, that both iterators are real pointers, using the class <i>is_pointer</i> previously described.  <li>Finally, that the pointed-to types have a trivial assignment operator using <i>has_trivial_assign</i>. </ul><p>Finally we can use the value of <i>can_opt</i> as the template argument to copier. This version of <i>copy</i> will now adapt to whatever parameters are passed to it, if it's possible to use <i>memcpy</i>, then it will do so; otherwise it will use a generic <i>copy</i>.</p><h3>Was It Worth It?</h3><p>According to Donald Knuth, "premature optimization is the root of all evil" (<i>ACM Computing Surveys</i>, December, 1974). So the question must be asked: Was our optimization premature? To put this in perspective, <A NAME="rt1"><A HREF="0010bt1.htm">Table 1</A> lists the timings for our version of <i>copy</i> compared to a conventional generic <i>copy. </i>(The test code is available as part of the boost utility library; see algo_opt_ examples.cpp. The code was compiled with gcc 2.95 with all optimizations turned on. Tests were conducted on a 400-MHz Pentium II machine running Windows 98.)</p><p>Clearly, the optimization makes a difference in this case; but, to be fair, the timings are loaded to exclude cache miss effects. Without this, accurate comparison between algorithms becomes difficult. However, perhaps we can add a couple of caveats to the premature optimization rule: </p><ul>  <li>If you use the right algorithm for the job in the first place then optimization will not be required; in some cases, <i>memcpy</i> is the right algorithm.  <li>If a component is going to be reused in many places by many people, then optimizations may well be worthwhile where they would not be for a single case. In other words, the likelihood that the optimization will be absolutely necessary somewhere, sometime is much higher. Just as importantly, the perceived value of the stock implementation will be higher: There is no point standardizing an algorithm if users reject it on the grounds that there are better, more heavily optimized versions available.</ul><h3>Pair of References</h3><p>The optimized <i>copy</i> example shows how type traits can be used to perform optimization decisions at compile time. Another important use of type traits is to allow code to compile that otherwise would not do so unless excessive partial specialization were used. This is possible by delegating partial specialization to the type- traits classes. Our example for this form of usage is a pair that can hold references. (John Maddock and Howard Hinnant have submitted a compressed_pair library to Boost, which uses a technique similar to the one described here to hold references. Their pair also uses type traits to determine if any of the types are empty, and will derive to conserve space instead of contain; hence the name "compressed.") First, we'll examine the definition of <i>std::pair</i>, omitting the comparison operators, default constructor, and template copy constructor for simplicity; see <A NAME="rl5"><A HREF="#l5">Listing Five</A>. This pair cannot hold references as it currently stands, because the constructor would require taking a reference to a reference, which is currently illegal. (This is actually an issue with the C++ Core Language Working Group, issue #106, submitted by Bjarne Stroustrup. The tentative resolution is to allow a "reference to a reference to T" to mean the same thing as a "reference to T," but only in template instantiation, in a method similar to multiple cv-qualifiers.) Consider in <A NAME="rt2"><A HREF="0010bt2.htm">Table 2</A> what the constructor's parameters would have to be to allow <i>pair</i> to hold nonreference types, references, and constant references.</p><p>A little familiarity with the type-traits classes lets you construct a single mapping that allows you to determine the type of parameter from the type of the contained class. The type-traits classes provide a transformation add_reference (<A NAME="rt3"><A HREF="0010bt3.htm">Table 3</A>), which adds a reference to its type, unless it is already a reference. This lets you build a primary template definition for <i>pair </i>that can contain nonreference types, reference types, and constant reference types; see <A NAME="rl6"><A HREF="#l6">Listing Six</A>.</p><p>Add back in the standard comparison operators, default constructor, and template copy constructor (which are all the same), and you have a <i>std::pair</i> that can hold reference types. This same extension could have been done using partial template specialization of <i>pair</i>, but to specialize <i>pair</i> in this way would require three partial specializations, plus the primary template. Type traits let you define a single primary template that adjusts itself to any of these partial specializations, instead of a brute-force partial specialization approach. Using type traits in this fashion lets you delegate partial specialization to the type-traits classes, resulting in code that is easier to maintain and easier to understand.</p><h3>Conclusion</h3><p>Templates have enabled C++ users to take advantage of the code reuse that generic programming brings. However, generic programming does not have to sink to the lowest common denominator, and templates can be optimal as well as generic. Therein lies the value of type traits.</p><h3>Acknowledgments</h3><p>We would like to thank Beman Dawes and Howard Hinnant for their helpful comments when preparing this article.</p><p></p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>template &lt;typename T&gt; struct is_void{ static const bool value = false; };template &lt;&gt; struct is_void&lt;void&gt;{ static const bool value = true; };</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>template &lt;typename T&gt; struct is_pointer { static const bool value = false; }; template &lt;typename T&gt; struct is_pointer&lt;T*&gt; { static const bool value = true; };</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>template &lt;typename T&gt; struct remove_bounds{ typedef T type; };template &lt;typename T, std::size_t N&gt; struct remove_bounds&lt;T[N]&gt;{ typedef T type; };</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>namespace detail{template &lt;bool b&gt;struct copier{   template&lt;typename I1, typename I2&gt;   static I2 do_copy(I1 first, I1 last, I2 out);};template &lt;bool b&gt;template&lt;typename I1, typename I2&gt;I2 copier&lt;b&gt;::do_copy(I1 first, I1 last, I2 out){   while(first != last)   {      *out = *first;      ++out;      ++first;   }   return out;}template &lt;&gt;struct copier&lt;true&gt;{   template&lt;typename I1, typename I2&gt;   static I2* do_copy(I1* first, I1* last, I2* out)   {      memcpy(out, first, (last-first)*sizeof(I2));      return out+(last-first);   }};}template&lt;typename I1, typename I2&gt;inline I2 copy(I1 first, I1 last, I2 out){   typedef typename     boost::remove_cv&lt;     typename std::iterator_traits&lt;I1&gt;      ::value_type&gt;::type v1_t;   typedef typename     boost::remove_cv&lt;     typename std::iterator_traits&lt;I2&gt;      ::value_type&gt;::type v2_t;   enum{ can_opt =       boost::is_same&lt;v1_t, v2_t&gt;::value      &amp;&amp; boost::is_pointer&lt;I1&gt;::value      &amp;&amp; boost::is_pointer&lt;I2&gt;::value      &amp;&amp; boost::      has_trivial_assign&lt;v1_t&gt;::value    };   return detail::copier&lt;can_opt&gt;::      do_copy(first, last, out);}</pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five</H4><pre>template &lt;typename T1, typename T2&gt; struct pair {  typedef T1 first_type;  typedef T2 second_type;  T1 first;  T2 second;  pair(const T1 &amp; nfirst, const T2 &amp; nsecond)  :first(nfirst), second(nsecond) { }};</pre><P><A HREF="#rl5">Back to Article</A></P><H4><A NAME="l6">Listing Six</H4><pre>template &lt;typename T1, typename T2&gt; struct pair {  typedef T1 first_type;  typedef T2 second_type;  T1 first;  T2 second;  pair(boost::add_reference&lt;const T1&gt;::type nfirst,       boost::add_reference&lt;const T2&gt;::type nsecond)  :first(nfirst), second(nsecond) { }};</pre><P><A HREF="#rl6">Back to Article</A></P></body></html>