<html><head><title>Oct00: The TINI Internet Interface</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>The TINI Internet Interface</h1><p><i>Dr. Dobb's Journal</i> October 2000</p><h2>A tiny board with  big possibilities</h2><h3>By Al Williams</h3><I>Al is an author and consultant who lives near Houston, Texas. He is the author of Microcontroller Projects with Basic Stamps (R&amp;D Books, 1999) as well as numerous books on Windows programming. Look for Al at http://www.al-williams.com/.</I><hr><p>It doesn't take much imagination to see that soon nearly every digital device and appliance will be able to connect to the Internet. Just about everything has a microprocessor these days, so the only trick is adding Internet connectivity. Embedded microprocessor manufacturers know this is the case, and they are scrambling to provide Internet-enabled solutions for embedded developers.</p><p>One of the more interesting ideas I've run across is a board from Dallas Semiconductor (http://www.dalsemi.com/) called the "Tiny InterNet Interface" (TINI). This 1.25X4.05-inch printed-circuit board (see <A NAME="rf1"><A HREF="0010hf1.htm">Figure 1</A>) looks like a standard memory SIMM. However, on this diminutive board is a Java-capable microprocessor, at least 512 K of nonvolatile memory, and an Ethernet transceiver. In addition, there are a variety of interfaces to connect to external devices (I2C, CAN, RS232, and 1-wire) and a full bus-oriented interface on the SIMM's edge connector. For details on the TINI board, go to http://www.ibutton .com/TINI/index.html.</p><DDJADVERTISEMENT INLINE><h3>What Can It Do?</h3><p>The TINI's biggest strength is that it has Java built in -- well, almost. The TINI's firmware (which you can load using a special tool) has a specially adapted Java Virtual Machine (JVM) that runs with the limited hardware and memory that the TINI has available. This JVM does not run standard class files, and doesn't support everything that a normal workstation's JVM supports. Still, it is surprising how much the JVM does support.</p><p>For example, the TINI can operate as a web, FTP, and Telnet server -- all at the same time. The web server even supports servlets. In fact, the most common way to load programs into the TINI is to use FTP. Dallas Semiconductor supplies custom classes to operate the special hardware and the standard javax.comm package for serial port. The java.lang, java.net, java.io, and java.util packages are a semipermanent part of the firmware. You can selectively load other packages as needed into RAM.</p><p>What isn't included? That depends. As of beta 2, java.io is missing object-serialization functions; java.lang doesn't support reflection, the <i>FloatingDecimal</i> class, and transcendental functions; and java.util doesn't contain the <i>Calendar</i>, <i>Date</i>, and related classes. Dallas Semiconductor documents what isn't in the JVM, but you won't often need what is missing for embedded development.</p><h3>Getting Started</h3><p>The easiest way to get up and running with the TINI is to buy the TINI Sockets board from Dallas Semiconductor. This is simply a board with a SIMM socket for the TINI, a power supply, and connectors for RS232 and 10base-T Ethernet. This makes it simple to power up the TINI and connect things to it. Of course, for production, you'd probably use the TINI  board separately (or perhaps even the chipset, which Dallas will sell separately). However, for development, the Sockets board is the way to go.</p><p>Once you get the TINI powered up, you'll need to be running a computer with an RS232 port tied to the TINI's main serial port (SERIAL0). The connection only requires a 3-wire cable. By default, however, the board uses the DTR signal from the computer to reset the TINI. The Dallas Semiconductor software contains JavaKit, a special program that is written in Java. Therefore, it should run on any computer that supports Java -- including the javax.comm API for accessing serial ports. I've run the program on a PC (which is what the instructions assume) and others running JavaKit under Linux (see http://www.apms.com.au/tini/javakit.html). </p><p>The purpose of JavaKit is to load basic software into the TINI. You can follow the directions provided with the board to load the basic JVM and other necessary firmware. After everything is set, you will also want to load a default program. Before deploying the TINI, you might want to place your own software here. However, for development, you'll probably just load SLUSH, a command shell similar to a stripped-down UNIX command shell. SLUSH lets you manage what is in the TINI's memory, check its status, set up its Ethernet interface, and run programs. This is the program that responds to requests over the serial port and Telnet, by default.</p><p>If you are comfortable with UNIX, SLUSH isn't a problem. You can type "help" to see a list of commands and you can also use help to get specific help on each command. You can log into the TINI (using the default <i>root </i>or <i>guest </i>account). Probably the first thing you'll do is set up the TINI's Ethernet interface. You can issue an <i>ipconfig</i> command to set the IP address, network mask, and gateway address. You can also specify that the TINI should get an IP address from a DHCP server.</p><p>Once you have the Ethernet interface running, you'll probably do your interactions with the TINI via Telnet. By default, the TINI constantly listens for logins over the serial port and Telnet. It also listens for FTP requests. You can stop these servers using the <i>downserver</i> command (or restart them with <i>startserver</i>). For example, you might want to release the serial port for other uses, so you could enter <i>downserver -s</i> to stop the serial server from accepting logins.</p><p>Of course, you need to connect the TINI board to your network. If you already use 10base-T and you have a spare port on a nearby hub, you can connect a cable from the TINI socket board to the hub. If you are just doing development and don't want a full-blown network, you can use a computer with an appropriate network card and cross-over cable. (These cables are specifically for connecting two -- and only two -- computers together without a hub.)</p><h3>Building Programs</h3><p>Once you can log into the TINI, you are ready to go. To write TINI programs, you need a Java development environment such as the Sun JDK (that's what I use) or any standard Java IDE (Borland's JBuilder, for example). You'll need to set the Java compiler's options to use the TINI classes (for the Sun JDK, use the <i>-bootclasspath</i> option with the path name to the tiniclasses.jar file). </p><p>Once you have a class file, the next step is to convert it into a format appropriate for the TINI to use. You do this by running the Java program TINIConvertor. Use the <i>-f</i> option to name the class file you want to convert. The <i>-o</i> option names the output file. The <i>-d</i> option specifies a database that corresponds with the loaded TINI firmware. In the absence of other options, the converter sets the file so that the main function in the first class you name will execute. I use the following batch file to automatically run TINIConvertor:</p><blockquote><p>java TINIConvertor -f %1.class -o %1.tini -d  </p><p>   e:\tini\TINIBeta2\firmware\tini.db</p></blockquote><p>You supply the name of the class as an argument, and the result is a .tini file suitable for execution on the board.</p><p>Assuming you don't get any compile errors (or errors while converting the file) you are ready to send the output file to the TINI. The easiest way to do this is with FTP. Once the file is in place, you can issue a SLUSH command to start it. If your file is test.tini, you start it with <i>java test.tini</i>. You can add command-line parameters if you like. An &amp; character at the end of the line starts the program and returns you to the SLUSH prompt immediately. </p><p>If you want to automatically start a program, use the /etc/.startup file, which provides SLUSH a set of commands to execute at startup. However, for production use, you'd probably want to replace SLUSH with your own program. To do this, you have to run another conversion step. For example, </p><blockquote><p>java com.dalsemi.tiniconvertor.BinToHex 				        -input </p><p> Filename.tini -output Filename -startBank 			    7 -hex386</p></blockquote><p>produces an image file you can load with JavaKit instead of SLUSH.</p><h3>A Simple Project</h3><p>The TINI has lots of potential. With its multitude of interfaces, you can use it as an intelligent bridge between practically any device and any network -- including the Internet. Suppose you want to measure several process variables in a manufacturing plant. Since there is a web server that supports servlets available, you could simply collect the data using the TINI and make the parameters available as part of a web page. Anyone on the network could monitor the plant's operation using an ordinary web browser. The Java code could perform engineering unit conversion, averaging, or store historical data.</p><p>Of course, you might want another program to read the data instead of a web browser. That's even easier, because Java makes working with sockets a snap. The test program I present here reads input from the RS232 port and sends it to a socket on a remote computer. A companion Java program running on the remote computer simply displays the data. In real life, it might display the results graphically, or save the values in a file.</p><h3>RS232 Woes</h3><p>Technically, the TINI supports four serial ports. However, one of them is a TTL serial port and doesn't have full support in the current release of the firmware. Two other ports require external UARTs. That leaves the main serial port as the only functional, true RS232 port on the board without adding more hardware. </p><p>Unfortunately, SLUSH and the system console use this serial port. Consequently, you must shut down SLUSH's serial server (using <i>downserver -s -d</i>) if you want to use the serial port from your own program.  You can also modify the /etc/.startup file to prevent the serial server from loading. If you replace SLUSH with your own program you can use the serial port freely.</p><p>Dallas Semiconductor supplies a custom object that lets you use the serial port (the source code for SLUSH is a good example of how to use it). However, recent versions support the standard javax.comm package, so the custom routines are now deprecated. </p><p>With some experimentation, you'll find that the serial port doesn't support all possible baud rates, nor does it support flow control. I couldn't find a single place where the capabilities were documented, but your program will throw an exception when you try to use something that isn't there.</p><h3>Inside the Project</h3><p>Currently, I have a custom piece of hardware that uses a Motorola 68HC11 CPU to convert four voltages into digital values, then sends them to a PC using 9600-baud RS232. The data is formatted as four hex numbers, separated by spaces, and ending in a carriage return. The RS232 cable limits the distance the instrument can be from the PC. If the PC is on the LAN, that's fine, but it seems silly to dedicate a PC simply to use as a network gateway for this device.</p><p><A NAME="rl1"><A HREF="#l1">Listing One</A> is the <i>SerialSender</i> class, a Java program that requires two arguments. The first argument is the IP (or host name) of the computer that should receive the data. The second argument is the port number that the computer is using. Most of the action occurs in the <i>go</i> subroutine. </p><p>First, the program opens a socket -- remember, this is on a tiny embedded computer that costs about $50.00. Still, the code is identical to how you'd open a socket on a PC or any other Java platform, for that matter. The program then writes the string "Start" to the socket as a debugging aid. The code flushes the socket. This way if the RS232 code goes astray, you'll still see the debugging message. Without the flush, the string could be waiting in limbo after the code hangs. This gives you the incorrect impression that the socket code did not work, when in fact it is the RS232 code that is the culprit.</p><p>The javax.comm package provides a standard way to use communication ports under Java. The basic sequence of steps that you'll use to open an input stream on a serial port is:</p><p>1.	Create a <i>CommPortIdentifier</i> object that names the serial port (for the TINI this is <i>serial0</i>) by calling the static method <i>CommPortIdentifier.getPortIdentifier</i>.</p><p>2.	Use the object's <i>open</i> method to create a <i>SerialPort</i> object.</p><p>3.	Use <i>setSerialPortParams</i> to set the <i>SerialPort</i>'s baud rate and other parameters.</p><p>4.	Call <i>getInputStream</i> to return an <i>InputStream</i> object that refers to the port.</p><p>This <i>InputStream</i> object is like any other. In fact, for debugging purposes, you might want to replace the serial port code with <i>is=System.in;</i> which lets you use the standard input stream as a source for input (so you can enter characters from the SLUSH terminal or a Telnet session).</p><p>After both the port and the socket are ready, a <i>while</i> loop reads characters from the port and sends them to the socket. On receipt of an end-of-line character, the program flushes the socket so that the remote computer receives frequent updates. </p><h3>The Other Side</h3><p><A NAME="rl2"><A HREF="#l2">Listing Two</A> is the Java program for the host computer. This is an ordinary Java program that doesn't require any special TINI classes or conversion to run. It only requires one argument, a port number.</p><p>Instead of an ordinary socket, the host program uses <i>ServerSocket</i>, a specialized class that handles all of the details required to wait for client requests. Because the program only handles one client at a time, the program closes the socket after the call to accept (which returns when a client connects). </p><p>Once the socket is ready, it is a simple matter to make a <i>BufferedReader</i> and read the incoming data a line at a time. <A NAME="rl2"><A HREF="#l2">Listing Two</A> simply echoes the data to the console output, but the same principle would apply if you wanted to do more sophisticated processing.</p><h3>Conclusion</h3><p>For $50.00, the TINI can act as a Java-programmable translator between an Ethernet connection and any other device you can connect to it. Not only is this a very inexpensive option, but Java makes it almost trivial to write programs that can interact over a network or the Internet.</p><p>At first it seems a bit odd to do cross development in Java and then download to the target computer using FTP. However, the fact that this modest board can support HTTP, FTP, Telnet, and serial servers is a testament to its true power.</p><p>Remember, the TINI is in beta testing as I write this. It still has some kinks. For example, several times during development my RAM corrupted and I had to go back to the loader and clear the heap before anything would work again. Assuming Dallas Semiconductor gets all the quirks out of the TINI, however, it looks like a winner. </p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>// TINI sender classimport java.io.*;import java.net.*;import javax.comm.*;public class SerialSender  {  SerialPort rs232;  Socket sock;  OutputStreamWriter os;  InputStream is;  String msg;  public static void main(String args[])   {   if (args.length!=2)   // check arguments and go     {     System.out.println("Usage: SerialSender host port");     System.exit(9);     }   new SerialSender().go(args);   }  void procError(String s) // Note: Tini Exceptions don't return messages   {   System.out.println("Error");   System.out.println(s);   System.exit(1);   }// main routine  public void go(String args[])    {// Open socket    try       {        System.out.println("Connecting to " + args[0] +":"+ args[1]);        sock=new Socket(args[0],Integer.parseInt(args[1]));      }    catch (Exception e)      {      procError("Can't open Socket");      }// Connect socket to stream    try      {      os=new OutputStreamWriter(sock.getOutputStream());      os.write("Start\r\n",0,7);      os.flush();      }    catch (Exception e)      {      procError("Can't open stream");      }// Open RS232     try        {// Use this code to open the RS232 port        CommPortIdentifier cpi;        cpi=CommPortIdentifier.getPortIdentifier("serial0");        if (cpi==null) procError("Can't find SERIAL0");        rs232 = (SerialPort)cpi.open("SSend",1000);        rs232.setSerialPortParams(9600,SerialPort.DATABITS_8,           SerialPort.STOPBITS_1,SerialPort.PARITY_NONE);        is=rs232.getInputStream();// Or... Just use stdin//          is=System.in;        }        catch (Exception e)         {         procError("Can't open RS232 port " +msg);         }// main loop    while (true)       {      int c;      try        {        c=is.read();        }      catch (Exception e)         {        continue; // ignore rs232 exceptions        }      try        {        if (c==13) c=10;  // cr to LF        os.write(c);        if (c==10) os.flush();        }      catch (Exception e)        {        procError("Write error");        }      }     }    }</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>// Host programimport java.io.*;import java.net.*;public class SerialRcv  {  ServerSocket ssock;  BufferedReader br;  Socket sock;  public static void main(String args[])    {    if (args.length!=1)  // check arguments and go      {      System.out.println("Usage: SerialRcv port");      System.exit(1);      }    new SerialRcv().go(args);    }// main routine  public void go(String args[])    {// get a connection    try      {      ssock=new ServerSocket(Integer.parseInt(args[0]));      System.out.println("Listening on port " + args[0]);      sock=ssock.accept();      ssock.close(); // quit listening      System.out.println("Status: Connection established");      br=new BufferedReader(         new InputStreamReader(          sock.getInputStream()));      }    catch (Exception e)      {      System.out.println("Can't open or connect server socket");      System.exit(1);      }// main loop    while (true)      {      try        {        String s=br.readLine();        if (s==null) break;        if (s.length()==0) continue;  // no blank lines        System.out.println(s);        }       catch (Exception e)        {        System.out.println("Read error");        System.exit(2);        }      }    }  } </pre><P><A HREF="#rl2">Back to Article</A></P></body></html>