<html><head><title>Oct00: Migrating to Namespaces</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Migrating to Namespaces</h1><p><i>Dr. Dobb's Journal</i> October 2000</p><h2>It's not so bad when you follow the rules</h2><h3>By Herb Sutter</h3><I>Herb is chief technology officer of PeerDirect Inc. He also serves as secretary of the ISO/ANSI C++ Standards committee, and chair of ANSI SQL/Replication. He is the author of the books Exceptional C++ and the forthcoming Peer Distributed Databases (Addison-Wesley, 2000). Herb can be contacted at hsutter@peerdirect.com.</I><hr><p>Although C++ changed greatly during standardization, few of the changes the committee made are likely to break existing code. There is one change, however, that will cause nearly all earlier C++ code to fail to compile -- the addition of namespaces. More specifically, all of the C++ Standard Library now lives in namespace <i>std</i>. </p><p>If this hasn't troubled you yet, then it probably will soon, because the newest releases of most C++ compilers conform to this change. As you start upgrading to the latest release of your compiler, your code will be forced to adapt.</p><DDJADVERTISEMENT INLINE><p>For instance, <A NAME="re1"></a><A HREF="0010ce1.htm">Example 1</A>(a) used to work, but now requires that you either specifically say which names are in <i>std</i>, see <A NAME="re1"></a><A HREF="0010ce1.htm">Example 1</A>(b); write <i>using</i> declarations to bring the necessary <i>std</i> names into scope, see <A NAME="re1"></a><A HREF="0010ce1.htm">Example 1</A>(c); write a "<i>using</i> directive" to drag all the <i>std</i> names into scope wholesale, see <A NAME="re1"></a><A HREF="0010ce1.htm">Example 1</A>(d); or some combination of the aforementioned. So, what's the right way to use namespaces in the long run? And what's the best way to move a large body of existing code to the new rules quickly, deferring unnecessary (for now) migration work without increasing the overall migration workload later? I'll address these questions in this article.</p><h3>Guidelines for a  Good Long-Term Solution</h3><p>First, what's the right way to use namespaces in the long run? It's important to decide this first, because knowing the long-term answer will help you decide what to aim for when you craft your best short-term migration strategy.</p><p>In short, a good long-term solution for namespace usage should follow these rules:</p><p></p><p><b>Namespace Rule #1:</b> Avoid <i>using</i> directives entirely, especially in header files. The reason for Rule #1 is that <i>using </i>directives cause wanton namespace pollution by bringing in potentially huge numbers of names, many of which are unnecessary. The presence of the unnecessary names greatly increases the possibility of unintended name conflicts -- not just in the header itself, but in every module that <i>#include</i>s the header. I find it helpful to think of a <i>using</i> directive as a marauding army of crazed barbarians that sows indiscriminate destruction wherever it passes -- something that by its mere presence can cause unintended conflicts, even when you think you're allied with it.</p><p><b>Namespace Rule #2:</b> Never write namespace <i>using</i> declarations in header files. Rule #2 goes much further than most popular advice. Most programmers recommend that <i>using</i> declarations never appear at file scope in shared header files. That's good advice, as far as it goes, because at file scope a <i>using</i> declaration causes the same kind of namespace pollution as a <i>using</i> directive, only less of it. Unfortunately, the popular advice does not go far enough. Here is why you should never write <i>using</i> declarations in header files at all, not even in a namespace scope: The meaning of the <i>using</i> declaration may change depending on what other headers happen to be #<i>include</i>d before it in any given module. This kind of unpredictability is bad, and should never be permitted. I'll illustrate this in <A NAME="rl2"></a><A HREF="#l2">Example 2</A>.</p><p>Namespace Rule #3: Use C headers with the new style "<i>#include &lt;cheader&gt;</i>" instead of the old style "<i>#include &lt;header.h&gt;.</i>" For backward compatibility with C, C++ still supports all of the Standard C header names (stdio.h, for instance) and when you <i>#include</i> those original versions, the associated C Library functions are visible in the global namespace as before -- but in the same breath, C++ also says that the old header names are deprecated, which puts the world on notice that they may be removed in a future version of the C++ Standard. Thus, Standard C++ strongly encourages programmers to prefer using the new versions of the C headers that start with "c" and drop the ".h" extension (that is, <i>cstdio</i>); when you <i>#include</i> the C headers using the new names, you get the same C Library functions, but now they live in namespace <i>std</i>.</p><h3>Long-Term Approaches</h3><p>To illustrate these rules, consider <A NAME="rl2"></a><A HREF="#l2">Example 2</A> and two long-term approaches for migrating the module to namespaces. How can you best migrate <A NAME="rl2"></a><A HREF="#l2">Example 2</A>(a) to a compiler that respects namespaces and a library that puts the standard names in namespace <i>std</i>? Think about what alternatives you might consider. Which ones are good? Which ones aren't? Why? </p><p>Have you made a decision? All right, then. There are several ways you might approach this, and I'll describe two common strategies -- only one of which is good form.</p><h3>A Good Long-Term Solution</h3><p>A good long-term solution is to explicitly qualify every standard name wherever it is mentioned in a header (.h) file, and to write just the <i>using</i> declarations that are needed inside each source (.cpp) file for convenience, because those names are likely to be widely used in the source file; see <A NAME="rl2"></a><A HREF="#l2">Example 2</A>(b). The <i>using</i> declarations inside x.cpp had better come after all <i>#include</i> directives; otherwise, they may introduce name conflicts into other header files depending on the order in which they're <i>#include</i>d. An alternative long-term solution is to do <A NAME="rl2"></a><A HREF="#l2">Example 2</A>(b), but eschew the <i>using </i>declarations entirely and explicitly qualify every single standard name, even inside the .cpp file. I don't recommend doing this, however, simply because it's a lot of extra work that doesn't deliver any real advantage in a typical situation.</p><h3>A Not-So-Good Long-Term Solution</h3><p>In contrast, one often-proposed solution is actually dangerous. This bad long-term "solution" proposes to put all of the project's code into its own namespace (which is not objectionable in itself, but isn't as useful as one might think) and write the <i>using</i> declarations or directives in the headers (which unintentionally opens a gaping door for potential problems). The reason some people have proposed this method is that it requires less typing than some other namespace-migration methods; see <A NAME="rl2"></a><A HREF="#l2">Example 2</A>(c). Note the highlighted error: The reason, as stated, is that the meaning of a <i>using</i> declaration in a header can change -- even when the <i>using</i> declaration is inside a namespace, and not at file scope -- depending on what else a client module may happen to <i>#include</i> before it. Clearly, it's always bad form to write any kind of code that can silently change meaning depending on the order in which headers are <i>#include</i>d.</p><h3>An Effective Short-Term Solution</h3><p>The reason I've spent time explaining the desirable long-term solution, and discrediting some bad approaches, is because knowing what you want to eventually achieve will help you pick a simpler short-term solution that won't compromise your long-term solution. So now I'll tackle the short-term question: What is the most effective way to migrate your existing code base to deal with namespace <i>std</i>?</p><p>Speaking pragmatically, the "upgrade to the new compiler version" task is just one of a list of things to be done in your product's release cycle. Upgrading the compiler and migrating to namespaces probably isn't the most urgent item on the task list, and you have lots of other things to do and product features to add; more likely than not, you're under project deadline pressure to boot, so you should prefer the quickest namespace migration approach that gets the job done without compromising future safety and usability. How can you best defer unnecessary (for now) migration work to the future without increasing the overall migration workload? First, consider migrating the header files:</p><p><b>Migration Step #1:</b> In every header file, add "<i>std::</i>" qualifiers wherever needed. "Is adding <i>std::</i> everywhere really necessary?" you might ask. "Couldn't you just add <i>using</i> declarations or directives in the headers?" Well, adding <i>using</i> declarations or directives would indeed be the least work, but it's work that would have to be undone when you implement the correct long-term solution; Namespace Rules #1 and #2 already reject such an approach, and you've already seen compelling reasons not to go down that road. Given that you mustn't add <i>using</i> declarations or directives in headers, then, your only alternative for headers is to add <i>std::</i> in the right places.</p><p><b>Migration Step #2:</b> Create a new header file called "myproject_last.h" that contains the directive <i>using namespace</i> <i>std;</i>. In every implementation file, <i>#include myproject_last.h</i> after all other <i>#include</i>s. Things are a little better with implementation files: You can get away with simply writing a <i>using </i>directive in each implementation file, as long as the <i>using</i> directive appears after all <i>#include</i> statements. Writing a <i>using </i>directive avoids/defers the tedious work of figuring out the (possibly lengthy) correct set of <i>using</i> declarations that will eventually go into each implementation file -- yes, that's right, as a temporary expedient you are deliberately choosing to invite an army of crazed barbarians to dinner. But never fear. As long as you're careful to write the <i>using</i> directive after all <i>#include</i>s, this doesn't compromise -- or change the meaning of -- any other code in any other modules. The barbarians may be at your table for the evening, but you're chaining them to their seats. The <i>using</i> directive is best put into a separate header that is then <i>#include</i>d in each implementation file after all other headers, both for safety (for example, to ensure you are sending only a single, well-controlled invitation to the army of crazed barbarians), and for another good reason that will become clearer in a moment. Finally, what about the new <i>&lt;cheader&gt;</i> header style? </p><p>Fortunately, that's optional, so it doesn't need to be done during the initial migration pass, which also defers all of the associated namespace issues. </p><p><A NAME="rl2"></a><A HREF="#l2">Example 2</A>(d) is the result of applying the two-step migration strategy to <A NAME="rl2"></a><A HREF="#l2">Example 2</A>(a). This does not compromise the long-term solution in that it doesn't do anything that will need to be undone for the long-term solution. At the same time, it's simpler and requires fewer code changes than a full long-term solution would. In fact, this approach represents the minimum amount of work you can get away with that will make your code work on a namespace-aware compiler but that won't make you have to go back and undo any of the work later.</p><h3>Migrating to the Long-Term Solution</h3><p>Finally, at some happy point in the future when you are momentarily free of pressing project deadlines, you can perform a simple migration to the full long-term solution illustrated in <A NAME="rl2"></a><A HREF="#l2">Example 2</A>(b). Simply follow these steps:</p><p></p><p>1. In each header or implementation file: Change lines that <i>#include </i>C headers to the new <i>&lt;cheader&gt;</i> style; for example, change <i>#include &lt;stdio.h&gt;</i> to <i>#include &lt;cstdio&gt;</i>.</p><p>2. In myproject_last.h: Comment out the <i>using</i> directive.</p><p>3. Rebuild your project. See what breaks the compile. In each implementation file, add the correct <i>using</i> declarations (after all <i>#include</i>s).</p><p></p><p>If you follow this advice, then even with looming project deadlines, you'll be able to quickly -- and effectively -- migrate to a namespace-aware compiler and library, all without compromising your long-term solution. </p><p><b>DDJ</b></p></body></html>