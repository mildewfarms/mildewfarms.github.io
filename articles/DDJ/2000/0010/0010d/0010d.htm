<html><head><title>Oct00: Type-Based Alias Analysis</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Type-Based Alias Analysis</h1><p><i>Dr. Dobb's Journal</i> October 2000</p><h2>Optimization  that makes C++ faster than C</h2><h3>By Mark Mitchell</h3><I>Mark is the CTO of CodeSourcery. He can be contacted at mark@codesourcery.com.</I><hr><p>Optimizing compilers try to transform source code into the most efficient machine-code equivalent. Techniques such as alias analysis and type-based alias analysis help accomplish that goal. In this article, I'll examine these techniques and explain how you can write source code that is easier for the compiler to optimize. Although C++ is often criticized as being too slow for high-performance applications, I'll show how C++ can actually enable compilers to create code that is even faster than the C equivalent.</p><p>CodeSourcery (my company) contributed an implementation of these optimization techniques to the GNU C and C++ compilers (gcc and g++, respectively). These techniques are also used by other optimizing compilers, including the MIPS compilers produced by SGI. Thus, you can take the techniques presented here and use them to improve your code today.</p><DDJADVERTISEMENT INLINE><h3>Aliasing: The Problem</h3><p>Two pointers alias one another if they point to the same location in memory. For instance, in <A NAME="re1"><A HREF="0010de1.htm">Example 1</A>, <i>ip1</i> and <i>ip2</i> are both aliases for <i>i</i>. The existence of aliases makes optimization much more difficult because it is hard to tell whether a particular value is being changed. Take a look at the function in <A NAME="re2"><A HREF="0010de2.htm">Example 2</A>(a). If the compiler could deduce that <i>ip1</i> and <i>ip2</i> cannot point to the same array, then the compiler could compile this function to assembly code that looks like <A NAME="re2"><A HREF="0010de2.htm">Example 2</A>(b). Note that there would be only one LOAD per loop iteration, except for the very first iteration. That's because the value of <i>ip2[i+1]</i> from that iteration is the same as <i>ip2[i]</i> on the next iteration, so there's no reason to reload the value.</p><p>Unfortunately, there's no way to know, just from looking at the function definition, that <i>ip1</i> and <i>ip2</i> do not alias. For example, the use of <i>f</i> in <A NAME="re3"><A HREF="0010de3.htm">Example 3</A> is completely legal, even though both arguments to <i>f</i> are identical.</p><p>Now, the assembly code shown in <A NAME="re2"><A HREF="0010de2.htm">Example 2</A>(b) is invalid because the value of <i>ip2[i+1]</i> is changed by the store into <i>ip[i+1]</i>. That happens because <i>ip1</i> and <i>ip2</i> are both aliases for <i>ia</i>. Because of this possibility, a C compiler must generate an extra LOAD instruction on each loop iteration, ending up with code like that shown in <A NAME="re2"><A HREF="0010de2.htm">Example 2</A>(c).</p><p>Examples like these are part of the reason that Fortran is often espoused as being faster than C. In Fortran, aliasing is illegal, so the compiler would be allowed to assume that <i>ip1</i> and <i>ip2</i> cannot alias. So, while the faster code in <A NAME="re2"><A HREF="0010de2.htm">Example 2</A>(b) would be generated by a good Fortran compiler, a C or C++ compiler must generate the slower code in <A NAME="re2"><A HREF="0010de2.htm">Example 2</A>(c).</p><h3>Alias Analysis: The Solution</h3><p>A compiler uses alias analysis to try to determine when two pointers do not alias. If the compiler can determine that two pointers are not aliases of one another, then the compiler can generate more efficient code in cases like the aforementioned example.</p><p>There are many techniques for doing alias analysis. One approach is the use of special keywords, such as <i>restrict</i>. The next version of C, currently called "C9X," provides this new keyword. You can use <i>restrict</i> to tell the compiler that one pointer does not alias another. This technique shifts the burden of deciding what might alias what from the compiler to you. The advantages to this approach are that it makes the compiler easier to implement and it lets you provide the compiler with information that no amount of automated analysis might be able to provide. CodeSourcery contributed an implementation of <i>restrict</i> to the GNU C and C++ compilers, so current versions of gcc and g++ support <i>restrict</i>. Several other commercial compilers also support <i>restrict</i>.</p><p>However, <i>restrict</i> is no panacea for the alias ailment. If you declare that two variables cannot alias, but then write code that causes them to alias, the program will not work correctly. A bug like this can take days to track down. It is cumbersome to use <i>restrict</i> everywhere. Because <i>restrict</i> is not supported by many C and C++ compilers, it is not portable. Finally, certain aspects of the way in which C9X defines <i>restrict</i> mean that there are situations where automated analysis can show that two things do not alias, but where there is no way to specify this with <i>restrict</i>.</p><p>In addition to using special keywords, such as <i>restrict</i>, compilers use lots of other techniques to establish when a pointer cannot alias some object. For instance, in <A NAME="re4"><A HREF="0010de4.htm">Example 4</A> the compiler does not have to worry about <i>ip</i> aliasing <i>j</i> because <i>j</i>'s address is never taken. If the address of a variable is never taken, then it's impossible for any pointer to point to it. In C++, there are ways to take the address of a variable without using the &amp; operator. In particular, you pass the variable by reference, or call one of its member functions. But if none of those possibilities occur, then the variable is never addressed.</p><p>Since the compiler can tell that <i>j</i> is never addressed, it does not need to worry that <i>g</i> might modify <i>j</i>. That means that <i>j</i> can be kept in a callee-saved register (one that is guaranteed to be preserved by called functions); it does not need to be read from or written to memory on each iteration through the loop.</p><p>As a programmer, you can benefit from knowledge about how the compiler performs alias analysis. In particular, you can write programs that run faster if you know that aliasing issues are important. In the first version of <i>f</i> in <A NAME="re5"><A HREF="0010de5.htm">Example 5</A>, the compiler has to worry that <i>g</i> might modify <i>*p</i>. Therefore, <i>*p</i> will be reloaded on each pass through the loop as it passed to <i>h</i>. In the second version, <i>x</i> is never addressed, so the compiler can keep it in a register, thereby improving performance. (Of course, if <i>g</i> really might modify <i>*p</i>, you shouldn't use this trick.) The downside to programming like this is that you may make your code harder to read. It's not a good idea to use this technique everywhere; use it only where performance is really critical.</p><h3>Type-Based Alias Analysis</h3><p>A more complicated kind of alias analysis is type-based alias analysis. It is used in top-of-the-line compilers, including the GNU C and C++ compilers. This form of alias analysis uses the types of variables to determine what things might alias what. Although useful in C as well, type-based alias analysis is a particularly powerful weapon in C++, sometimes allowing C++ code to run faster than the obvious C equivalents.</p><p>The idea behind type-based alias analysis techniques is to use the aliasing rules in the C and C++ standards to assist the compiler. For instance, the code in the first half of <A NAME="re6"><A HREF="0010de6.htm">Example 6</A> is not legal ANSI/ISO C or C++ since it treats the address of <i>d</i> as if it were a pointer to an <i>int</i>, even though it is really a pointer to a <i>double</i>. The technical rule in the Standards, with a few exceptions, is as follows:</p><blockquote><p>"If a program attempts to access the stored value of an object through an <i>lvalue</i> of [a type other than the dynamic type of the object] then the behavior is undefined." </p></blockquote><p>That just means that you have to use the type an object really has when accessing it. The bit about "dynamic types" means that you can use a base-class pointer to access a derived-class object.</p><p>For those that are curious, the exceptions are that you may use an <i>lvalue</i> (roughly speaking, a pointer or reference) to a signed type to access an object of unsigned type, or vice versa, that you can use an <i>lvalue</i> with different <i>const</i>-ness or <i>volatile</i>-ness than the object, and that you can use an <i>lvalue</i> of type <i>char</i> or <i>unsigned char</i> to access any object whatsoever. That last clause implies that the code in the second part of <A NAME="re6"><A HREF="0010de6.htm">Example 6</A> is legal because the modification of <i>d</i> happens through a pointer of type <i>char*</i>. (One reason for the exception for character types is so that you can write a portable version of <i>memcpy</i>; you can just iterate through the object copying it character by character.)</p><p>These rules make it possible for the compiler to do additional alias analysis. The numerical code in <A NAME="re7"><A HREF="0010de7.htm">Example 7</A> is representative of code that appears in many scientific applications. A few instructions here or there can make a big difference in a loop this small. There is an assignment to <i>s-&gt;x_m[i]</i> on each iteration of the loop. Therefore, a compiler that doesn't know about type-based alias analysis would have to reload <i>s-&gt;a_m</i>, <i>s-&gt;b_m</i>,  <i>s-&gt;x_m</i>, and <i>s-&gt;n_m</i> on each iteration, for fear that the assignment to <i>s-&gt;x_m[i]</i> might have altered <i>s-&gt;a_m</i>. However, a compiler that uses type-based alias analysis can recognize that the store to <i>s-&gt;x_m[i]</i> is modifying a double, while <i>s-&gt;a_m</i> is a <i>double*</i>. Therefore, it would be illegal for <i>s-&gt;x_m[i]</i> to be at the same address as <i>s-&gt;a_m</i>. Consequently, there's no need to reload <i>s-&gt;a_m</i> or <i>s-&gt;b_m</i> as the program iterates through the loop. Similar considerations apply to <i>s-&gt;n_m</i>; it need not be reloaded either.</p><p>Concretely, the second part of <A NAME="re7"><A HREF="0010de7.htm">Example 7</A> shows the code that GCC would generate for a MIPS processor, without type-based alias analysis, but with all other optimizations for this loop. (If you don't read MIPS assembly code, don't worry. The code is annotated, and you'll see the basic idea.) In this code, the register <i>$f3</i> contains <i>u_m,</i> and <i>$f2</i> contains <i>v_m</i>. The register <i>$5</i> holds <i>i</i>.</p><p>The third part of <A NAME="re7"><A HREF="0010de7.htm">Example 7</A> shows the code when type-based alias analysis is used. The compiler counts backward in this loop, because it knows that <i>s-&gt;n_m</i> cannot change. In particular, <i>$2</i> starts out as <i>s-&gt;n_m</i> and is decremented until it reaches 0. In this version of the loop, there are only 11 instructions instead of 17, representing approximately a 35 percent speedup. Because there are fewer references to memory, the improvement could be even greater than that. The key is that the compiler was able to avoid reloading <i>s-&gt;a_m</i>, <i>s-&gt;b_m</i>, and <i>s-&gt;x_m</i>, and <i>s-&gt;n_m</i> on each loop iteration.</p><p>Because some compilers now do type-based alias analysis, you should be careful not to violate the typing rules given in the language specification. If you write code that uses an <i>int*</i> to modify a <i>double</i>, you may well find that, when you enable optimizations, your compiler does not do what you expect.</p><p>For example, the compiler might decide that it can treat the code in the first half of <A NAME="re8"><A HREF="0010de8.htm">Example 8</A> as identical to the code in the second half, even though the last two lines have been reordered. Since the compiler knows that <i>ip</i> cannot point to a <i>double</i>, it does not have to worry that the assignment to <i>*ip</i> modifies <i>d</i>. Thus, the code generated won't behave as you expect. You should think of breaking the type system in this way as equivalent to using uninitialized memory, accessing data after you have passed it to <i>free</i>, or some other equally heinous activity.</p><h3>Benefits of Type-Based  Alias Analysis in C++</h3><p>Type-based alias analysis can be of particular benefit to C++ programmers when container classes are in use. In C, a reusable list of abstract data types would look something like the definition in the first part of <A NAME="re9"><A HREF="0010de9.htm">Example 9</A>.</p><p>Using this data structure, there would be no difference (in type) between a list of <i>int</i>s and a list of <i>double</i>s; both would be just pointers to a <i>list_node</i>. For example, assume that <i>x</i> is a list of <i>integer</i>s and <i>y</i> is a list of <i>double</i>s, and take a glance at the code in the second part of <A NAME="re9"><A HREF="0010de9.htm">Example 9</A>.</p><p>One drawback to the use of C is the ugly casts. However, there's an aliasing issue as well. The assignment to <i>y-&gt;next</i> changes a <i>list_node*</i>. So, on the third line, the compiler cannot be sure that <i>x-&gt;next</i> still points to the same thing it did before. Therefore, <i>x-&gt;next</i> will be reloaded from memory. However, since <i>x</i> is really a list of <i>int</i>s, and <i>y</i> a list of <i>double</i>s, the programmer knows these things could never alias. Thus, the compiler will not generate code that is as good as possible, even using type-based alias analysis.</p><p>In C++, however, the situation is different. Of course, by using templates, ugly casts can be avoided. In addition, however, templates can make it possible for the compiler to generate tighter code. Assume a <i>list_node</i> is defined by a template such as that in <A NAME="re10"><A HREF="0010de10.htm">Example 10</A>. Then, the sample code using the data structure would be almost unchanged. (Just remove the casts, as in the second part of <A NAME="re10"><A HREF="0010de10.htm">Example 10</A>.) But, now the compiler knows that the assignment <i>y-&gt;next</i> is to a <i>list_node&lt;double&gt;*,</i> whereas <i>x-&gt;next</i> is a <i>list_node&lt;int&gt;*</i>. Therefore, there's no way that that <i>x-&gt;next</i> can change, and it doesn't have to be reloaded from memory. The stronger type system in C++ permits the compiler to generate better code.</p><p>Of course, you could make two list structures in C. For example, you could have a <i>list_node_int</i> and a <i>list_node_double</i>. Then, you would still reap the benefits of type-based alias analysis. However, this approach is not nearly as convenient as using templates. If you use a C++-to-C translator (such as CodeSourcery's mmCC) to compile your code, the translator will automatically generate <i>list_node_ int</i> and <i>list_node_double</i>. Then, even if you have only a C compiler available, you can have all the benefits of C++, including type-based alias analysis.</p><h3>Conclusion</h3><p>I've stressed here the ability of the compiler to avoid redundant loads and stores. That's probably the most important benefit of type-based alias analysis, since it reduces the instruction count in a sequence of code. There are other benefits as well, however. For example, the fact that two memory references do not alias gives the instruction scheduler more flexibility. On today's deeply pipelined machines, that translates to fewer pipeline stalls and faster code.</p><p>When writing code, you should remember that aliasing issues make it difficult for compilers to generate code that runs as fast as you might hope. In performance-critical code, you should try to help the compiler figure out what pointers cannot alias what objects. There are several ways to do that. Avoid taking the addresses of objects. Use temporary variables, rather than expressions involving pointers or references, to tell the compiler that a particular variable cannot change during a section of code. Use the type system to help make clear what can and what cannot alias.</p><p>More globally, the next time someone starts talking about the overhead of C++, and how performance-critical code should always be written in C or Fortran, remember that C++'s strong type system can allow for better optimization opportunities. Features such as templates can be used not only for type safety and readability, but also to allow the compiler to generate faster code.</p><p><b>DDJ</b></p></body></html>