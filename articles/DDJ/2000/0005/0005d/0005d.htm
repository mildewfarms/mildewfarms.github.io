<html><head><title>May00: LDAP  Search Filters</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>LDAP  Search Filters</h1><p><i>Dr. Dobb's Journal</i> May 2000</p><h2>A C++ class  makes it easy</h2><h3>By Marcelo A.F. Calbucci</h3><I>Marcelo is a developer on the Microsoft Exchange Server. He can be contacted at mcalbu@microsoft.com.</I><hr><p>Many protocols run over the basic frame of the Internet, including HTTP/HTML, FTP, and SMTP. In this article, I'll focus on yet another protocol -- the Lightweight Directory Access Protocol (LDAP). LDAP is a transport mechanism for Directory Service transactions. Consequently, LDAP has a set of API functions to handle such operations as search, add, modify, delete, and the like. These APIs are available from various vendors. </p><p>LDAP has been examined in several <i>DDJ</i> articles, including "Examining Microsoft's LDAP API," by Sven B. Schreiber (December, 1998); "Understanding LDAP," by Basit Hussain (March, 1999); and "Examining PerLDAP," by Troy Neeriemer (April 1999). Here, I will focus on the search filter that is part of LDAP search functionality. This is the most relevant parameter when performing a directory search -- and searches are the most important operation you're going to do in a directory. In the process, I'll present <i>CLdapFilter</i>, a C++ class to handle LDAP search filters (available electronically; see "Resource Center," page 5).</p><DDJADVERTISEMENT INLINE><h3>The Search Filter</h3><p>An LDAP search filter is a string containing one or more primitive conditions to retrieve objects from a directory. (For our purposes here, a "primitive condition" is one that tests a single type with a value.) Its syntax (see <A NAME="rt1"><A HREF="0005dt1.htm">Table 1</A>) defines a set of primitive conditions using<i> and/or/not </i>operations stored in a prefix notation. In other words, the LDAP search filter is related to directories in the same way that, say, SQL is to databases.</p><p>A simple query for all objects in a directory might be <i>ldap_search_s(ld, "", LDAP_SCOPE_SUBTREE, "(objectClass=*)", NULL, 0, </i>&amp;<i>result);</i>. The filter here is <i>"(objectClass=*)"</i> -- which can be translated to "I want all entries where the <i>objectClass</i> attribute is present." In this case, it means all objects, because any object present in the directory has to have the <i>objectClass</i> attribute set.</p><h3>Programming Issues</h3><p>LDAP search functions use a simple string to specify the filter being used. If you want to have a filter that gets all entries that have <i>givenName</i> equal to "Homer" or "Marge," age equal to "32 or greater," and an e-mail address, your search filter might be <i>"(</i>&amp;<i>(|(givenName=Homer)(givenName= Marge))(age&gt;=32)(mail=*))."</i> Because programmers are used to infix notation, switching to this notation often leads to erroneous filters.</p><p>Another issue that arises involves brackets. A search filter that contains several subfilters and logical operations makes you spend time figuring out if the brackets are right. Can you find the error in the filter <i>"(</i>&amp;<i>(|(sn=Simpson)(age&gt;=32))(!(| (givenName=Marge)(givenName=Lisa)))"</i>? Give up? A close bracket is missing in the last position. And if you give this string as a parameter for <i>ldap_search</i>, the only thing you'll get as a reply is the error message LDAP_FILTER_ERROR. I've made this mistake when creating complex filters. For instance, in the middle of a large piece of code, you could waste time finding that the problem is in the <i>ldap_search</i>, and even more time finding out what is wrong with the filter. Of course, your compiler is not going to parse the string and indicate during compile time that you've got an error. You have to wait until run time to find out -- and you have to hope you find out before your customer does.</p><h3>A Solution</h3><p>I initially set out to build a class that could let me construct filters in an infix notation (using a C++ operator overloading mechanism and the only member variable). I naively thought <i>wstring</i> (STL <i>basic_string</i> for Unicode) would work. Then, when I overloaded <i>operator</i>&amp;&amp;, <i>operator||</i>, and <i>operator!</i>, my new class would put the brackets and operators in place. Therefore, instead of the previous filter, I could write:</p><blockquote><p>CLdapFilter Filter;</p><p>Filter = (F("sn=Simpson'') || F("age&gt;=32")) &amp;&amp; !(F("givenName=Marge") || F("given				Name=Lisa"))</p></blockquote><p>The <i>F</i> is just a <i>#define</i> of <i>CLdapFilter</i>, so you can write shorter lines. If nothing else, the compiler will complain if you commit any error with brackets like this. This is better then a link-time or run-time error.</p><p>This approach is slower than using a simple string. But filter construction isn't a performance concern, at least when it comes to writing directory client programs. The time you spend building filters will be less than the time the directory server takes to reply. In fact, you can probably construct hundreds of filters in the time it takes your server to reply to a single search with a single entry as a result. Better yet, client programs can construct one filter and use it several times.</p><p>The class for search filters can help you when writing filters because it improves the readability of the code and saves misunderstanding brackets. But you still have a problem, particularly if users use a more complex filter when creating a <i>CLdapFilter</i> object, as in:</p><blockquote><p>CLdapFilter Filter("(&amp;(sn=Simpson)(given			         Name=Homer))");</p></blockquote><p>There are two ways you can avoid making mistakes when building this <i>CLdapFilter</i>. The first is to prohibit users from creating filters that have one or more brackets. This implies you should only use primitive comparisons -- something that's not a good solution, since you can't reuse filters from strings, only from primitive comparisons or from another <i>CLdapFilter</i>. The second solution -- and the approach I take -- is to build a parser that analyzes the filter being provided as a string.</p><h3>Final Version</h3><p>With this in mind, my final filter design consists of a class that is not only a string, but an entire structure that holds a complete filter. In addition, for each element it inserts in this structure, the code parses the string to be sure it's a syntax-compliant filter.</p><p>As an aside, I used Unicode as my base because I think most of the actual implementation of LDAP APIs support Unicode as parameters. Also, the LDAP protocol is not Unicode, so your API is responsible for converting from Unicode to ASCII (UTF8).</p><p>The class that you talk to is <i>CLdapFilter</i>, which provides several useful interfaces to create, modify, and read your filter. Internally, however, I use a subclass called <i>CFilterTree,</i> which contains a set of subfilters and the operation you are performing on those subfilters. I also had to add another type of operation that is not an <i>and/or/not</i>;<i> </i>I call this an "item." The operation item means you are not handling subfilters, but a simple primitive comparison (as in<i> "sn=Simpson"</i>). To store this item, I added a <i>wstring</i> that is mutually exclusive with the subfilters: If the operation type is item, the information is stored in the string; if the operation type is not item, the information is stored in the subfilters. The subfilter is an STL's vector of <i>CFilterTree</i>. You can see the members variables in <A NAME="rl1"><A HREF="#l1">Listing One</A>.</p><p>The first thing you should have noticed is that I'm storing an entire <i>CFilterTree</i> in my vector container, not a pointer to it. There are several reasons for this. First, to make the code more readable and easy to maintain, I like to avoid pointers. Second, while profiling both versions (pointer versus class), there was no performance penalty. This is primarily because filters are usually small, don't have hundreds of subfilters, and you perform more read operations than writes. Pointers, however, lead to performance degradation due to dereferencing it. <A NAME="rf1"><A HREF="0005df1.htm">Figure 1</A> illustrates <i>CFilterTree</i>.</p><p>My <i>CLdapFilter</i> class is made of one <i>CFilterTree</i>, which can be made up of several <i>CFilterTree</i> and/or items (primitive comparisons). <A NAME="rl2"><A HREF="#l2">Listing Two</A> is a snapshot of <i>CLdapFilter</i>. This way of storing information is slower than storing the entire filter in a simple string, but is more flexible. The parser makes this class even slower, but has the benefit of never having an invalid filter.</p><p>There are two approaches to error notification when constructing an object of a class in C++. The first is to set an internal member variable (or some static one) with some error code, and pray that the programmer using the class will check this variable before using the object. The second is to throw an exception in the constructor. </p><p>I used both in my implementation, depending on whether you compile with the LDAPFILTER_SUPPORT_EXCEPTION defined. This is done in filter.h (available electronically). If you compile without this <i>#define</i>, you will have two more member variables that store the error code. You can then use <i>GetLastError()</i> or <i>GetLastErrorString()</i> to return text with the error message. I have a variable that stores the position in the string that the parser failed; it is retrieved using <i>GetLastErrorPos()</i>. You also have an additional function called <i>ClearLastError()</i>.</p><p>If you compile with that <i>#define</i>, you won't have these member functions or variables. Instead, you are going to throw an exception of type <i>CFilterException</i> if the parser fails. The exception class has two main member functions: <i>GetError()</i>, which returns a string with the error message; and <i>GetPos()</i>, which returns the position in the string the error occurred. </p><p>If I need to set an error in the parser code, I call <i>SetLastError()</i>, which is responsible for setting the error variables in the class; otherwise, I throw an exception.</p><h3>Operators</h3><p><i>operator</i>&amp;&amp; is not a member of the class, but a global function. It is necessary because after this operator, you don't want it to change the <i>lhs</i> or <i>rhs</i> values. You return a new <i>CLdapFilter</i>.</p><p>If you want to construct a <i>CLdapFilter</i> with the string: </p><blockquote><p>"(&amp;(objectClass=person)(sn=Simpson))"</p></blockquote><p>you execute:</p><blockquote><p>CLdapFilter Result = F("objectClass=person") 		       &amp;&amp; F("sn=Simpson");</p></blockquote><p>First, the <i>F("objectClass=person")</i> constructs a temporary instance of <i>CLdapFilter</i>. The code parses the string; if it is okay, it sets the operation type of this class to <i>OpTypeItem</i> and sets the <i>m_wsItem</i> to the string passed to the constructor. The same thing for <i>F("sn=Simpson")</i>.</p><p>After constructing both temporary <i>CLdapFilter</i> instances, you call the <i>operator</i>&amp;&amp; with these two objects. The first thing that <i>operator</i>&amp;&amp; does is check that the <i>rhs </i>and <i>lhs </i>values are valid. If the construction of one of these failed, you have a member variable saying what was the last error. In this case, you propagate the error to the result and finish.</p><p>I decided that if one of the values passed to the function is empty, the result is going to be the other one, or empty if both were empty. This sounds odd, but what do "X &amp;&amp;" or "&amp;&amp; Y" mean? I decided they mean "X" and "Y," respectively. So, if you are writing code and users decide to enter <i>wsFilter1</i> but leave <i>wsFilter2</i> empty, you still have a good filter in <i>Result</i>. </p><p>If none of the values passed to <i>operator</i>&amp;&amp; were empty, you have two real subfilters to be transformed into a single <i>and </i>operation. But, these subfilters could also be <i>and </i>operations. For example, the filter:</p><blockquote><p>"(&amp;(&amp;(a=b)(c=d))(&amp;(e=f)(g=h)))"</p></blockquote><p>has the same semantic as:</p><blockquote><p>"(&amp;(a=b)(c=d)(e=f)(g=h))"</p></blockquote><p>If the operation in one of the parameters is also an <i>and, </i>you do not add this parameter to the subfilter list. Instead, you add the subfilters of the parameter to the subfilter list of the result.</p><p>The mechanism is identical for <i>operator||</i>. But for <i>operator!</i>, you have a particularity. If you deny something that was already denied, you are reaffirming it. This is:</p><blockquote><p>"(!(!(a=b)))" =="(a=b)"</p></blockquote><p>So you put this logic into the <i>operator!</i>.</p><p>To improve the readability and maintainability, I implemented all other operators or member functions (that use <i>wstring</i> or <i>wchar_t *</i> as a parameter) simply by calling the operator that uses the <i>CLdapFilter</i> as a constructor.</p><p>Because LDAP filters don't support empty filters, it should be illegal to pass empty strings to the constructor or <i>operator=</i>. But I decided not to do this, because you can improve the programmability when you don't have to check every parameter that you pass to <i>CLdapFilter</i> class.</p><h3>The Parser</h3><p>After you call a constructor using <i>wchar_t *</i> or <i>wstring</i> (or use <i>operator=</i>), you call <i>ParseString()</i>. The entire parser subsystem is written in six functions; see <A NAME="rt2"><A HREF="0005dt2.htm">Table 2</A>.</p><p>First of all, <i>LdapEscapable()</i> is problematic. Depending on the implementation of the LDAP server you are running, other characters can also escape. So if you need to change something in <i>CLdapFilter</i>, this is the first function you should examine.</p><p>The <i>ValidateAttribute*()</i> functions are simple and not fully compliant with the LDAP standard. For example, I don't check if the type of the attribute is using only valid characters. I only check if it is not empty, and do not have spaces between characters. For the attribute value, it can be anything except empty.</p><p><i>ParseCondition()</i> parses a simple primitive condition. It can be written without the brackets (as in <i>"sn=Simpson"</i>) or with any number of brackets (<i>"(((sn=Simpson)))"</i>). The first is not an LDAP standard, but it is useful. This function also strips the type and value of the attribute and calls the validate functions.</p><p>Finally, you spend most of your time in <i>FullParser()</i>. This function uses a simple mechanism to break full conditions into small ones, and calls itself recursively until it finds out that the condition is a primitive condition. It then calls the <i>ParseCondition()</i>.</p><p>The algorithm that parses an entire string is straightforward. You start reading each character in the string, ignoring spaces. If the character is an open bracket, you increment the brackets counter; if it is a close bracket, you decrement the brackets count. If the counter, after start, reaches zero, that means this should be the last character in the filter; anything following it is a syntax error. If it goes below zero, it means that you have a brackets mismatch, as in <i>(sn=3)). </i>At the end of parsing, if the brackets counter is not zero, you have more open than close brackets.</p><p>If the character being parsed is a &amp;, |, or ! (and is in between two open brackets), you enter operation mode. This means that you have a complex filter, and should start parsing each following pair of open/close brackets as a subfilter. At this time, you call <i>FullParser()</i> recursively. </p><p>I do a lot of other checks in <i>FullParser()</i> to see whether the character sequence is valid. For example, after a close bracket, if there is any character other than a bracket, then we have a syntax error.</p><p>The last function of the parser mechanism of <i>CLdapFilter</i> is <i>ParseString()</i>. Its only purpose is to call <i>FullParser()</i>. This function could be dropped and you could call <i>FullParser() </i>directly, but I do a little check to see if the string is empty. This should never happen with <i>FullParser()</i>. <A NAME="re2"><A HREF="0005de2.htm">Example 2</A> is a call stack of a <i>ParseString()</i> function.</p><p>I could have written all the parser functions as static members of <i>CLdapFilter</i>, but this is a problem with the error variables. A solution is to make the error variables also static, as some APIs do.</p><h3>Conclusion</h3><p>Is <i>CLdapFilter</i> thread safe? It depends. The real question is: Is the STL library you are using thread safe? If the answer is yes, then <i>CLdapFilter</i> is thread safe. Here, I use the classes with the Microsoft STL implementation that came with Visual C++ 6.0, which are not thread safe. Therefore, I cannot share <i>CLdapFilter</i> instances between threads.</p><p>One optimization that can be done in <i>CLdapFilter</i> is reference counting. Every time you use the copy constructor or the assignment operator, we copy all member variables. For a medium-size filter string, this equates to something between 150 and 300 bytes. If you copy this filter several times, a performance penalty can result. Reference counting is platform dependent, because you should implement a mechanism that makes it thread safe. In Windows, you can use the SDK API functions <i>InterlockedIncrement()</i> and <i>InterlockedDecrement()</i>. But remember, Microsoft's STL is not thread safe, so you still have some issues to resolve here.</p><p>Even though this class was originally written in C++, it is simple to transform it into a Java class or any other language that supports OOP and operator overloading. This class is also platform independent, so it should work with most of the operational systems and processors existent.</p><p><i>CLdapFilter</i> is a nice class if you are working on an LDAP client program and need to construct several filters. However, there is little or no gain in using this class if you have just a few static filters in the code.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>Struct CFilterTree {   enum eOpType = {OpTypeNull, OpTypeItem, OpTypeAnd, OpTypeOr, OpTypeNot};   // . . . member functions   eOpType m_eOpType;   vector&lt;CFilterTree&gt; m_SubFilters;   wstring m_wsItem;};</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>Class CLdapFilter {public:   // ...protected:   // ...private:  CFilterTree m_FilterTree;  wstring m_wsGeneratedString;  bool m_fModified;  // ... other members};</pre><P><A HREF="#rl2">Back to Article</A></P></body></html>