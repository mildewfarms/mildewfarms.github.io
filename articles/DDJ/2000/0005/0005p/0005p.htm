<html><head><title>May00: Programmer's Bookshelf</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Stirring the Gene Pool</h1><p><i>Dr. Dobb's Journal</i> May 2000</p><h3>By Gregory V. Wilson</h3><h4><br><b><i>Objects  Unencapsulated: Java, Eiffel, and C++?</i></b><br>Ian Joyner <br>Prentice Hall, 1999 <br>386 pp., $49.00<br>ISBN 0-130-14269-7 <br><br><b><i>The Logic Programming Paradigm: A 25-Year Perspective</i></b><br>Krzysztof R. Apt, Victor W. Marek, Mirek Truszczynski,  and David S. Warren <br>Springer-Verlag, 1999<br>456 pp., $59.95<br>ISBN 3-540-65463-1 <br><br><b><i>Quantum Computing  and Communications</i></b><br><i>Michael Brooks, editor</i><br>Springer-Verlag, 1999<br>152 pp., $44.95<br>ISBN 1-852-33091-0 <br><br><b><i>Cambrian Intelligence</i></b><br><i>Rodney A. Brooks</i> <br>MIT Press, 1999<br>199 pp., $25.00<br>ISBN 0-262-02468-3 <br><br><b><i>Intellectual Property in the Age of Universal Access</i></b><br><i>Diane Crawford, editor</i><br>Association of  Computing Machinery, 1999<br>72 pp., $25.95<br>ISBN 1-58113-169-0<br><b><i><br></i></b>Database Design for Smarties<br><i>Robert J. Muller</i> <br>Morgan Kaufmann, 1999<br>442 pp., $44.95<br>ISBN 1-558-60515-0 <br><br><b><i>Designing Maintainable Software</i></b><br><i>Dennis D. Smith</i> <br>Springer-Verlag, 1999<br>169 pp., $49.95<br>ISBN 0-387-98783-5<br><br><b><i>Automating Windows with Perl</i></b><br><i>Scott McMahan</i><br>R&amp;D Books, 1999<br>209 pp., $34.95<br>ISBN 0-879-30589-4<br></h4><p>Biologists have learned that a species' ability to adapt depends on the diversity of its gene pool. With 80 percent of colleges now using Java in their first-year programming courses, there is a danger that computing's "meme pool" could become dangerously thin. This month's column therefore looks at a few books that can help preserve some hybrid mental vigor.</p><p>The first book, <i>Objects Unencapsulated: Java, Eiffel, and C++?</i>, by Ian Joyner, has its origins in a critique of C++ that Joyner posted to the Web several years ago. After several revisions, that critique has grown into a book that presents itself as a comparison of C++, Java, and Eiffel. It is still most accurately described as a critique, as much of it is devoted to analyzing the shortcomings of C++ and Java from an Eiffel point of view.</p><DDJADVERTISEMENT INLINE><p>Some of Joyner's points are irrelevant, such as the comparison in Chapter 2 of the EBNF notation used to specify Eiffel's syntax with the yacc-like notation commonly used for C++ and Java. Others gave more insight into the author's Eiffelism than they did into the languages themselves. For example, Joyner states that Eiffel has fewer operators than C++ or Java (which is true), then goes on to say that this gives the language a more declarative flavor (which is largely a matter of individual style), and that this in turn leads to programs that are easier to understand. This last statement is an article of faith among some programmers, but until I see an objective, empirical study that substantiates it, it shouldn't be stated as fact.</p><p>Despite these lapses, most of the discussion in <i>Objects Unencapsulated</i> is even handed, and worth at least a few hours of most programmers' time. Many of the programmers I now work with have used only C, C++, or Java, and so are not aware that these languages are particular answers to a set of questions that can be answered in many different ways. What does it mean, for example, to say that two objects are equal? For that matter, what does it mean to say that two things are objects? Eiffel's answers are similar enough to those of C++ and Java to be comprehensible, but different enough to be educational.</p><p>The second book is a collection called <i>The Logic Programming Paradigm: A 25-Year Perspective</i>, edited by Krzysztof R. Apt, Victor W. Marek, Mirek Truszczynski, and David S. Warren. Its 19 articles are divided into nine sections: "Concurrent and Agent Programming," "Program Analysis and Methodology," "Future of Declarative Programming," "Continuous Mathematics," "Constraints," "Machine Learning," "Answer Set Programming," "Database Systems," and "Natural Language Processing." These titles alone suggest the broad range of problems that Prolog and its descendants have generated, been applied to, or both.</p><p>While some of the articles will be comprehensible only to specialists, others ought to be accessible, and interesting, to any thoughtful software developer. The ideas in Debray's article on link-time optimization, for example, are directly applicable to the Internet world of applets, components, and multilingual applications. "How Enterprises Use Functional Languages, and Why They Don't," on the other hand, is a frank look at why the applicative approach to abstraction and higher level programming has failed to catch on, even though its complementary rival, object orientation, has been wildly successful.</p><p>Next, we have two books by two Brooks. Michael Brooks is the editor and coauthor of <i>Quantum Computing and Communications</i> -- a somewhat breezy and nonmathematical look at a technology that could deliver a second revolution in computing. Quantum mechanics states that the subatomic world is slippery: Electrons and light waves don't have well-defined states, but instead exist as a superposition of many possible states until they are disturbed by observation. Quantum computing is an attempt to use that slipperiness to make otherwise intractable problems tractable. Just to take one example, RSA cryptography is based on the difficulty of finding the prime factors of a large number. Quantum computing could reduce that difficulty exponentially, with obvious implications for electronic security.</p><p>Brooks flies over this territory at a fairly high altitude. Only a little of the underlying mathematics is presented, and even much of that is side-barred. The effect is that of an extended Discovery Channel documentary, which made it just right for my last three-hour delay at Atlanta International.</p><p>The other Brooks is Rodney, an MIT professor who abandoned the top-down approach to robotics that was in favor in the mid-1980s for a bottom-up approach that is closer in both spirit and implementation to the way that simple living systems work. Brooks, whose work was featured in the quirky documentary film <i>Fast, Cheap, and Out of Control</i>, has achieved some notable successes by making robots in which perception and action are tightly coupled. For example, his robotic ants do not "know" how to walk. Instead, each limb knows how to react to the floor underneath it, and the motion of neighboring limbs. The results have proved to be more flexible, and more robust, than many of their more thoughtful counterparts.</p><p>His book reprints eight key papers that trace the evolution of these ideas over 15 years. As with the logic programming collection, some of this material will only be of interest to specialists, but the rest of it should be a fertile source of ideas for programmers developing web bots, interactive game characters, and the like.</p><p>Robot designers aren't the only ones taking a bottom-up, emergent approach to computing: The legal system seems to be dealing with issues raised by the Internet in the same way. A new collection of articles published by the ACM, called <i>Intellectual Property in the Age of Universal Access</i>, examines many aspects of the emerging body of Internet-related law. Of particular interest to me were those articles that highlighted the inconsistencies and ambiguities that are beginning to plague online commerce and privacy, and Ned Kock's story of a case of academic plagiarism. Having been plagiarized online myself several years ago, I can sympathize with his frustration with professional organizations that encourage scientists to report their research on the Web, but do nothing more than mumble when others abuse that altruism.</p><p>Mutation is one of the forces that drives evolution, but crossover is equally important. Robert Muller's <i>Database Design for Smarties</i> is a prime example, and its subtitle, "Using UML for Data Modeling," is a succinct summary of what the book covers. In 13 chapters, Muller gives a practical introduction to the Unified Modeling Language (UML), and shows how it can be used to analyze database requirements in an object-oriented fashion, even if relational technology is then used for the actual implementation. The book is well edited, and has enough sample code and platform-specific detail to keep it well grounded.</p><p>Unfortunately, as fast as authors like Muller write good books, other authors write bad ones, such as Dennis Smith's <i>Designing Maintainable Software</i>. I ordered this book based on its title, and actually agree with the author's central thesis. Smith argues that comprehensibility is the key to maintainability, and that software developers have to take human cognition into account if their successors are to be able to understand and modify their creations. However, Smith's presentation is so disjointed that I often had to work hard to see (much less understand) the connection between successive sections. At the same time, some parts of the book, such as the one-page appendix titled "The Information Age," seem to have come straight out of a 1960s-era issue of <i>Scientific American</i>. I think this is a fascinating subject that deserves a lot of attention, but not of this kind.</p><p>Finally, there is Scott McMahan's <i>Automating Windows with Perl</i>. Once again, I ordered this book based on its title. The first warning I had was the line on page 3 that said, "Welcome to the first book in history that discusses using Perl to automate Windows." I looked up at my shelf, where <i>Learning Perl on Win32 Systems</i> sits next to <i>Windows NT User Administration</i>, and shrugged -- given lead times in the print media, the statement could well have been true when McMahan wrote it. But then, hot on the heels of the claim that "Perl has a logical familiar syntax," I read a disclaimer about array-to-scalar conversion that said, "I'd never remember that in a million years." Along the way, I found that McMahan is still using Perl 4, rather than Perl 5, and that this is the only Perl book I've read in the last two years that didn't take advantage of the "use English" directive to give built-in variables readable names, and...you get the picture. There are a few good ideas and useful scripts in here, but they are lost between digressions about Microsoft (which doesn't even appear in the index), and admissions that the author is not qualified to explain what the modulo operator "%" does, and that in 15 years of programming, he's never found a need for it. I like being able to use Perl on Windows, but I honestly can't think of any potential user of that combination that I would recommend this book to.</p><p><b>DDJ</b></p></body></html>