<html><head><title>Jan00: Algorithm Alley</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Randomized Shuffling</h1><p><i>Dr. Dobb's Journal</i> January 2000</p><h3>By Timothy Rolfe</h3><I>Tim is a visiting associate professor in the Computer Science Department of Eastern Washington University. He can be contacted at rolfet@acm.org.</I><hr><p>Card shuffling is an example of putting a fixed number of items into completely random order. The method used to shuffle cards applies to any programming circumstance where you need to randomize the order of a fixed number of items, including Scrabble tiles, dominoes, standard playing cards, Tarot cards, or lottery numbers, for example.</p><p>You can view this randomization of items as randomizing the permutation of entries in an array. In this article, I'll examine a couple of randomizing algorithms -- one that does not generate all permutations with equal probability, and another that does. Both algorithms are based on working through the array, swapping entries in the process.</p><DDJADVERTISEMENT INLINE><p>The first algorithm focuses on proceeding through the array, randomly positioning the value found in each successive position. With this algorithm, as you proceed through the <i>N</i> positions of the array (source positions), you choose the target position randomly from the <i>N</i> possible positions in the array. The values in the source and target positions are then interchanged. H.M. Deitel and P.J. Deitel refer to this as their "high-performance card shuffling" algorithm in their book <i>C++: How to Program</i> (Prentice-Hall, 1998). In C++, this process looks like <A NAME="re1"><A HREF="0001me1.htm">Example 1</A> (presuming a function or macro <i>Swap (L,R)</i>). At first glance, it appears that this algorithm generates all permutations with equal probability. On examination, however, you can see that this generates <i>N<sup>N</i></sup> rearrangements of elements -- each of the <i>N</i> iterations of the loop positions a value among the <i>N</i> available positions -- even though there are only <i>N!</i> possible permutations of <i>N</i> elements. For each permutation there are a number of ways to generate that permutation -- an average of <i>N<sup>N</sup>/N!</i> ways.</p><p>The second algorithm focuses on choosing a random value for each position in the array. Once the value is placed in that position, the position (and the value) no longer participates in the shuffling. While you could start at either end of the array, the code is simpler if the region for choosing a source value always begins with subscript 0. To do that, you start with the rightmost position in the array as the target and randomly select a source position from the front of the array to that target position. You interchange the values, then treat the array as shortened by one position and do the same thing over again. There are no choices left to be made when the remaining array has a single element. <A NAME="re2"><A HREF="0001me2.htm">Example 2</A> is C++ code that implements this approach. Examination of the structure of this loop shows that it generates <i>N!</i> rearrangements of elements. All permutations are equally likely, aside from the minor deviation from uniform distribution by selecting a random value between 0 and <i>Dest</i> as <i>(rand()%(Dest+1)</i>).</p><p>A natural question is "How far from the uniform distribution are the permutations from the <i>N<sup>N</i></sup> algorithm discussed first?" To answer this, I'll develop a method of numbering permutations. Then all of the permutations generated by the <i>N<sup>N</i></sup> algorithm can be generated and counted. Since, in a permutation, each position has one fewer choice than the one before it, you can borrow from programming the notion of a multidimensional array, with dimensions: [<i>N</i>] [<i>N</i>-1] [<i>N</i>-2]...[3] [2] [1].</p><p>You can then map subscripts for such an <i>N-</i>dimensional array onto a one- dimensional offset. Each permutation can then be viewed as <i>N</i> times selecting elements from those remaining (as selecting from position [0], [1], and so on). At first, there are <i>N</i> elements to choose from, then (<i>N</i>-1), then (<i>N</i>-2), down to 1. Viewed as subscripts in an <i>N</i>-dimensional array, these positions of elements chosen will generate offsets (permutation indices) between 0 and (<i>N!</i>-1). A further advantage of the numbering is that, if the original permutation is in increasing order, it numbers the permutations in lexicographic order; that is, something like alphabetical or dictionary order. Thus the permutation with all elements in ascending order is numbered "0," while the permutation with all elements in descending order is numbered "<i>N!</i>-1."</p><p><A NAME="rf1"><A HREF="0001mf1.htm">Figure 1</A> illustrates how, in the permutation of eight elements, the 8<sup><i>8</i></sup>(16777216) rearrangements from the first algorithm map onto the 8<i>!</i> (40320) possible permutations. The file mapperms.cpp (available electronically; see "Resource Center," page 5) implements this process. <A NAME="rt1"><A HREF="0001mt1.htm">Table 1</A> shows that there are some individual permutations that are markedly more likely than others. While most appear to cluster between 200 and 600, the pattern is by no means random. Applying a moving average to these data, you can show some underlying regularities in the data, again indicating that the data are far from random. In <A NAME="rf2"><A HREF="0001mf2.htm">Figure 2</A>, a moving window of about 0.5 percent of all the data is applied (201 cells averaged and assigned to the central point). Another way that you can get a feel for the distribution is by sorting those 40320 data points; see <A NAME="rf3"><A HREF="0001mf3.htm">Figure 3</A>. </p><p>Another approach is to investigate, in the mapping of these <i>N<sup>N</i></sup> reorderings onto the <i>N!</i> permutations, the probability (fraction of the total) for each position in the initial string to end up in each position in the shuffled string. <A NAME="rt2"><A HREF="0001mt2.htm">Table 2</A> shows those probabilities. In it, each column and each row totals to 100 percent. Down the columns, each position contains one of the eight available characters. Across the rows, each character shows up on one of the eight positions. The first character in the source string shows equal probability of ending up in all eight positions of the rearranged string, while all other characters in the source string show varying probabilities for their positions in the rearranged string.</p><p>Also, you see that only the final position in the rearranged string has an equal probability of receiving all of the characters of the source string. <A NAME="rf4"><A HREF="0001mf4.htm">Figure 4</A> displays <A NAME="rt2"><A HREF="0001mt2.htm">Table 2</A> with the eight series taken from the rows.</p><h3>Acknowledgment</h3><p>Thanks to Dr. Ray Hamel of the Eastern Washington University Computer Science Department for his comments, specifically for the idea of examining the relationships between the initial and final positions of items in the rearrangements.</p><p></p><p><b>DDJ</b></p></body></html>