<html><head><title>Jan00: Programmer's Toolchest</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Examining PerlCOM</h1><p><i>Dr. Dobb's Journal</i> January 2000</p><h2>Perl meets Microsoft's COM</h2><h3>By Mike McMillan</h3><I>Mike is an instructor of computer science at Pulaski Technical College, contract programmer, and author of Perl From the Ground Up (Osborne, 1999). You can contact Mike at mmcm@swbell.net.</I><hr><p>When O'Reilly &amp; Associates released its Perl Resource Kit for Win32, it did more than just put the Perl language into a shrinkwrap package -- it also provided programmers with a new set of tools that extend the already powerful Perl language. One of the most interesting tools is PerlCOM, which lets you use Perl in any language or application that supports Microsoft Component Object Model (COM) objects. In this article, I'll describe the PerlCOM component and show you how to use it to extend Visual Basic to include features such as a regular expression engine and the ability to access Perl modules from within Visual Basic. The Perl community has created a useful set of modules that extend Perl to do things such as network programming, text manipulation, and editing the Registry. Using PerlCOM, you can create an instance of a Perl module and use Visual Basic to access the module's methods and properties. Programming with PerlCOM provides you an alternative to the Windows API or other libraries. PerlCOM can also be used with DCOM to provide distributed access to Perl.</p><h3>Introducing PerlCOM </h3><p>PerlCOM is a component that puts a wrapper around a single Perl interpreter. Using the PerlCOM object (PerlCOM.Script), you can execute Perl code from within an application or a development environment such as Visual Basic. You can create and execute Perl functions, as well as create Perl variables and access them using the host language. You can also work with Perl modules. If you are working in a distributed environment, PerlCOM works with DCOM as well as COM, meaning that if you have Perl and the PerlCOM DLL loaded on a server, any client on the network can access and run Perl code from the server.</p><DDJADVERTISEMENT INLINE><p>The first step in using PerlCOM is to create an ActiveX object using the Visual Basic <i>CreateObject</i> function:</p><blockquote><p>Dim objPerl As Object</p><p>Set objPerl = CreateObject("PerlCOM.Script")</p></blockquote><p>The named object, <i>objPerl</i>, is now bound to a single instance of the Perl interpreter through the common name for the PerlCOM DLL, PerlCOM.Script. With the object defined and bound, you can now execute Perl code using the <i>EvalScript</i> method. This first example simply declares a scalar variable and assigns a value to it:</p><blockquote><p>objPerl.EvalScript "$greet = 'Hello, world.\n' ;"</p></blockquote><p>To access this newly created variable, you have to treat it as a property of the PerlCOM object it is defined under, like this:</p><blockquote><p>MsgBox objPerl.greet</p><p>objPerl.greet = "Hello, gentle reader."</p></blockquote><p>The first line displays the greeting "Hello, world." in a message box, and the second changes the greeting to another string. The second line of code is interesting because you are taking a variable created with Perl code and changing its value using Visual Basic code. The initial value of the variable doesn't have to be set under Perl, though the variable does have to be initialized, like this:</p><blockquote><p>objPerl.EvalScript "$greet="</p><p>objPerl.greet = "Hello, world."</p></blockquote><p>You can also create a Perl function using the <i>EvalScript</i> method, then run it from within Visual Basic as a method of the PerlCOM object. <A NAME="rl1"><A HREF="#l1">Listing One</A> displays a greeting in a message box. The name of the Perl function created with <i>EvalScript</i> is <i>my_greet</i>. The <i>shift</i> operator is used to pull the function argument in as the value of the scalar variable <i>$name</i>. The term <i>qq</i> is a quote operator that puts double quotes around its argument, which in <A NAME="rl1"><A HREF="#l1">Listing One</A> is bracketed so that the whole expression is double quoted. Finally, because Perl does variable interpolation, the <i>$name</i> variable is combined with the word "Hello" to display a personalized greeting.</p><h3>PerlCOM Arrays</h3><p>Perl is often used to process lists of data using array data structures. Returning an array from Perl to be evaluated in Visual Basic is straightforward. After you have built an array in Perl, simply return a reference to the array (such as <i>\@array</i> instead of just <i>@array</i>) and Visual Basic will convert it to a Basic array.</p><p><A NAME="rl2"><A HREF="#l2">Listing Two</A> creates a Perl function that splits a string into an array. The array is then passed as a reference to Visual Basic, where the array is built back into a string and displayed element by element in a message box. </p><h3>Using PerlCOM::Hash</h3><p>A hash is an associative array that organizes data into key/value pairs. This data structure is called a "hash" due to the underlying algorithm (the hash table) that is used to implement it. <A NAME="rl3"><A HREF="#l3">Listing Three</A>, which demonstrates how a simple hash is created in Perl, displays the name "L. Wall." </p><p>This associative structure can be built using PerlCOM in two ways. One way is to write a function in Perl that returns a reference to a hash, and evaluate the code using the <i>EvalScript</i> function; see <A NAME="rl4"><A HREF="#l4">Listing Four</A>. The code evaluated by the <i>EvalScript</i> function creates the hash using the same code as I used in the aforementioned Perl example. After the hash is created, a Visual Basic hash object is created and is assigned the hash by calling the <i>build_ hash</i> property. Finally, a value is returned and displayed in a message box by calling the <i>Get</i> property. This property takes a hash key and returns its associated value. </p><p>It is also possible to create a hash without actually writing any Perl code. The <i>CreateHash</i> function returns a hash object and then allows you to define each key as a property of the object and the key's associated value can be assigned to the property. <A NAME="rl5"><A HREF="#l5">Listing Five</A> creates the Wizards hash using this technique.</p><p>Another way to assign a key and value to a hash is to use the <i>Set</i> method, which takes the key and the value as quoted arguments, like this:</p><blockquote><p>objWizards.Set "Fortran", "J. Backus"</p></blockquote><p>The first element is the key and the second one is the value that is returned by the key.</p><p>While you will often want to work with a hash by retrieving a value from a key reference, there are also times when you will want to work with the whole key/value pair. PerlCOM provides a useful method for returning this data pair -- the <i>Each()</i> method. This method returns the key/value pair as array items, with the key being the <i>0</i>th element and the value being the <i>1</i>st element. The most common use of the <i>Each()</i> method is to iterate through a hash, performing some operation or set of operations on each key/value pair. <A NAME="rl6"><A HREF="#l6">Listing Six</A> loops through the Wizards hash, displaying each key/value pair in a listbox. This produces output such as:</p><blockquote><p>Java =&gt; J. Gosling</p><p>Perl =&gt; L. Wall</p><p>Fortran =&gt; J. Backus</p></blockquote><p>When the <i>Each() </i>method is called, the key/value pair is stored in the array elements <i>arrayPair(0)</i> and <i>arrayPair(1)</i>. When the hash is out of data, the method will return a null list, and the variable will be empty. While the variable <i>arrayPair</i> is not initialized as an array, the <i>Each()</i> method still stores the contents of each key and value as an array element. This behavior matches the Perl function <i>each</i>, which returns the key/value pair of a hash as a list. </p><h3>PerlCOM and Perl Modules</h3><p>Perl modules extend the functionality of Perl by providing libraries for performing operations that aren't possible using just plain Perl. There are modules for working with files, working with the Internet, working with the Registry, and just about every standard and esoteric computational function you can imagine. PerlCOM gives you access to these modules through the <i>UsePackage</i> method and the <i>CreateObject</i> method that I've already looked at. If the Perl module you want to use is a collection of functions, you will use the <i>UsePackage</i> method. However, if the module you want to use consists of class definitions that can be instantiated into objects, then you will use the <i>CreateObject</i> method. </p><p>When the module you want to import is made up of standard Perl functions, you use the <i>UsePackage</i> method to import the functions into Visual Basic. To illustrate how to use this method with PerlCOM, I'll examine the Win32.pm module, which imports a group of functions that provide information about the current Win32 operating environment and perform various operations on Win32 machines, such as system shutdowns and registering and unregistering ActiveX/COM servers.</p><p>Once a PerlCOM object is created, you simply call the <i>UsePackage</i> method with the name of the module you want to import; see <A NAME="rl7"><A HREF="#l7">Listing Seven</A>. All of the module's functions are now imported into Visual Basic and can be called as properties of the PerlCOM object. <A NAME="rl8"><A HREF="#l8">Listing Eight</A> gets the local user name and computer name from a Win32 machine and displays them.</p><p>When you use a module that is made up of class definitions, you use the <i>CreateObject</i> method to import the module into your Visual Basic program. For example, the <i>FileHandle</i> module provides a set of methods and properties that make it easy to work with files in Perl. This module is object oriented and must be imported with PerlCOM via the <i>CreateObject</i> method. <A NAME="rl9"><A HREF="#l9">Listing Nine</A> creates a new instance of a <i>FileHandle</i> object.</p><p>The <i>FileHandle</i> module's properties can now be called as properties of the <i>objFileHdl</i>, the new <i>FileHandle</i> object. <A NAME="rl10"><A HREF="#l10">Listing Ten</A> uses the <i>FileHandle</i> method to get lines from a text file and make a text substitution in each line when a particular string is found. This code demonstrates how to do pattern substitutions with Perl in Visual Basic. The purpose of <A NAME="rl10"><A HREF="#l10">Listing Ten</A> is to find each instance of the substring <i>dp</i> in the given text file and change the substring to <i>cis</i>. This is done quite easily in Perl by doing a pattern substitution of <i>cis</i> for each occurrence of <i>dp</i> (the regular expression s/dp/cis) and reassigning it to the line of text using Perl's binding operator (=~). However, to do this, you first create a Perl variable so that you can store data in it. This is done by creating an empty variable using the <i>EvalScript</i> method. The data is grabbed from the text file using the <i>getline</i> method from the <i>FileHandle</i> module. Finally, each line of the text file is displayed in a listbox with the new text substituted if a pattern match is found. </p><h3>Conclusion</h3><p>The goal of PerlCOM is to expose a Perl interpreter that can be invoked from within another COM-aware programming language or application. The examples I've shown here were written within the Visual Basic environment, but I could have also shown you how to use PerlCOM from within Microsoft Word or Excel, Delphi, or even PowerBuilder. Most importantly, PerlCOM lets you use the power and flexibility of Perl in other environments that may not be quite as powerful or flexible. As the Visual Basic family of languages -- Visual Basic, Visual Basic for Applications, Visual Basic Scripting Edition -- mature and develop, they will undoubtedly gain some of the power and flexibility of Perl. </p><p>In fact, just in the past few months I have been exploring PerlCOM, the 5.0 Version of Visual Basic Scripting Edition includes a regular-expression engine and more hooks into the operating system. Still, it will be hard for Microsoft to match in number or usefulness the modules that have been and are being created for the Win32 version of Perl. For the foreseeable future, it will be advantageous for you to explore and use PerlCOM as an efficient way to extend the Visual Basic environment.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>objPerl.EvalScript " sub my_greet { "   &amp; _                   "    my $name = shift; "     &amp; _                   "    return qq[Hello, $name.]; } "strName = "Charlie"MsgBox objPerl.my_greet(strName)</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>Dim objPerl As ObjectSet objPerl = CreateObject("PerlCOM.Script")objPerl.EvalScript (" sub str_split { " &amp; _                    "  $string = 'Perl,C,Java,C++';" &amp; _                    "  my @languages = split(/,/, $string);" &amp; _                    "  return \@languages; } ")arrayLangs = objPerl.str_split()strLangs = ""For x = 0 To UBound(arrayLangs)   strLangs = strLangs &amp; arrayLangs(x) &amp; Chr(13) &amp; Chr(10)Next xMsgBox strLangs</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>My %wizards = (   C     =&gt; 'D. Ritchie',   Java =&gt; 'J. Gosling',   Perl =&gt; 'L. Wall',);print $wizards{"Perl"} </pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>Dim objPerl As ObjectSet objPerl = CreateObject("PerlCOM.Script")objPerl.EvalScript _    " sub build_hash { " &amp; _    "    my %wizards = ( 'C'    =&gt; 'D. Ritchie', " &amp; _    "                    'Java' =&gt; 'J. Gosling', " &amp; _    "                    'Perl' =&gt; 'L. Wall'); " &amp; _    "    return \%wizards } "Dim oHash As ObjectSet oHash = objPerl.build_hashMsgBox oHash.Get("Perl")</pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five</H4><pre>Dim objPerl As ObjectSet objPerl = CreateObject("PerlCOM.Script")Set objWizards = objPerl.CreateHashobjWizards.C = "D. Ritchie"objWizards.Java = "J. Gosling"objWizards.Perl = "L. Wall"MsgBox objWizards.Get("Java")</pre><P><A HREF="#rl5">Back to Article</A></P><H4><A NAME="l6">Listing Six</H4><pre>Dim objHash As ObjectDim arrayPair Set objHash = objPerl.CreateHashobjHash.C = "D. Ritchie"objHash.Java = "J. Gosling"objHash.Perl = "L. Wall"objHash.Set "Fortran", "J. Backus"arrayPair = objHash.Each()Do While (Not IsEmpty(arrayPair))   List1.AddItem arrayPair(0) &amp; " =&gt; " &amp; arrayPair(1)   arrayPair = objHash.Each()Loop</pre><P><A HREF="#rl6">Back to Article</A></P><H4><A NAME="l7">Listing Seven</H4><pre>Dim objPerl As ObjectSet objPerl = CreateObject("PerlCOM.Script")Set objWin32 = objPerl.UsePackage("Win32")</pre><P><A HREF="#rl7">Back to Article</A></P><H4><A NAME="l8">Listing Eight</H4><pre>strUserName = objWin32.LoginNamestrComputerName = objWin32.NodeNamestrInfo = "User name: " &amp; strUserName &amp; Chr(13) &amp; Chr(10)strInfo = strInfo &amp; "Computer name: " &amp; strComputerNameMsgBox strInfo, , "User Information"</pre><P><A HREF="#rl8">Back to Article</A></P><H4><A NAME="l9">Listing Nine</H4><pre>Dim objPerl As ObjectSet objPerl = CreateObject("PerlCOM.Script")Set objFileHdl = objPerl.CreateObject("FileHandle", "new")</pre><P><A HREF="#rl9">Back to Article</A></P><H4><A NAME="l10">Listing Ten</H4><pre>strFileName = "c:\sample.txt"If objFileHdl.open(strFileName) = 1 Then   For x = 1 To 4      objPerl.EvalScript "$dept = '';"      objPerl.dept = objFileHdl.getline      objPerl.EvalScript "$dept =~ s/dp/cis/;"      List1.AddItem objPerl.dept   Next x   objFileHdl.CloseEnd If</pre><P><A HREF="#rl10">Back to Article</A></P></body></html>