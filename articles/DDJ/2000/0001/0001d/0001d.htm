<html><head><title>Jan00: Python Server Pages: Part I</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Python Server Pages: Part I</h1><p><i>Dr. Dobb's Journal</i> January 2000</p><h2>A portable ASP-like server-side  scripting engine</h2><h3>By Kirby W. Angell</h3><I>Kirby is a Microsoft Certified Software Developer and a contributing author to the Quick Python Book (Manning, 1999). He can be contacted at kwangell@hotmail.com.</I><hr><p>Python Server Pages (PSP) constitute a server-side scripting engine designed along the lines of Microsoft's Active Server Pages (ASP) and Sun's Java Server Pages (JSP) specification. The major difference between ASP and PSP is that PSP is written in 100 percent Java and is, therefore, portable to a wide variety of platforms. Web applications written in ASP, on the other hand, can be run only on Microsoft platforms. Compared to JSP, PSP uses JPython as its scripting language, which seems more appropriate for scripting web sites than the Java (a systems language) used in JSP.</p><p>One benefit of using PSP is the huge number of add-on modules available for Python and JPython (both available at http://www.python.org/). With PSP, you can access any module that is compatible with JPython from within your PSP application's pages. And because JPython is itself written in Java, you can access Java packages from PSP applications as well. Since creating PSP, I've deployed it in several intranet sites, and it is currently being evaluated for commercial viability in Internet e-commerce and portal sites. </p><DDJADVERTISEMENT INLINE><p>In the first installment of this two-part article, I'll present PSP. In the next installment, I'll examine PSP's Java servlet code, which contains everything to compile and execute the JPython code in response to a request from a user. PSP source code and related files are available electronically at http://www.ciobriefings .com/psp/, or from <i>DDJ</i> (see "Resource Center," page 5). </p><h3>A Developer's Perspective</h3><p>HelloWorld.psp (see <A NAME="rl1"><A HREF="#l1">Listing One</A>) is a PSP implementation of the familiar "Hello World" program. As you can see, it looks similar to Microsoft's Active Server Pages (ASP) and VBScript. All that this simple page (see <A NAME="rf1"><A HREF="0001df1.htm">Figure 1</A>) does is display a user's IP address to prove that a server-side scripting engine processed the page. </p><p>There are four things you should notice about the HelloWorld.psp:</p><ul>  <li>Like ASP, HTML and server-side scripts are mixed throughout the file.  <li>Instead of the ASP script markers &lt;% and %&gt;, PSP uses $[ and ]$.  <li>PSP, like ASP, provides an <i>include</i> call to import other scripts into the current script.  <li>PSP provides an ASP-like object model including the <i>Request</i> object.</ul><p>One thing that attracted me to web programming in the first place was the ability to use server-side scripting from within my HTML pages. I generally use a tool such as FrontPage to create an initial page design, then rename the file and begin inserting script statements to customize the page. It was important for my development team that I replicate the paradigm they were used to in the Windows NT/IIS environment even when deploying to Solaris. PSP does this by assuming that the contents of the page will be sent directly to the user's web browser. PSP only interferes with the page when it comes across its script markers.</p><p>Still, I made the script markers for PSP different than those of ASP because I didn't want someone to confuse PSP pages with ASP/VBScript pages. This was short sighted. It turns out there is a Python add-on called "win32all" (http://www.python .org/windows/win32all/) that plugs a Python interpreter into ASP. If I had used the ASP script markers, my PSP-based applications might have been portable to ASP. </p><p>Like ASP, PSP provides <i>Request</i>, <i>Response</i>, <i>Session</i>, and <i>Server</i> objects that scripts can use to find out about and interact with their HTTP environment. In HelloWorld.psp, the <i>Request</i> object's server dictionary is queried to determine the user's IP address. Although the objects are most likely familiar to you, they have been "Pythonized" so they have a Python feel. For instance, data such as form variables and server parameters are implemented as Python dictionaries instead of Visual Basic-like collections.</p><p><A NAME="rf2"><A HREF="0001df2.htm">Figure 2</A> illustrates the general architecture of PSP. What made this solution suitable for me was that everything runs inside of the Java Virtual Machine. As long as I stay away from any Java VM idiosyncrasies, I shouldn't have any problems deploying Windows NT on those projects that required it, and then on Solaris later on. Eventually, I did have problems moving the final application from Windows NT to Solaris, but it wasn't because of Python Server Pages. </p><p>The enabling technology here is JPython, Jim Hugunin's Java implementation of the Python language (for more information, see my article "Examining JPython," <i>DDJ</i>, April 1999). Python offers many benefits over a lot of other scripting languages. In this situation, Python's ability to compile code on-the-fly was vital. With this feature, PSP can take a page that is a combination of HTML and Python, turn it into a series of Java bytecodes, and execute it inside the JVM. In general, here is what happens inside of PSP when users request a web page:</p><p>1. Text is read from a .PSP file.</p><p>2. The file is converted to a syntactically correct Python module.</p><p>3. The Python module is compiled by the JPython built-in <i>compile</i> method.</p><p>4. The compiled method is executed.</p><p></p><p>The PSP servlet employs caching to improve performance and implements some other features that make it more usable; however, most of the application is concentrated in the Java Servlet that processes requests from the web server. However, one of the hardest parts to write was the code generator used in step 2.</p><h3>Web Page to Python Code</h3><p>I prototyped the code generator in JPython. Eventually, I would like to rewrite the generator in Java, but the current code is working remarkably well. <A NAME="rl3"><A HREF="#l3">Listing Three</A> is an abbreviated version of <i>cgEngine</i> (the code generator class) and related classes. <i>cgEngine</i> is designed to work in a variety of situations other than HTML generation. I have removed some of that support code to concentrate on the parts that are important to PSP.</p><p>Again, the code generator turns hybrid HTML/Python files into compatible Python code. <A NAME="rl2"><A HREF="#l2">Listing Two</A> is the output from the code generator for the HelloWorld.psp page. I've deleted the lines relating to Banner.psp for now, but I'll address them in Part 2 of this article. All that has really happened is that Python statements to output the HTML have replaced the HTML lines. Any Python expressions embedded within the HTML are blended into the final Python statement. </p><p>The <i>__convertToPython</i> method of <i>cgEngine</i> is basically a filter function that processes an input file (the unadulterated PSP page) into an output file (a Python module). To do this, the method reads a line of input, then converts it to Python by calling the <i>parseLine</i> method. </p><p>The <i>cgEngine</i> class implements a state machine to keep track of what is going on within the input file. <i>parseLine</i> is the primary processing method for this engine and controls the state of <i>cgEngine</i>. The method processes the given line into a series of tokens; either <i>Text</i> or <i>Expression</i>. The state machine starts out expecting normal, nonPython text and converts any such text it finds into a <i>Text</i> object. When the script prefix ($[) is encountered, the state changes and any text found is wrapped by an <i>Expression</i> object. If the <i>parseLine</i> method is processing an expression and finds the script postfix (]$), the state shifts back to processing normal text. What to do inside the state is relatively easy; the hard part is finding out when to change states. <i>cgEngine</i> actually had to have four states instead of the two I mentioned; of course, it took some experimentation to figure this out. <A NAME="rf3"><A HREF="0001df3.htm">Figure 3</A> shows the states I eventually identified and how <i>parseLine</i> progresses from one state to the next.</p><p>After <i>parseLine</i> builds a list of the tokens it found in the input line of text, <i>__convertToPython</i> uses that information to output a valid line of Python code. If <i>parseLine</i> returns a list of tokens that contain only normal text, <i>__convertToPython</i> has a simple job to do. It merely wraps the line in a <i>__write__</i> statement and puts it into the output file. If the line contains only a Python expression, it is simply written to the output file as well. Some more complex processing goes on if the tokens contain Python expressions and normal text. Near the end of <i>__convertToPython</i>, the method iterates through each token, converting <i>Text</i> tokens into Python expressions and integrating the existing <i>Expression</i> objects. Again, the line is wrapped up into a <i>__write__</i> statement and written to the file. </p><p>The use of the <i>__write__</i> statement bears some explaining. Originally, I used the Python standard <i>print</i> method to write out the processed text. Using the old method, the first line in <A NAME="rl3"><A HREF="#l3">Listing Three</A> would have looked like: <i>print "&lt;HTML&gt;"</i>.</p><p>When JPython executed this code, the output was sent to the standard output device. My applications that used this code generator would have to redirect the standard output device, execute the code, and restore standard output to its previous value. Now, the application that executes the code produced by the code generator provides a <i>__write__</i> method that is called by the executing code. The method can do anything it wants to with the data; PSP writes the output to the HTTP response output stream. This turned out to be a poor design decision. <A NAME="rl4"><A HREF="#l4">Listing Four</A> contains a PSP page that outputs everything the page knows about the current request. To do this, a <i>for</i> loop is used to iterate through the list of request variables and each one is sent to the output stream. Python does not use a statement of any kind to terminate blocks of code, such as loops. Python uses a trailing colon to indicate the start of a block and indentation to control the contents of the block. For instance, a simple <i>for</i> loop might look like:</p><blockquote><p>for x in Range(1,10):</p><p> x = x + 1</p><p>print x</p></blockquote><p>The <i>x=x+1</i> line is in the loop, the <i>print</i> statement is not. While outputting statements, the code generator has to make sure that the Python statements are set to the proper indentation level. You can see this in <A NAME="rl5"><A HREF="#l5">Listing Five</A> when the loop is writing each HTML table row. It's easy enough to look for the colon at the end of a line to know that it is time to increase the indentation level. It's not so easy to know when to decrease the indentation level. My solution was to introduce a statement that could be used to terminate blocks of code. When the level increases, <i>__convertToPython</i> outputs an additional TAB character to indent the code to a new level. When the level decreases through an <i>end block</i> statement, the TAB character is removed.</p><p>A regular contributor to the JPython mailing list, Jason Orendorff, pointed out that this could be a problem (he also suggested the <i>__write__</i> method used earlier). The problem is that Python doesn't care how the code gets indented. I typically use all TABs to indent code, but spaces would work just as well. Worse yet, you only need to be consistent within the block of code. You could indent one block with spaces and the next with TABs. My solution forces all PSP pages to use TABs for indentation; not a huge problem, but it is an unnecessary restriction. </p><h3>PSP Installation</h3><p>PSP is distributed in a single .ZIP file that contains the Java Servlet and Python-based code generator. Before installing PSP, you need to install JPython and ensure that your web server supports Java servlets. If your server does not support servlets, I recommend the JRun Servlet engine from Live Software (http://www .livesoftware .com/). It provides servlet support for Microsoft Internet Information Server, Apache, and Netscape and I've tried it successfully on Windows NT, Linux, and Solaris.</p><p>Your servlet engine will need to be configured to load the JPython package and point to the directory where the PSP code resides. The servlet engine can be configured to pass any files that have a .PSP extension to the PSP servlet. Finally, JPython must be configured to load the code generator by copying the directory containing the code generator to your JPython/lib directory.</p><p>Some day the PSP distribution will contain the ubiquitous InstallShield for Java; until then, it is installation the hard way.</p><h3>Conclusion</h3><p>Although PSP was not so much designed as evolved, there are some aspects of its design that trouble me. Nonetheless, I've used it to implement several intranet applications and it has been trouble free so far.</p><p>In the next installment of this two-part article, I'll delve into the Java servlet code. This servlet started out as a simple class to read a PSP page, execute the page, and return the results to the user. This design eventually ballooned to 19 classes supporting page caching, application space, <i>Request</i> and <i>Response</i> objects, and many other features. </p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Hello World&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;$[include banner.psp]$&lt;H1&gt;Hello World&lt;/H1&gt;&lt;BR&gt;$[Response.write( "Hello, %s, from Python Server                                 Pages." % (Request.server["REMOTE_ADDR"]))]$&lt;BR&gt;If your IP address was in the greeting above, you have                               installed Python Server Pages correctly.&lt;/BODY&gt;&lt;/HTML&gt;</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>__write__(  "&lt;HTML&gt;" )__write__(  "&lt;HEAD&gt;" )__write__(  "&lt;TITLE&gt;Hello World&lt;/TITLE&gt;" )__write__(  "&lt;/HEAD&gt;" )__write__(  "&lt;BODY&gt;" ) ... statements included from banner.psp deleted ...__write__(  "&lt;H1&gt;Hello World&lt;/H1&gt;" )__write__(  "&lt;BR&gt;" )Response.write( "Hello, %s,              from Python Server Pages." % (Request.server["REMOTE_ADDR"]))__write__(  "&lt;BR&gt;" )__write__(  "If your IP address was in the greeting above, you have                                 installed Python Server Pages correctly." )__write__(  "&lt;/BODY&gt;" )__write__(  "&lt;/HTML&gt;" )__write__(  "" )</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>class cgEngine:    # These constants are used to keep track of the state of the parser.    stNormal = 0    stFoundScriptPrefix1 = 1    stScriptOpen = 2    stFoundScriptPostfix1 = 3    def parseLine( self, inBuf ):        """Parses a text string into a list of tokens. Each token is either         a block of text or a python expression. Classes Text and Expression         are used to hold the text blocks and Python expressions. """        tokens = []        output = Text()        expression = Expression()        nPos = 0                                while nPos &lt; len(inBuf):            char = inBuf[nPos]            if char == '$':                if self.state == cgEngine.stNormal:                    self.state = cgEngine.stFoundScriptPrefix1                elif self.state == cgEngine.stFoundScriptPostfix1:                    self.state = cgEngine.stNormal                    tokens.append( expression )                    expression = Expression()                elif self.state == cgEngine.stFoundScriptPrefix1:                    output.append( "$" )                elif self.state == cgEngine.stScriptOpen:                    expression.append( char )                else:                    output.append( char )            elif char == '[':                if self.state == cgEngine.stFoundScriptPrefix1:                    self.state = cgEngine.stScriptOpen                   expression = Expression()                    if output.empty() == 0:                        tokens.append(output)                        output = Text()                elif self.state == cgEngine.stScriptOpen:                    expression.append( char )                else:                    output.append( char )            elif char == ']':                if self.state == cgEngine.stScriptOpen:                    self.state = cgEngine.stFoundScriptPostfix1                elif self.state == cgEngine.stFoundScriptPostfix1:                    expression.append( "]" )                else:                    output.append(char)            else:                if self.state == cgEngine.stScriptOpen and char != '\n':                    expression.append( char )                elif self.state == cgEngine.stFoundScriptPrefix1:                    self.state = cgEngine.stNormal                    output.append("$")                    output.append(char)                elif self.state == cgEngine.stFoundScriptPostfix1:                    self.state = cgEngine.stScriptOpen                    expression.append("]")                    expression.append(char)                elif char != '\n':                    output.append(char)            nPos = nPos + 1        # if there is some output left        if output.empty() == 0:            tokens.append( output )        # if there is an expression        if expression.empty() == 0:            tokens.append( expression )        # if there are no tokens, this must be a blank line        if len(tokens) == 0 and self.state != cgEngine.stScriptOpen:            tokens.append( Text() )        return tokens    # convertToPython    # Processes the input file, converting all script expressions into    # python code and other text into print statements    def __convertToPython( self, inFile, outFile, tabIndent = 0 ):        inBuf = "spam"        self.state = cgEngine.stNormal        while len(inBuf):            inBuf = inFile.readline()            tokens = self.parseLine( inBuf )            # find out if this is only a script line, or contains some output            printLine = 0            for token in tokens:                if token.__class__ == Text:                    printLine = 1                    break            # Write out this line of output            outBuff = Text()            if printLine == 0 and len(tokens):                s = string.strip( str(tokens[0]) )                if len(s) and s[len(s)-1] == ":" and s[0] != "#":                    tabIndent = tabIndent + 1                elif "end block" == string.lower(s):                    tabIndent = tabIndent - 1                    if tabIndent &lt; 0:                         tabIndent = 0                    tokens[0] = Expression("#" + self.indent(tabIndent) + s)                elif string.lower(s)[:8] == "include ":                    stmt,name = string.split( s, " ", 1 )                    path,inFileName = os.path.split( inFile.name )                    if len(path) == 0:                        newInFile = open( name, "r" )                    else:                        newInFile = open( path + os.sep + name, "r" )                    self.__convertToPython( newInFile, outFile, tabIndent )                    newInFile.close()                    tokens[0] = Expression("#" + self.indent(tabIndent) + s)            for token in tokens:                if token.__class__ == Text:                    outBuff.append( ' + "' + escapeQuotes(str(token)) + '"' )                    printLine = 1                if token.__class__ == Expression:                    if printLine:                        outBuff.append( ' + str(' + str(token) + ')' )                    else:                       outBuff.append( str(token) )            if printLine:                # Write out the statement, trimming off the leading + sign.                outFile.write( self.indent( tabIndent ) + "__write__( "                                               + str(outBuff)[2:] + " )\n" )            else:                outFile.write( str( outBuff ) + "\n" )class Expression:   "Contains a single python expression fragment parsed from a template file."    def __init__(self, expr = ""):        self.data = expr    def append(self, s):        self.data = self.data + s    def empty(self):        return len(self.data) == 0    def __repr__(self):        return self.dataclass Text:    "Contains a single text fragment parsed from a template file."    def __init__(self):        self.data = ""    def append(self, s):        self.data = self.data + s    def empty(self):        return len(self.data) == 0    def __repr__(self):        return self.data</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;PSP Snoop&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;H1&gt;PSP Snoop&lt;/H1&gt;&lt;BR&gt;&lt;PRE&gt;&lt;H2&gt;Request Headers:&lt;/H2&gt;&lt;table&gt;$[for varName in Request.server.keys():]$    &lt;tr&gt;        &lt;td&gt;$[varName]$&lt;/td&gt;        &lt;td&gt;$[Request.server[varName]]$&lt;/td&gt;    &lt;/tr&gt;$[  end block ]$&lt;/table&gt;&lt;/BODY&gt;&lt;/HTML&gt;</pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five</H4><pre>__write__(  "&lt;HTML&gt;" )__write__(  "&lt;HEAD&gt;" )__write__(  "&lt;TITLE&gt;PSP Snoop&lt;/TITLE&gt;" )__write__(  "&lt;/HEAD&gt;" )__write__(  "&lt;BODY&gt;" )__write__(  "&lt;H1&gt;PSP Snoop&lt;/H1&gt;" )__write__(  "&lt;BR&gt;" )__write__(  "&lt;PRE&gt;" )__write__(  "&lt;H2&gt;Request Headers:&lt;/H2&gt;" )__write__(  "&lt;table&gt;" )for varName in Request.server.keys():    __write__(  "   &lt;tr&gt;" )    __write__(  "       &lt;td&gt;" + str(varName) + "&lt;/td&gt;" )    __write__(  "       &lt;td&gt;" + str(Request.server[varName]) + "&lt;/td&gt;" )    __write__(  "" )    __write__(  "   &lt;/tr&gt;" )#end block__write__(  "&lt;/table&gt;" )__write__(  "&lt;/BODY&gt;" )__write__(  "&lt;/HTML&gt;" )__write__(  "" )</pre><P><A HREF="#rl5">Back to Article</A></P></body></html>