<html><head><title>Dec00: Java Q&A</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>How Can I Extend  Java's Search Capabilities?</h1><p><i>Dr. Dobb's Journal</i> December 2000</p><h3>By Alexandre Pereira Calsavara</h3><I>Alexandre holds a bachelor degree in systems analysis and has extensive experience in embedded systems, C/C++, and Java. He currently works as a contractor and can be contacted at calsavara@ hotmail.com.</I><hr><p>String searching is a basic operation for just about any application. So basic, in fact, that Java (and other languages) have this capability either built-in or included as a standard function. Unless you are using a language such as Perl or JavaScript and need to search for anything other than a simple string, your language's built-in string search capability is usually not enough. This is when regular expressions come into play. </p><p>Regular expressions let you look for sequences of characters that match a given pattern. It is a useful and powerful capability, usually found only in advanced editors for programmers, but many other applications could benefit from it.</p><DDJADVERTISEMENT INLINE><p>In this article, I present a relatively small class that uses regular expressions to add powerful string search capabilities to Java. In addition to implementing regular expression search, I also present a utility similar to the UNIX grep tool to exemplify its use. I chose to use an object-oriented implementation instead of the traditional state table. The result is not as fast as the traditional implementation, but it is easier to understand and maintain and (more importantly) easy to extend or customize.</p><h3>Specifying Patterns</h3><p>Regular expressions are a way to specify patterns to search. The patterns are specified as human readable strings, obeying a given syntax. A pattern can be anything from a simple string (although in this case it would be easier and faster to use the language built-in string search) to a pattern of arbitrary complexity.</p><p>The pattern string is a sequence of tokens, each with a special meaning that says what to match. There are tokens to match any character, a set of characters, a character class (predefined character set), or one character of a set of alternatives. A simple character is represented by itself and there are tokens (escape codes) to represent nonprintable characters.</p><p>Tokens always match just one character, but special operators allow a token to be matched several times (repeated) and tokens can be grouped and nested to be repeated or used as alternatives to match. <A NAME="rt1"><A HREF="0012ot1.htm">Table 1</A> provides a complete list of tokens and <A NAME="rt2"><A HREF="0012ot2.htm">Table 2</A> provides the pattern syntax. <A NAME="rt3"><A HREF="0012ot3.htm">Table 3</A> lists some examples of valid patterns.</p><h3>Pattern Graph</h3><p>My implementation is totally contained in the class <i>jlib.util.RegExp</i> (available electronically; see "Resource Center," page 5). There are a number of auxiliary classes, but they are all private and internal classes. I also use an exception class, <i>jlib.util.SyntaxError</i> (also available electronically) to sign errors in the pattern string.</p><p>The key idea behind my implementation is to represent the pattern string as a graph of nodes. Each node represents what to match and the links between nodes represent the possible alternatives. Once the graph is constructed, finding a match is just a matter of traversing the graph from the starting node until the end node is reached.</p><p>The nodes are instances of the <i>jlib.strucs.RegExp.Node</i> private internal class or one of its subclasses. <A NAME="rt4"><A HREF="0012ot4.htm">Table 4</A> lists all subclasses, what they match, and the corresponding tokens.</p><p>Each class stores internally all information it needs in order to know what to match. For example, the class <i>jlib.strucs .RegExp.Literal</i> stores the character to match in the field <i>pattern, </i>and the class <i>jlib.strucs.RegExp.Set</i> stores the set of the characters to match as an array of character ranges in the field <i>set. </i>It also stores whether the set is negated in the field <i>invert.</i></p><p>The class <i>jlib.strucs.RegExp.Node</i> has just one method, <i>match()</i>, which should be overriden by its subclasses. This method is called by the class <i>jlib.strucs.RegExp</i> when it is traversing the graph in order to match the input string with the pattern. The subclasses can, and should, use the fields of the outer class <i>jlib.strucs.RegExp</i> to get the input string in order to match it with the pattern they represent. <A NAME="rt5"><A HREF="0012ot5.htm">Table 5</A> lists the fields of the outer class <i>jlib.strucs.RegExp,</i> interesting for the subclasses and what they contain when the <i>match()</i> method is called.</p><p>If the input string matches the pattern at the position specified by the <i>index </i>field, the subclass must return <i>true, </i>and update the <i>index </i>field if necessary. <A NAME="rt6"><A HREF="0012ot6.htm">Table 6</A> explains the implementation of each subclass. Notice that the tokens *, +, ?, |, and () do not have corresponding subclasses. This is because these tokens do not match anything by themselves, but they affect the operation of other tokens. They can be implemented by the way the nodes that represent the tokens they operate on are linked. In other words, these tokens are represented by paths (links) in the graph, not by nodes. <A NAME="rf1"><A HREF="0012of1.htm">Figure 1</A> shows how these tokens are represented.</p><h3>Pattern Parsing</h3><p>The pattern graph is built by the pattern parser. The parser builds the graph and checks the pattern syntax at the same time, while it parses the pattern string. If an error is found, an instance of the <i>jlib.util.SyntaxError</i> class is thrown with an appropriate error message. The parser is composed of several methods that resemble the productions presented in <A NAME="rt2"><A HREF="0012ot2.htm">Table 2</A>. <A NAME="rt7"><A HREF="0012ot7.htm">Table 7</A> lists all methods that compose the parser.</p><p>When the parser methods are called, the field <i>expression </i>contains the pattern string and the field <i>index </i>points to the character being parsed. Each method parses the pattern string, updates the field <i>index </i>as needed, and returns a graph representation of what it parsed as an array of two nodes, the graph start, and end nodes. <A NAME="rf2"><A HREF="0012of2.htm">Figure 2</A> shows some pattern string examples and the graph that the parser creates.</p><h3>Pattern Searching</h3><p>The test for a match is done by the private internal method <i>visit()</i>. When it is called, the fields <i>input </i>and <i>index </i>should contain the input string and the position to match, respectively. The <i>visit()</i> method receives as input the node to match with the input string's current position. If a match is found, the field <i>found </i>is set to True<i>.</i></p><p>The method <i>visit() </i>first calls the <i>match() </i>method of the node it received as input. If the method returns False<i>, visit() </i>returns; otherwise, it calls itself recursively with each one of the possible paths. If the node does not link to any other node, that means that it is an ending node of the pattern graph, so <i>visit() </i>sets the field <i>found </i>to True<i> </i>and returns.</p><p>The public method <i>next()</i> searches for a pattern. Starting at the position given by the field <i>index, </i>it calls the <i>visit()</i> method with the pattern graph starting node. If a match is not found, it calls <i>visit()</i> again to try a match at the next position, until a match is found or the end of the input is reached.</p><h3>Using the Class </h3><p>Using the <i>jlib.util.RegExp </i>class is straightforward. First, construct an instance of the <i>jlib.util.RegExp</i> with the pattern string and, optionally, whether you want to take case into account. Once the object is constructed, you can get the pattern string through the <i>getExpression()</i> method and query/set the case sensitiveness of the object using the <i>getCase()</i>/<i>setCase()</i> methods.</p><p>To search for a pattern, call the <i>search()</i> method with an input string and, optionally, an initial position to start searching. The method looks for a match starting at the given position and returns whether a match was found or not. After that, you can call the method <i>next()</i> to search for more matches. Each time <i>next()</i> is called, it looks for a new match starting at the last match found.</p><p>You can also use the method <i>startSearch()</i> to just initialize the object to search. In this case, you must call the <i>next()</i> method later to actually perform the search. After a search is performed, the method <i>found()</i> returns whether a match was found on the last search and the method <i>getInput()</i> returns the input string.</p><p>After a successful search, the method <i>match()</i> returns the substring found and the methods <i>matchBegin()</i> and <i>matchEnd()</i> return the start and end position of the match found in the input string.</p><p>To illustrate the class <i>jlib.util.RegExp</i>, I present a simple utility, JGrep (available electronically), that looks for text inside text files. It is similar to the popular grep tool, hence its name. Execute the class without any option to get a help screen. Notice that the messages and help screen are localized for English and Portuguese through property files. Available electronically are property files for English (the default) and Portuguese.</p><h3>Conclusion</h3><p>The choice of an appropriate solution can be the difference between success and failure. Frequently, complex topics can be turned into straightforward implementations by employing original and simple algorithms and data structures. By using a graph, I made regular expression implementation easier to understand and maintain.</p><p>My implementation also shows the power of object orientation. By using an object-oriented approach, I made regular expressions easy to extend. To create a new token, just change the appropriate parser methods to recognize it and, if needed, subclass <i>jlib.util.RegExp.Node</i> or one of its subclasses.</p><p><b>DDJ</b></p></body></html>