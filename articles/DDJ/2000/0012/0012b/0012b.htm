<html><head><title>Dec00: Porting Across  UNIX and Win32</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Porting Across  UNIX and Win32</h1><p><i>Dr. Dobb's Journal</i> December 2000</p><h2>Knowing system  differences is the trick</h2><h3>By Abdul Sakib Mondal</h3><I>Sakib is a doctoral fellow at the Indian Institute of Management, Calcutta, and is currently working in the Software Concept Laboratory of Infosys Technologies Limited. He can be contacted at abdulsakib@inf.com.</I><hr><p>Even though UNIX and Win32 are the most common desktop operating systems around, applications written for one platform usually do not work on the other. Consequently, thought and effort are needed to port an application from one OS to another. In this article, I'll describe the issues I encountered when porting a load-balancing application, first from Sun OS to Linux, then from Linux to Win32. </p><p>Because of the use of low-level system routines and the high amount of communication, load-balancing software is a good example for examining porting issues. The load-balancing tool I ported is called "XYALB" (see my article "Load Balancing for UNIX and Win32," <i>DDJ</i>, July 2000). </p><DDJADVERTISEMENT INLINE><h3>Porting from Sun OS to Linux</h3><p>Different flavors of UNIX differ at the kernel level. As a result, if an application uses system-level functions, porting becomes difficult. For load measurement, for instance, XYALB uses the Sun OS 4.1.1 <i>kvm </i>routines. Linux, on the other hand, provides neither the <i>kvm </i>routines nor any direct equivalents to them. To implement equivalent routines in Linux, you need to know about process structures in both the systems. </p><p>In Sun OS, the process table is maintained as a linked list; see <A NAME="rf1"><A HREF="0012bf1.htm">Figure 1</A>(c). Each process has an entry in the linked list that contains information such as process ID  (PID) and pointers to <i>u</i>-area, which contain further information about the processes such as open descriptors and signal masks. Descriptors contain information about the type of resource that they refer to (file, pipe, socket) and other associated information, such as permissions. </p><p>For Linux, the process information is kept as an array, see <A NAME="rf1"><A HREF="0012bf1.htm">Figures 1</A>(a) and 1(b), where each entry corresponds to a process. Each process entry (of type <i>task_ struct</i>) contains pointers through which you can obtain further information about resources associated with the process. For example, there is a pointer to a file structure (of type <i>file_struct</i>) that represents files opened by the process. So porting <i>kvm_routine</i> to Linux is basically equivalent to finding out the PID, looking for the <i>task_struct</i> entry corresponding to this process by searching the array of process entries, then looking for the information in the <i>task_struct</i> itself (or following the pointers in <i>task_struct</i>) until you find the desired parameter of the process. How do you know where the desired parameter is? For that, you need to go through the headers linux/sched.h, linux/module.h, and linux/types.h, which help you in identifying the path from the array of <i>task_struct</i> to the desired parameter.</p><p>The process array is accessible through the device /dev/kmem. You need to define __KERNEL__ in your source code to use this device. The <i>task_struct</i> array resides at a specific offset address, available as a value of "task" in /boot/System.map. For example, in my system, it's 0x00111d61f4. </p><p>To get kernel information about a process, <i>kvm_open</i> prepares for reading kernel memory. Subsequently, <i>kvm_proc</i> reads the process structure of the desired process. Once you have read the process structure, you can use <i>kvm_read</i> to read specific information about the process by passing suitable arguments. In Linux, you have to open the /dev/kmem file. Using the returned file descriptor <i>kfd, </i>you can read the content of the symbol table. <A NAME="rl1"><A HREF="#l1">Listing One</A> (findtask) is an equivalent of <i>kvm_getproc</i> that finds the entry for a process. Like <i>kvm_ getproc</i>, <A NAME="rl1"><A HREF="#l1">Listing One</A> reads <i>task_ struct</i>. Structure <i>task_struct</i> has a member PID, which is used to find out whether you have read the <i>task_struct</i> of the intended process. </p><p>Once you've read the process's <i>task_ struct</i>, you can get other properties, such as user and group IDs (<i>readcred</i> in <A NAME="rl1"><A HREF="#l1">Listing One</A>) and groups (<i>readgroups</i> in <A NAME="rl1"><A HREF="#l1">Listing One</A>) from the <i>task_struct</i> itself. For determining files, sockets, pipes opened by the process, and their properties, you need to follow the appropriate pointers (see <i>readfile</i> in <A NAME="rl1"><A HREF="#l1">Listing One</A>). You can also read process statistics from the <i>task_ struct</i> entry. </p><p>The process of porting the application to Win32 platforms was relatively difficult due to a number of differences, such as the process creation mechanism, the means of interprocess communication and process synchronization, resource handling, and so on.</p><h3>Porting from Linux to Win32</h3><p>For the sake of brevity, I'll concentrate on some of the more important porting issues. For other issues, see <i>Win32 system Programming</i>, by Johnson M. Hart (Addison-Wesley, 1997); "Using the Win32 API to Port Code from UNIX to Windows NT" (http:// wint.decsy.ru/alphaservers/digital/ v0001536.html); and "Moving Unix Applications to Windows," <i>MSDN</i>. While many of the C library functions will work on Windows without change (though you may like to use equivalent Win32 API functions such as <i>ReadFile</i> in place of <i>fread</i> to improve performance), code related to the aforementioned differences has to be ported. Hart is a good source for a directly equivalent Windows routine for some of the C library functions (examples, <i>strcaseamp== _stricmp, bzero==memset</i>). For other cases, you will need to dirty your hands a bit.</p><p>Whenever you open a file in a UNIX pipe, socket, or shared memory, you get an integer called "<i>descriptor</i>" that can be used for further work with these objects. In Windows, these objects are manipulated through handles. Though some handles are just integers (SOCKET handle), some are complex structures. A file handle is one such example. Unlike UNIX, you cannot use standard input, standard output, and standard error devices through file descriptors 0, 1, and 2, respectively. You have to use <i>GetStdHandle(STD_ INPUT_HANDLE)</i>, <i>GetStdHandle(STD_ OUTPUT_HANDLE)</i>, <i>GetStdHandle(STD_ ERROR_HANDLE)</i>, respectively (available electronically; see "Resource Center," page 5).</p><h3>Process Creation </h3><p>Through a <i>fork </i>in UNIX, you can create a dummy process, and manipulate its properties, such as redirection of standard devices, setting signal handling properties, and so on. This dummy process is then converted into a process with the aforementioned properties and desired functionality by executing a new program through <i>exec </i>or its variants. Windows does not have <i>fork</i>s<i>. </i>If you use <i>exec </i>variants in Windows, a new process is created, but it terminates the calling process. To create a new process without terminating the calling process, you have to use <i>CreateProcess</i> or a higher level routine, such as <i>_spawnv</i> or its variants.</p><p>Getting an operation equivalent to the <i>fork exec </i>combination of UNIX with modification of properties through intermediate dummy processes is not straightforward in Windows. <A NAME="rl2"><A HREF="#l2">Listing Two</A> (available electronically) illustrates how you can perform intermediate tasks of standard input, standard output, and error redirection. Here, the first argument of <i>CreateProcess</i> specifies the program to run, and the second provides the command-line arguments. <i>CreateProcess</i> takes other process parameters as arguments (see Hart for details). However, the last two arguments require mention. The second to last argument is a pointer to a STARTUPINFORMATION structure, which specifies the standard devices for the process and other start-up information about the process environment. You need to set the <i>hStdin</i>, <i>hStdout</i>, and <i>hStderr</i> members of the STARTUPINFORMATION structure before passing its address to <i>CreateProcess</i> to redirect standard input, standard output, and standard error. The last argument is a pointer to a PROCESSINFORMATION structure, which is filled up by the created process. Once the process starts, it will contain the handle to the created process. To get the operation equivalent to a signal call on the intermediate dummy process in UNIX, you can utilize the handle to carry out those steps (see <i>handle_ SIGCHLD</i> in <A NAME="rl2"><A HREF="#l2">Listing Two</A>, available electronically). </p><h3>Interprocess Communication</h3><p>The support of signal handling is poor in Windows, and UNIX provides a large number of signals. In Windows, you can perform the task of signal handling by a mechanism like Structured Exception Handling (SEH). The intention of SEH is to make the program robust to unexpected exceptions such as floating-point exceptions, access to privileged instructions, and the like. If the code is susceptible to such events, you put those events inside the <i>_try{}</i> block followed by a number of <i>_except (exception1){}</i> blocks to capture the desired exceptions. Code inside the curly braces states what needs to be done (such as freeing resources) for the corresponding exception (<i>exception1</i>, in this example). You can affect the normal flow of the program by generating exceptions through <i>RaiseException</i>. However, this mechanism of communication is limited to one thread. You cannot send signals from one thread to another, or one process to another as in UNIX.</p><p>SEH cannot perceive the occurrence of events such as a user logging off or pressing Control C for the intended action. You can use <i>SetConsoleCtrlEvent</i> to capture such events from the program. Here, you pass a handler function as the first argument to the call <i>SetConsoleCtrlEvent</i>; an argument to the handler function specifies what event is to be captured, and the handler routine itself specifies how to react to an occurrence of this event (see <A NAME="rl4"><A HREF="#l4">Listing Four</A>; available electronically). As you may have guessed, you can actually generate these events (CTRL_ LOGOFF_EVENT, CTRL_C_EVENT, CTRL_ BREAK_EVENT) through <i>GenerateConsoleCtrlEvent</i>. However, communication is limited to processes sharing the same console.</p><p>Interprocess communication in Windows is as straightforward as its UNIX counterparts for pipes and sockets. For pipes, you need to create a pipe through <i>CreatePipe</i> (<i>pipe</i> in UNIX). Processes can interact by reading from and writing to the pipe through <i>Readfile</i> and <i>WriteFile</i> functions. Win32 provides the header file winsock.h and library wsock32.lib, which make it possible for most of the socket commands of UNIX to work on Win32. However, you should use <i>WSAStartUp</i> and <i>WSACleanup</i> to start and stop the Windows socket DLL. </p><p>Memory-mapped files in Win32 are an alternative to UNIX shared memory. In UNIX, you create shared memory with an <i>Open </i>call with the first argument SHARED. <i>Open </i>returns a descriptor to shared memory. In Win32, you create a mapping object through <i>CreateFileMapping</i>. The first argument specifies a handle to the file used for mapping, and subsequent arguments specify the access type and size limits of the mapping object. As a result of the call, you get a handle to the mapping object. The next step is to allocate a memory space and associate it with a process address space. In UNIX, you do it through <i>mmap</i>, which takes as parameters, among other things, the process space that is to be mapped and the descriptor for the shared memory. In Win32, <i>MapViewOfFile</i> is used to associate memory space to the file (see <A NAME="rl3"><A HREF="#l3">Listing Three</A>; available electronically).</p><p>Synchronization of processes is possible through <i>semaphore, mutex, </i>or <i>event </i>objects. You can create an event or number of events through a call to <i>CreateEvent</i>, and make a call to <i>WaitforSingleObject</i> or <i>WaitForMultipleObjects</i> for a single or a set of events to occur. The process will block these calls until the desired events occur. You can programmatically generate these events by a call to <i>SetEvent,</i> with the event as an argument. For <i>semaphore </i>and <i>mutex </i>objects<i>, </i>the modus operandi is the same, only the routines for creating and releasing them differ. </p><h3>Porting Daemons </h3><p>Services in Win32 are equivalent to daemons in UNIX. Creating a daemon in UNIX is simple. You just need to run the program in the background without attaching it to the terminal. You can use <i>nohup</i> for detaching a program from the terminal on which it is being run. However, in Windows, the process of service creation is fairly complicated. </p><h3>Windows NT Services</h3><p>NT services must implement the <i>servicestart</i> function, which carries out the actual operation that the service is to perform. Hence, if you have an existing UNIX daemon, you can modify its <i>main</i> (see <A NAME="re1"><A HREF="0012be1.htm">Example 1</A>) to work on both UNIX and Windows, respectively.</p><p>You need to define a few other routines for full-fledged service. You should always have a <i>main </i>routine -- a starting point of execution. <i>main</i> parses command-line options and calls appropriate routines for installing, removing, or running the service. Use the <i>ReportStatusToManager</i> function to report the status of the service to the Service Control Manager (SCM). </p><p>When the argument is "<i>install,</i>" <i>main </i>calls the routine <i>CmdInstallService</i> to register the service with the SCM for the first time. <i>CmdInstallService</i> calls <i>OpenSCManager</i> to get a handle to the SCM database. Using the handle, it then creates the service through a call to <i>CreateService,</i> which takes SZSERVICENAME (the name of the service), SZSERVICEDISPLAYNAME (the name as displayed on the console), and other properties as arguments.</p><p>To run the service in debugging mode as a console application, you need to pass <i>debug</i> as the first argument to <i>servicename</i>. Additional arguments serve as arguments to the application program. The <i>main</i> routine, in this case, calls routine <i>CmdDebugService</i> with the second and latter arguments. <i>CmdDebugService</i> sets the routine (<i>ControlHandler</i>) to handle console events through <i>SetConsoleHandler</i>. Subsequently, service is started through <i>servicestart</i>.</p><p>The routine <i>servicestop</i> stops the service by setting the event <i>hServerStopEvent</i>. <i>Servicestop</i> can be called by the SCM through the SERVICE_CONTROL_STOP event or by pressing Control C if the service is running in debug mode.</p><p>When a service is started through the SCM, <i>service_main</i> is called. It sets up the handler routine (<i>service_control</i>) for SCM control events followed by a call to <i>servicestart</i> to start the service.</p><p>To remove the service from the SCM database, you need to use the "remove" option. The <i>main </i>routine in that case calls <i>CmdRemoveService</i>, which gets a handle to the SCM database through <i>OpenSCManager, </i>and opens the service through <i>OpenService</i>. Then <i>controlservice</i> is called to stop the service, and <i>deleteservice</i> is called to remove the service from SCM database. Finally, it clears the handles for the service.</p><h3>Windows 95 Services</h3><p>Unlike Windows NT, Windows 95 does not provide a service API. However, you can run the application program as a service in a roundabout way by first creating a registry key: \HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunServices (see <i>RegCreateKey</i> in <A NAME="rl4"><A HREF="#l4">Listing Four</A>; available electronically). </p><p>To add a service, you just write the program name as the registry key value (see <i>RegSetValueEx</i> in <A NAME="rl4"><A HREF="#l4">Listing Four</A>). To start the service, you need to run the program as a detached process, which can be done by using DETACHED_PROCESS as the argument to <i>CreateProcess</i>. However, such processes do not have any attached consoles, so they stop when the user logs off. To make sure that it is not terminated,  you have to register the service with a Windows kernel. To accomplish this, get access to the kernel process address through a call to <i>GetProcAddress</i>. Then use <i>RegSrvProc</i> with the PID as the argument to get the corresponding process registered. </p><p>If you have the PID, stopping the service is easy. You call <i>OpenProcess</i> with the PID as an argument to get the handle to the process, and then call <i>terminateProcess </i>with the handle as an argument. If you do not have the PID, you can use the module name. But in this case, you will have to call <i>CreateToolhelp32Snapshot</i> to get information about all running processes, and check the entries one by one. When the name matches, you can extract the PID and carry out the steps, as in the previous case, to terminate the process. <A NAME="rl4"><A HREF="#l4">Listing Four</A> also illustrates how you can create a common service for both Windows 95 and NT.</p><h3>Conclusion</h3><p>Porting across UNIX platforms is considerably easier than porting from UNIX to Win32. This is expected, as UNIX systems share a common design philosophy and provide lot of similarities at the application layer. Still, the Win32 API helps in a limited way when porting from UNIX to Win32. What's important is for you to be aware of the issues that result from the differences in the designs of UNIX and Win32. </p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>/***************CODE FOR SUN OS**********************************//* The kvm routines are used to read certain information from the kernel */kvm_t *mptr;                /* Pointer to kmem */struct proc *process;       /* Pointer to proc structure */struct user *user;          /* Pointer to user structure */struct file ofile;          /* File structure of an object */struct file *fileptr;       /* Pointer to above structure */struct ucred credits;       /* Process credentials *//*Open /dev/kmem */if (!(mptr = kvm_open((char *)0, (char *)0, (char *)0,O_RDONLY,(char *)0 ))) exit (-1);/*read process-structure of the process with pid what-&gt;proc_nr*/process = kvm_getproc(mptr, what-&gt;proc_nr);/* read the credentials of the process  */if(kvm_read(mptr, process-&gt;p_cred, (char *)&amp;credits, sizeof (credits)) != sizeof (credits)){exit(-1);}/*you can verify for effective and real uids and gids, and user groups of the process using members cr_uid, cr_gid, cr_ruid, cr_rgid, cr_groups[] of credits *//*Given a file/socket descriptor (what-&gt;sock_nr), if you want to determine properties of the corresponding object, you need to readthe ofile structure of the object, but for this you have to first read user structure from the kernel */if((user = kvm_getu(mptr, process)) == NULL){exit(-1);}/*Now, read the ofile structure */if (what-&gt;sock_nr &lt; NOFILE_IN_U) {/* if the  file structure is in the user-area */if(kvm_read(mptr, user-&gt;u_ofile_arr[what-&gt;sock_nr], (char *) &amp;ofile, sizeof (struct file)) != sizeof (struct file)){        exit(-1);    }}else/* if the  file structure is not in the user-area */{if (kvm_read(mptr, (user-&gt;u_ofile + ((what-&gt;sock_nr - NOFILE_IN_U) * sizeof (struct file *))),(char *) &amp;fileptr, sizeof (struct file *)) != sizeof (struct file *)){        exit(-1);}if (kvm_read(mptr, fileptr, (char *) &amp;ofile, sizeof (struct file)) != sizeof (struct file)){        exit(-1);}}/* Now we can use the structure to extract further details of the object (example type of the object, permissions, group owner etc. if the object is file, port, domain, protocol etc. if the object is socket etc.)*//******************CODE FOR LINUX***********************************/* Unlike SUN OS where, task structures are maintained as linked list*       * Linux  keeps an array of entires for task structures.  Additional ** information (such as files opened etc.) are available through a   ** pointer in the entry.                                             **********************************************************************/#define __KERNEL__ #define TASK 0x001d61f4#ifdef OLDLNUX#define FD0 ((char *)&amp;ts.files-&gt;fd[0] - (char *)&amp;ts)    #define AD(fd) (task_addr +FD0+4*(fd))#else    #define FILES ((char *)&amp;ts.files - (char *)&amp;ts)    #define FD0 ((char *)&amp;fs.fd[0] - (char *)&amp;fs)    #define AD(fd) (readvalz(task_addr +FILES)+FD0+4*(fd))#endifint kfd;                    /* File Pointer to /dev/kmem */int task_addr;      struct task_struct ts;      /*task structure*/  struct files_struct fs;     /*file system structure*/struct file ofile;          /*File structure of an object */struct file *fileptr;       /*Pointer to above structure */struct uid_credit{          /*process credential*/    unsigned short uid,euid,suid,fsuid;    unsigned short gid,egid,sgid,fsgid;}credits;int procgrps[NGROUPS];  /*process groups*//********************************************************************   read an entry from the array in symbol table                   *********************************************************************/  int readval(int ad){    int val,r;    if (lseek(kfd,ad,SEEK_SET)&lt;0){        perror("lseek"); exit(1);    }    if((r=read(kfd,&amp;val,4))!=4){        if (r&lt;0) perror("read");        else fprintf(stderr,"Error reading ..\n");        exit(1);    }    return val;}/********************************************************************   read value at specified location, error if value is 0          *********************************************************************/int readvalz(int ad){    int r=readval(ad);    if(r==0) fprintf(stderr,"Error reading ..\n");    return r;}/********************************************************************* to read the additional information, we require the id of the      * * process corresponding to this entry                               **********************************************************************/void readtask(int ad){ int r; if (lseek(kfd,ad,SEEK_SET)&lt;0)        perror("lseek"), exit(1); if((r=read(kfd,&amp;ts,sizeof(struct task_struct)))!=sizeof(struct task_struct)){        if (r&lt;0) perror("read");        else fprintf(stderr,"Error reading ..\n");        exit(1); }}/********************************************************************   find the task structure of specified process                   *********************************************************************/  void findtask(int pid){    int kadr;    for(kadr=TASK;;kadr+=4){/*TASK is starting address for symbol table: differs from installation to  * installation. Its value can be found from /boot/System.map */        if (kadr&gt;=TASK+4*NR_TASKS){ /*NR_TASK indicates number of tasks*/             fprintf(stderr,"Proc not found ..\n");         }               task_addr=readval(kadr);        readtask(task_addr);        if (ts.pid==pid) break;    }}/********************************************************************   read process credentials                                       *********************************************************************/void readcred(struct uid_credit *credits){    int r;    int ad= task_addr +(char *)&amp;ts.uid-(char *)&amp;ts;    if (lseek(kfd,ad,SEEK_SET)&lt;0)        perror("lseek"), exit(1);    if((r=read(kfd,credits,sizeof(struct uid_credit)))!=                                             sizeof(struct uid_credit)){        if (r&lt;0) perror("read");        else fprintf(stderr,"Error reading ..\n");        exit(1);    }}/********************************************************************   read process user groups                                       *********************************************************************/void readgroups(int *procgrps){    int r;    int ad= task_addr +(char *)&amp;ts.groups[0]-(char *)&amp;ts;    if (lseek(kfd,ad,SEEK_SET)&lt;0)        perror("lseek"), exit(1);    if((r=read(kfd,procgrps,NGROUPS*sizeof(int)))!=NGROUPS*sizeof(int)){        if (r&lt;0) perror("read");        else fprintf(stderr,"Error reading ..\n");        exit(1);    }}/********************************************************************   read file structure for a given kernel object                  *********************************************************************/void readfile(int sock_nr, struct file *fileptr){    int r;    int ad=AD(sock_nr);    if (lseek(kfd,ad,SEEK_SET)&lt;0)        perror("lseek"), exit(1);if((r=read(kfd,(char *)fileptr,sizeof(struct files_struct)))!=sizeof(struct files_struct)){        if (r&lt;0) perror("read");        else fprintf(stderr,"Error reading ..\n");        exit(1);    }}kfd=open("/dev/kmem",O_RDONLY); if (kfd&lt;0) { perror("open"); exit(1);}/* read the task structure first */findtask(what-&gt;proc_nr);/* read the credentials of the process */readcred(&amp;credits);/* read the user groups of the process*/readgroups(procgrps); /*you can verify for effective and real uids and gids, and user groups of the process using members uid, gid, euid, egid of credits and procgrps *//* read the ofile structure for the give descriptor (what-&gt;sock_nr) */readfile(what-&gt;sock_nr,&amp;ofile); /* Now we can use the structure to extract further details of the object (example type of the object, permissions, group owner etc. if the object is file, port, domain, protocol etc. if the object is socket etc.)*/</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>int ForkAndExec(int sock, char **argvv, int *sockpid) { char chReadBuffer[64]; 	BOOL bSuccess; int j;   HANDLE hOutFile; 	HANDLE hReadPipe, hWritePipe, hWritePipe2; char szArgs[256]; 		char *p; DWORD cchReadBuffer; STARTUPINFO si; 		PROCESS_INFORMATION pi; SECURITY_ATTRIBUTES saPipe;   /* create the log file where we will save all output from child */ if ((hOutFile = CreateFile("\\\\.\\C:\\yalb_win\\tmp", GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL, NULL))==NULL) printf("Error %d\n",GetLastError());  /* set up the security attributes for the anonymous pipe */ saPipe.nLength = sizeof(SECURITY_ATTRIBUTES);saPipe.lpSecurityDescriptor = NULL; saPipe.bInheritHandle = TRUE;  /* create the anonymous pipe */ if (!(bSuccess = CreatePipe(&hReadPipe, &hWritePipe, &saPipe, 0))) printf("Error %d\n",GetLastError());/* Now we need to change the inheritable property for the readable end of the pipe. */  if (!(bSuccess = DuplicateHandle(GetCurrentProcess(),hReadPipe, GetCurrentProcess(),NULL, 0, FALSE, DUPLICATE_SAME_ACCESS)))printf("Error %d\n",GetLastError());  if (!(bSuccess=DuplicateHandle(GetCurrentProcess(),hWritePipe, GetCurrentProcess(), &hWritePipe2, 0, TRUE, DUPLICATE_SAME_ACCESS))) printf("Error %d\n",GetLastError());  /* Set up the STARTUPINFO structure */ memset(&si, 0, sizeof(si)); 		si.cb = sizeof(si);  /* Set up the command-line buffer */ memset(szArgs, 0, sizeof(szArgs)); 	strcpy(szArgs, *argvv); p = strchr(szArgs, 0); for (j = 0; argvv[j]!=NULL; j++){     strcat(p, argvv[j]); strcat(p, " "); }  #ifdef USESTDHANDLES /*file handles specified in the STARTUPINFO structure willbe inheritied by the child. */ si.hStdInput = hWritePipe2; si.hStdOutput = hWritePipe; si.hStdError = hWritePipe2; si.dwFlags = STARTF_USESTDHANDLES; #else bSuccess = SetStdHandle(STD_INPUT_HANDLE, hWritePipe2);   	bSuccess = SetStdHandle(STD_OUTPUT_HANDLE, hWritePipe);   	bSuccess = SetStdHandle(STD_ERROR_HANDLE, hWritePipe2); bSuccess = DuplicateHandle(GetCurrentProcess(),GetStdHandle(STD_INPUT_HANDLE), GetCurrentProcess(),NULL, 0, FALSE, DUPLICATE_SAME_ACCESS);  #endif    /* create the child process */ if ((bSuccess = CreateProcess(NULL, szArgs, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi)) ==NULL) printf("Error %d\n",GetLastError());  *sockpid=pi.dwProcessId;  		CloseHandle(pi.hThread);    /*We can close our instances of the inheritable pipe write handle*/ bSuccess = CloseHandle(hWritePipe); bSuccess = CloseHandle(hWritePipe2); /* read from the pipe until we get an ERROR_BROKEN_PIPE */ for (;;){ bSuccess = ReadFile(hReadPipe, chReadBuffer, sizeof(chReadBuffer), &cchReadBuffer, NULL);     	if (bSuccess && cchReadBuffer) { send(sock, chReadBuffer,cchReadBuffer, 0);		/* write buffer (of specified length) to console */       		printf("%.*s", cchReadBuffer, chReadBuffer);       	} if (cchReadBuffer<64) break; } /* close the trace file, pipe handles */ CloseHandle(hOutFile); CloseHandle(hReadPipe); handle_SIGCHLD(pi);}</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>#ifdef WIN32	HANDLE hIn,hInMap;	LPSTR addr_time;	static HANDLE shared_mem; #else	caddr_t addr_time; 	static int shared_mem; #endif#ifdef WIN32hIn=CreateFile ("\\tmp\\yalb\\yalb.shared", GENERIC_READ|GENERIC_WRITE,0,NULL,OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL,NULL);	printf ("Error in creating File yalb.shared  %d\n", GetLastError());hInMap=CreateFileMapping(hIn,NULL,PAGE_READWRITE,0,sizeof(structtimeval) + sizeof(float) + 2*sizeof(int) + sizeof(float),NULL);	printf ("Error in creating file mapping for yalb.shared  %d\n", GetLastError());addr_time=MapViewOfFile(hInMap,FILE_MAP_ALL_ACCESS,0,0,0);	printf ("Error in  mapping file for yalb.shared  %d\n", GetLastError());	*last_update = (struct tm *) addr_time;#endif#ifdef UNIX#ifdef ROOT_OWNER	shared_mem = open(SHARED,O_RDWR | O_CREAT, 0600);#else	shared_mem = open(SHARED,O_RDWR | O_CREAT, 0666);#endifif (shared_mem < 0){	syslog(LOG_ERR, "Load-Daemon: Shared memory not available: %m");	exit(1);}ftruncate (shared_mem, 4096);addr_time = mmap ((caddr_t)0, (size_t) (sizeof(struct timeval) + sizeof(float) + 2*sizeof(int) + sizeof (float) + sizeof(int)),PROT_WRITE | PROT_READ, MAP_SHARED, shared_mem, (off_t)0 );     if (addr_time == (caddr_t)-1)syslog(LOG_ERR, "Load-Daemon: getting shared segment (%m)");last_update = (struct timeval *) addr_time;#endif</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre> #ifdef WIN32VOID ServiceStart (DWORD argc, LPTSTR *argv) #endif#ifdef UNIXint main(int argc,char *argv[])#endif{ /*actual work of service defined here*/}#define SZAPPNAME            "ldaemon" #define SZSERVICENAME        "ldaemon" #define SZSERVICEDISPLAYNAME "ldaemon" #define SZDEPENDENCIES       ""   #ifdef WIN95 #include <tlhelp32.h>#define SERVICE_KEY "Software\\Microsoft\\Windows\\CurrentVersion\\RunServices" #endif		SERVICE_STATUS sStatus; 	SERVICE_STATUS_HANDLE   sshStatusHandle; DWORD dwErr = 0; 	BOOL bDebug = FALSE; 	TCHAR  szErr[256];  /* function prototypes *//*ServiceStart must be defined by in code. The service should useReportStatusToSCMgr to indicate progress.  This routine must also be used by StartService()to report to SCM when the service is running*/ VOID ServiceStart(DWORD dwArgc, LPTSTR *lpszArgv); VOID ServiceStop(); BOOL ReportStatusToSCMgr(DWORD dwCurrentState, DWORD dwWin32ExitCode,DWORD dwWaitHint); void AddToMessageLog(LPTSTR lpszMsg); VOID WINAPI service_ctrl(DWORD dwCtrlCode); VOID WINAPI service_main(DWORD dwArgc, LPTSTR *lpszArgv); VOID CmdInstallService(); VOID CmdRemoveService(); VOID CmdDebugService(int argc, char **argv); BOOL WINAPI ControlHandler ( DWORD dwCtrlType ); LPTSTR GetLastErrorText( LPTSTR lpszBuf, DWORD dwSize ); const char *CmdLine=".\\ldaemon -debug"; /* set according to application to be run*//* main() either performs the command line task, or call StartServiceCtrlDispatcher to register the main service thread.When the this call returns, the service has stopped, so exit. */ void _CRTAPI1 main(int argc, char **argv) { SERVICE_TABLE_ENTRY dispatchTable[] =     	{         { TEXT(SZSERVICENAME),(LPSERVICE_MAIN_FUNCTION)service_main },         { NULL, NULL }     	};  if ( (argc > 1) && ((*argv[1] == '-')|| (*argv[1] == '/')) ){         	if ( _stricmp( "install", argv[1]+1 ) == 0 ) {             		CmdInstallService();         	}         	else if ( _stricmp( "remove", argv[1]+1 ) == 0 ) {             		CmdRemoveService();         	}         	else if ( _stricmp( "debug", argv[1]+1 ) == 0 ) {             		bDebug = TRUE;             		CmdDebugService(argc, argv);         	}         	else {             		goto dispatch;        	} 		exit(0);     	}      	/* else call StartServiceCtrlDispatcher */    	dispatch:         	printf( "%s -install to install the service\n", SZAPPNAME );         	printf( "%s - remove to remove the service\n", SZAPPNAME ); printf( "%s -debug <params>to run as a console app for debugging\n", SZAPPNAME );         	printf( "\nStartServiceCtrlDispatcher being called.\n" );         	printf( "This may take several seconds.  Please wait.\n" );          	if (!StartServiceCtrlDispatcher(dispatchTable))             	AddToMessageLog(TEXT("StartServiceCtrlDispatcher failed.")); }    /* actual initialization of the service */ void WINAPI service_main(DWORD dwArgc, LPTSTR *lpszArgv) {  	sshStatusHandle = RegisterServiceCtrlHandler( TEXT(SZSERVICENAME), service_ctrl);  	if (!sshStatusHandle) goto cleanup;      	ssStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;     	ssStatus.dwServiceSpecificExitCode = 0;       	// report the status to the service control manager.     	if (!ReportStatusToSCMgr(SERVICE_START_PENDING,NO_ERROR,3000)) goto cleanup;      	ServiceStart( dwArgc, lpszArgv ); cleanup: if (sshStatusHandle) (VOID)ReportStatusToSCMgr(SERVICE_STOPPED, dwErr, 0);      		return; }    /* service_ctrl is called by the SCM whenever ControlService() is called on this service. */ VOID WINAPI service_ctrl(DWORD dwCtrlCode) { switch(dwCtrlCode) { /* SERVICE_STOP_PENDING should be reported before setting the Stop Event to avoid a race condition. */       	case SERVICE_CONTROL_STOP:            	ReportStatusToSCMgr(SERVICE_STOP_PENDING, NO_ERROR, 0);             	ServiceStop();       return;  case SERVICE_CONTROL_INTERROGATE: break;  default:     break; } ReportStatusToSCMgr(ssStatus.dwCurrentState, NO_ERROR, 0); }    /* ReportStatusToSCMgr(): Sets the current status of the service and reports it to the Service Control Manager */ BOOL ReportStatusToSCMgr(DWORD dwCurrentState, DWORD dwWin32ExitCode,DWORD dwWaitHint) {     	static DWORD dwCheckPoint = 1; BOOL fResult = TRUE;      	if ( !bDebug ) {         	if (dwCurrentState == SERVICE_START_PENDING) ssStatus.dwControlsAccepted = 0;         	else             	ssStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;          	ssStatus.dwCurrentState = dwCurrentState;         	ssStatus.dwWin32ExitCode = dwWin32ExitCode;         	ssStatus.dwWaitHint = dwWaitHint; 		if ((dwCurrentState==SERVICE_RUNNING)||( dwCurrentState ==SERVICE_STOPPED))             		ssStatus.dwCheckPoint = 0;         	else             		ssStatus.dwCheckPoint = dwCheckPoint++;  		if (!(fResult = SetServiceStatus( sshStatusHandle, &ssStatus))) {             		AddToMessageLog(TEXT("SetServiceStatus"));         	}     	}     	return fResult; }    /* AddToMessageLog: Allows any thread to log an error message */ VOID AddToMessageLog(LPTSTR lpszMsg) { TCHAR   szMsg[256];     HANDLE  hEventSource; LPTSTR  lpszStrings[2]; if ( !bDebug ) { dwErr = GetLastError();  	hEventSource = RegisterEventSource(NULL, TEXT(SZSERVICENAME));  	_stprintf(szMsg, TEXT("%s error: %d"), TEXT(SZSERVICENAME), dwErr);       	lpszStrings[0] = szMsg;         lpszStrings[1] = lpszMsg; if (hEventSource != NULL) { ReportEvent(hEventSource, EVENTLOG_ERROR_TYPE, 0, 0,NULL, 2, 0, lpszStrings, NULL);              	(VOID) DeregisterEventSource(hEventSource); } } }   void CmdDebugService(int argc, char ** argv) {     DWORD dwArgc;     LPTSTR *lpszArgv;  #ifdef UNICODE     lpszArgv = CommandLineToArgvW(GetCommandLineW(), &(dwArgc) ); #else     dwArgc   = (DWORD) argc;     lpszArgv = argv; #endif      _tprintf(TEXT("Debugging %s.\n"), TEXT(SZSERVICEDISPLAYNAME));      SetConsoleCtrlHandler( ControlHandler, TRUE );      ServiceStart( dwArgc, lpszArgv ); }   /* Handles console control events */ BOOL WINAPI ControlHandler ( DWORD dwCtrlType ) {     switch( dwCtrlType ) {         case CTRL_BREAK_EVENT:         case CTRL_C_EVENT:             _tprintf(TEXT("Stopping %s.\n"),TEXT(SZSERVICEDISPLAYNAME));             ServiceStop();             return TRUE;             break;      }     return FALSE; } HANDLE  hServerStopEvent = NULL; VOID ServiceStop(){     if ( hServerStopEvent ) SetEvent(hServerStopEvent); }#ifdef WIN95 #include <tlhelp32.h>#define SERVICE_KEY "Software\\Microsoft\\Windows\\CurrentVersion\\RunServices" #endif	#ifdef WIN95 BOOL AddService(const char* Name, const char *CmdLine) { HKEY    hKey;     LONG    Status;     BOOL    Result  = FALSE; Status = RegCreateKey(HKEY_LOCAL_MACHINE, SERVICE_KEY, &hKey);  if(ERROR_SUCCESS == Status) { Status  = RegSetValueEx(hKey, Name, 0, REG_SZ, (CONST BYTE*)CmdLine, strlen(CmdLine)+1);         	if(ERROR_SUCCESS == Status) Result  = TRUE;         	RegCloseKey(hKey); }  	return Result; }  #define NUM_ATTEMPTS_EXISTS     20 #define SLEEP_TIME              500  DWORD StartWin95Service(char* file_name) { PROCESS_INFORMATION piProcInfo;     	STARTUPINFO siStartInfo; DWORD   dwPriority;     		DWORD dwResult=(DWORD)-1; int                 ii;  dwPriority = NORMAL_PRIORITY_CLASS;  /* Initialize STARTUPINFO structure. */ siStartInfo.cb          = sizeof(STARTUPINFO);     siStartInfo.lpReserved  = NULL; siStartInfo.lpReserved2 = NULL;   	siStartInfo.cbReserved2 = 0; siStartInfo.lpDesktop   = NULL;  siStartInfo.dwFlags     = STARTF_USESHOWWINDOW;  /* Create the process   */ if(FALSE == CreateProcess(file_name, NULL, NULL, NULL,FALSE,DETACHED_PROCESS | dwPriority, NULL, NULL, &siStartInfo,&piProcInfo)) return -1; else{ for(ii = 0; ii < NUM_ATTEMPTS_EXISTS; ii++){ GetExitCodeProcess(piProcInfo.hProcess,&dwResult); if(dwResult == STILL_ACTIVE) break; else Sleep(SLEEP_TIME); }         if(dwResult == STILL_ACTIVE) { Sleep(2000);             	SetPriorityClass(piProcInfo.hProcess, dwPriority);             	dwResult = piProcInfo.dwProcessId; }         else  dwResult    = (DWORD)-1; } return dwResult; }   /* mark a process as a Win95 "service" */ BOOL RegisterService (DWORD AppProcessId){ BOOL    Result  = FALSE;     int     nstat;     HMODULE hKernelLib;  typedef DWORD (WINAPI*ExRegSrvProc) (DWORD dwProcessId, DWORD dwType); ExRegSrvProc RegSrvProc;  hKernelLib = GetModuleHandle("KERNEL32.DLL"); if(NULL != hKernelLib) { RegSrvProc= (ExRegSrvProc)GetProcAddress(hKernelLib, "RegisterServiceProcess");     	if(NULL != RegSrvProc) { nstat = RegSrvProc(AppProcessId, 0x00000001);             	if(1 == nstat) Result  = TRUE; } } return Result;}  void CmdRemoveService(){ DWORD  dwProcID;	HANDLE hProcess, hProcessSnap, hModuleSnap; PROCESSENTRY32  pe32; 	MODULEENTRY32   me32; BOOL bModuleFound = FALSE;  /* Take snapshot of all processes */ hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS,0); pe32.dwSize = sizeof(PROCESSENTRY32); if (Process32First(hProcessSnap, &pe32)) { do  { hModuleSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE,pe32.th32ProcessID);                 me32.dwSize = sizeof(MODULEENTRY32);                 Module32First(hModuleSnap, &me32);                 do {                     	if(strcmp(me32.szExePath, SZSERVICENAME)==0){                        	bModuleFound = TRUE;                        	break; } }while (Module32Next(hModuleSnap, &me32));                CloseHandle (hModuleSnap); if(bModuleFound) break; } while (Process32Next(hProcessSnap, &pe32)); } CloseHandle (hModuleSnap);  if(bModuleFound) { hProcess=OpenProcess(PROCESS_ALL_ACCESS,FALSE,pe32.th32ProcessID);       	TerminateProcess(hProcess, -1);      	printf("Process terminated"); } else	printf("Process not found"); } #endif   /*CmdInstallService(): Installs the service */ void CmdInstallService() { SC_HANDLE   schService;	SC_HANDLE   schSCManager; TCHAR szPath[512];  if ( GetModuleFileName( NULL, szPath, 512 ) == 0 ) { _tprintf(TEXT("Unable to install %s - %s\n"), TEXT(SZSERVICEDISPLAYNAME), GetLastErrorText(szErr, 256));         return; }  	#ifdef WIN95if (AddService(SZSERVICENAME,CmdLine)==TRUE) {          _tprintf(TEXT("%s installed.\n"),TEXT(SZSERVICEDISPLAYNAME)); }    else _tprintf(TEXT("CreateService failed \n")); #elseschSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS); if ( schSCManager ) { schService=CreateService(schSCManager,TEXT(SZSERVICENAME), TEXT(SZSERVICEDISPLAYNAME), SERVICE_ALL_ACCESS,SERVICE_WIN32_OWN_PROCESS, SERVICE_DEMAND_START, SERVICE_ERROR_NORMAL, szPath, NULL, NULL, TEXT(SZDEPENDENCIES),NULL, NULL);          if ( schService ) {             	_tprintf(TEXT("%s installed.\n"),TEXT(SZSERVICEDISPLAYNAME));             	CloseServiceHandle(schService);         } else _tprintf(TEXT("CreateService failed-%s\n"), GetLastErrorText(szErr, 256));        CloseServiceHandle(schSCManager); } else _tprintf(TEXT("OpenSCManager failed - %s\n"),GetLastErrorText(szErr,256)); #endif}#ifdef WINNT /* CmdRemoveService(): Stops and removes the service */ void CmdRemoveService(){ SC_HANDLE   schService; 	SC_HANDLE   schSCManager; schSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS); if ( schSCManager ) { schService=OpenService(schSCManager, TEXT(SZSERVICENAME),SERVICE_ALL_ACCESS);  	if (schService) { if ( ControlService( schService, SERVICE_CONTROL_STOP,&ssStatus)) {                 	_tprintf(TEXT("Stopping %s."), TEXT(SZSERVICEDISPLAYNAME));                 	Sleep( 1000 ); while( QueryServiceStatus( schService,&ssStatus)){                     		if (ssStatus.dwCurrentState == SERVICE_STOP_PENDING) {                         		_tprintf(TEXT("."));                         		Sleep( 1000 );                     		}                    		else  break;                 	}                  	if (ssStatus.dwCurrentState == SERVICE_STOPPED) _tprintf(TEXT("\n%s stopped.\n"), TEXT(SZSERVICEDISPLAYNAME) );                 	else _tprintf(TEXT("\n%s failed to stop.\n"), TEXT(SZSERVICEDISPLAYNAME) );              	}              	/* remove the service */if( DeleteService(schService) )                 	_tprintf(TEXT("%s removed.\n"),TEXT(SZSERVICEDISPLAYNAME) ); else _tprintf(TEXT("DeleteService failed - %s\n"),GetLastErrorText(szErr,256));  		CloseServiceHandle(schService);         }         else _tprintf(TEXT("OpenService failed - %s\n"),GetLastErrorText(szErr,256)); CloseServiceHandle(schSCManager); } else _tprintf(TEXT("OpenSCManager failed - %s\n"), GetLastErrorText(szErr,256)); } #endif</pre><P><A HREF="#rl4">Back to Article</A></P></body></html>