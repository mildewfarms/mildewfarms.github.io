<html><head><title>Dec00: Algorithm Alley</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>AVL Trees</h1><p><i>Dr. Dobb's Journal</i> December 2000</p><h3>By Timothy Rolfe</h3><I>Timothy is an associate professor of computer science at Eastern Washington University. He can be contacted at trolfe@ ewu.edu.</I><hr><p>The binary search tree (BST) is a data structure for holding information that allows rapid access according to some ordering key. As the name indicates, it is a tree structure in which the nodes containing information can be connected to two subtrees (hence the "binary"). The search condition is met by requiring that all information to the left of a node comes before the node itself, and that all information to the right of the node comes after the node itself. If you want to allow equal comparisons, you choose which side to put them on.</p><p>Searching for an item within such a data structure is simply a matter of examining each node (starting from the beginning, called the "root" of the tree). If the value desired is found within that node, you're finished. If not, you can see how your desired value compares with the node value: If the desired value is less than the node value, you can ignore the entire right subtree and just move down the left subtree, repeating the same operation. If the desired value is greater than the node, then ignore the left subtree and move down the right.</p><DDJADVERTISEMENT INLINE><p>Insertion into a BST involves searching for the value to be inserted, then putting it in exactly at the spot where it wasn't<i> </i>found.</p><p>Deletion is a bit more of a problem. The more elegant solution is to find a replacement node from farther down in the tree that can replace the deleted node and still retain the BST condition. In other words, replace the node with a node in the tree that, in the key order generating the tree, comes immediately before or after that node.</p><p>If the BST is most densely organized, you can, within a path of length <i>k</i>, access one piece of information among 2<sup><i>k</i>+1</sup> pieces of information. The extremely careful would want that written as 2<sup><i> k</i>+1</sup> -1, though the -1 makes little difference as <i>k</i> becomes large. Starting from the top, every level of the tree is fully populated, and the number of levels in the tree of <i>N </i>nodes is approximately 3.3 <i>log</i><sub>10</sub> <i>N -- </i>in other words, the base-2 logarithm of <i>N</i>, written as <i>lg</i>(<i>N</i>).</p><p>However, the BST has a significant problem. When the tree is at its lowest density, the path of length <i>k</i> only chooses from among <i>k</i>+1 pieces of information. This happens when every node in the tree has just one subtree; perhaps at every level there is no left subtree, but only a right subtree (referred to as a degenerate tree because it really is nothing but a linked list). This is exactly what happens if you build the BST with values that are already in order.</p><p>With random data, the number of levels in the tree tends to be almost 3 <i>lg</i>(<i>N</i>), and on average you go down a bit over 1 1/3 <i>lg</i>(<i>N</i>) levels to find a value.</p><p>People who want faster access have devised schemes that guarantee that the BST is denser than that (which would certainly avoid the degenerate tree case), regardless of the order of operations on the tree. The first one was proposed by Adel'son-Velskii and Landis, and is called the "AVL tree" in their honor (see G.M. Adel'son-Velskii and Y.M. Landis, "An Algorithm For The Organization Of Information," <i>Soviet Math Dockl</i>., 1962).</p><p>Every node in a tree has what is called its "height" -- the number of links in the longest path from that node down to what is called a "leaf node" (one with no children) at the bottom of the tree. (A memory aid for this is to remember that height  tells you how far up you are.) The AVL condition for a BST is that, for every node, the heights of its two children differ at most by one. (You can see that you have to allow a difference of one just by looking at a two-node tree.)</p><p>The operations in a BST that affect the height are insertion and deletion. I will focus on deletion as effectively removing the node that becomes the replacement for the deleted node. On an insertion, there are obviously no nodes below the point of insertion since there's nothing there. With the way we are focusing for deletion, there are also no changes in height for nodes in the subtree below the node removed. Consequently, the adjustments to enforce the AVL condition must be performed in the nodes from the point of the operation back up to the root of the tree. This might appear to be a problem, but it really isn't. To see why, we will have to get into explicit programming, and we will use C++ as its basis (C++ because I depend on having a pointer as a reference parameter). I will explicitly discuss insertion, but also include the deletion function in the accompanying code.</p><p>Insertion is most easily handled as a recursive function: recurse to the point of failure, then change the pointer (and, because of the reference parameter, the pointer in the calling routine) to reference the newly created node. Written for a BST without regard to the AVL condition, this function (see <A NAME="rl1"><A HREF="#l1">Listing One</A>) is particularly simple. Assume a <i>class BST</i> for the tree itself, a <i>class </i>or <i>struct BSTnode</i> for the nodes of the tree, and a <i>class</i>, <i>struct</i>, or type <i>Data</i> for the data portion of the <i>BSTnode</i> (for which the relational operator "&lt;" is defined). To keep the logic simple, I'll omit validation of the pointer returned by the <i>new</i> operator.</p><p>Because of the recursion, the entire path back up to the root of the tree is available as the function goes through its returns. Thus, you can easily do the correction for the AVL condition simply by putting the appropriate code after the <i>if/else-if/else</i> structure in <A NAME="rl1"><A HREF="#l1">Listing One</A>. </p><p>Obviously, you need to get at the height of each tree node easily for an AVL tree. This means that you will have a small expense in space within each AVL node to retain that information. While there are strategies for retaining the necessary AVL information in just a couple of bits, the logic is more easily seen if you simply store the height, and unless you get into bit fields, you'll probably end up using a default <i>int</i> anyway.</p><p>When checking the AVL condition, you test whether the two subtrees differ in height by more than one. Because the tree was a valid AVL tree before the most recent operation, you know that the difference will be at most two. So what you need is an operation that changes the height relationship. That is found in what is called a "BST rotation" -- shuffle links at three levels of the BST so that one side goes up and the other side goes down. The rightward and leftward rotations are simply inverses of each other, so that a single figure shows both.</p><p>As <A NAME="rf1"><A HREF="0012pf1.htm">Figure 1</A> illustrates, it is most useful to show the grandparent (Gr) with the link that must be altered, and then instead of parent and child, leftward node (Lt) and rightward node (Rt). For completeness, the leftward child of Lt is shown, even though it is not moved, as well as the rightward child of Rt. The child that is moved is the subtree occurring between Lt and Rt (the subtree labeled Q): In one circumstance it is the rightward child of Lt, in the other it is the leftward child of Rt.</p><p>Because of the reference parameter, you have available for alteration the link from the grandparent that needs to be changed in the rotation. If the subtree to the left has a height longer than the subtree on the right, then a rightward rotation should decrease the leftward subtree by one and increase the rightward subtree. <A NAME="rl2"><A HREF="#l2">Listing Two</A> is the rightward rotation function; the leftward rotation is its mirror image.</p><p>There is a problem, though, with the subtree Q. As you can see in <A NAME="rf1"><A HREF="0012pf1.htm">Figure 1</A>, it remains at the same level (even though it switches sides). If the height of the leftward subtree is based on Q (that is, Q's height is one more than R's) you end up not correcting the AVL condition. You can, however, do preprocessing to ensure that the leftward side is longer by doing a leftward rotation at Lt before doing the rightward rotation at Rt.</p><p>You have enough information now to build the function <i>AVLadjust</i> (see <A NAME="rl3"><A HREF="#l3">Listing Three</A>), then insert a call to it at the end of the <i>Insert</i> function; see <A NAME="rl1"><A HREF="#l1">Listing One</A>. Note that the <i>Rotate</i> functions adjust heights after the rotation has been accomplished -- something also checked if there is a rotation.</p><p>The AVL tree has an interesting property. In its worst case (that is, the AVL tree in which every node has subtrees that differ in height by one), the number of nodes in the entire tree, and within each subtree that comprises the entire tree, is close to a Fibonacci number. (The recurrence  is actually <i>H<sub>k</i>+1</sub>=<i>H<sub>k</i></sub>+ <i>H<sub> k</i>-1</sub>+1.) On this basis, there is proof that the worst-case height (the largest number of links that must be traversed in a search) is less than 1.44 <i>lg</i>(<i>N</i>+2)-1.328. This is a marked improvement over the average case for a BST, noted earlier as nearly 3 <i>lg</i>(<i>N</i>). The average height for AVL trees, unfortunately, has not been mathematically determined.</p><p><A NAME="rf2"><A HREF="0012pf2.htm">Figure 2</A> combines two sources of experimental data. For AVL trees of up to 12 nodes, you can explicitly generate all possible trees (up to 12 permutations) to get the average tree height (worst-case search path length) and the average node depth (the average of the search path lengths to find a value). For trees with more than 12 nodes, the results are based on generating, for each tree size, 5000 AVL trees from random data, and then generating their averages. Besides the average height (top graph) and the average depth (bottom graph), you also see as the step function between them the height of a complete binary tree -- the best-case tree in which every tree level, except possibly the bottom, is completely filled. The average tree height shows some interesting undulations for each power of two in the size of the tree. As the tree size grows, however, the ratio of the average tree height to the average node depth settles down to approximately 1.3 to 1. There is no plot of the average node depth in the complete binary tree because it is close to the average node depth of the AVL tree, lying at most about 0.2 units below the AVL tree average node depth. To the scale of the graph, the two can't be distinguished.</p><p><A NAME="rf3"><A HREF="0012pf3.htm">Figure 3</A> shows the results from taking the AVL tree experimentation out to trees with 5000 nodes, again running 5000 random trees of each size. You see that the tree height approaches 10 percent more than the corresponding perfect tree, and the average depth comes in a bit under 15 percent less than the height of the corresponding perfect tree. This represents a marked improvement over the BST: For tree height, 1.1 versus 3; for average depth, 0.85 versus 1 1/3.</p><p>You do have to pay for this, of course, by the added AVL-adjustment logic on each insertion and deletion. For my implementations of these data structures, the insertions into AVL trees take approximately twice as long as insertions into BSTs where the question of node height is ignored. On the other hand, if you are using this tree data structure as a look-up table (where most accesses are finds rather than inserts or deletes), the denser organization will double throughput on average. In addition, if your look-up table is generated from data stored exactly in order, you will still easily generate an efficient tree structure for your look-ups, while the straight binary search tree would require explicit balancing to avoid the worst-case behavior of a degenerate tree (effectively, just a linked list).</p><p>Since Adel'son-Velskii and Landis proposed their self-adjusting data structure, there have been numerous others proposed, each claiming some improvement on the AVL tree. All of these, however, are more complex than the original AVL tree, both in concept and in implementation, and the AVL tree provides attractive performance with a simple implementation.</p><h3>References</h3><p>Binary search trees are discussed in all introductory texts on the topic of data structures. Some of those texts also discuss the self-adjusting binary search trees, and more extensive information is available on all of these topics in the more advanced data structures texts. The information on random binary search trees is from Robert Sedgewick and Philippe Flajolet's <i>An Introduction to the Analysis of Algorithms</i> (Addison-Wesley, 1996). The information on the worst-case AVL tree height is from Mark Allen Weiss's <i>Algorithms, Data Structures, and Problem Solving with C++ </i>(Addison-Wesley, 1996). This is the text for the data-structures course I am teaching at Eastern Washington University. In addition to the fundamental BST and the AVL tree, Weiss also discusses several of the more recent self-adjusting trees (2-3 trees, red-black trees, and splay trees). In January 1994, <i>DDJ </i>published an article by Bruce Schneier with the title "Skip Lists" about an alternative structure for look-ups.</p><h3>Online Resources</h3><p>The file AVL.ZIP is available electronically (see "Resource Center," page 5). When expanded, it generates the source code used to obtain the statistics for the average depths of AVL trees -- appropriate class files and two main program files (one to generate all permutations up to a maximum tree size, the other to generate random permutations). The mains are even written (under Linux on a dual-processor machine) to generate each of these statistics in two parallel computations. In addition, there is an RTF file giving a single sheet with exact figures and references for quantities with approximate values.</p><p></p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>void BST::Insert( BSTnode* &amp;Node, const Data &amp;Value ){   if ( Node == NULL )  // failure point --- recursion base case      Node = new BSTnode(Value);  // change Node (reference parameter)   else if ( Value &lt; Node-&gt;Value )      Insert(Node-&gt;Left, Value);  // recurse left   else                           // equal keys go right      Insert(Node-&gt;Right, Value); // recurse right} </pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>void AVL::RotateRight(BasePtr &amp;Rt)// Rotate rightward --- right node moves down, left node moves up.{  BasePtr  Lt = Rt-&gt;Left,            Q  = Lt-&gt;Right;x   Lt-&gt;Right= Rt;   Rt-&gt;Left = Q;   HtAdjust (Lt);  // Shifting Q may well have changed Lt and Rt heights   HtAdjust (Rt);   Rt = Lt;        // Change the link itself that was passed by reference} </pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>void AVL::AVLadjust ( AVLnode* &amp;Node ){//We presume the AVL class has access to AVLnode's Height data member   int Lht = Node-&gt;Left  == NULL ? -1 : Node-&gt;Left-&gt;Height,       Rht = Node-&gt;Right == NULL ? -1 : Node-&gt;Right-&gt;Height,       Diff = Lht - Rht;   if ( abs(Diff) &lt; 2 ) // AVL condition is met      HtAdjust(Node);   // May need to adjust the height anyway   else if ( Lht &gt; Rht )// Left side two longer than right   {  int Lck = Node-&gt;Left-&gt;Left  == NULL ? -1 : Node-&gt;Left-&gt;Left-&gt;Height,          Rck = Node-&gt;Left-&gt;Right == NULL ? -1 : Node-&gt;Left-&gt;Right-&gt;Height;      if ( Lck &lt; Rck )         RotateLeft (Node-&gt;Left); // Make left the longer      RotateRight (Node);         // Adjust Node itself      HtAdjust(Node);             // Update current node's height   }    else  // Mirror image logic to that above:  Right is two longer than left   {  int Lck = Node-&gt;Right-&gt;Left  == NULL ? -1 : Node-&gt;Right-&gt;Left-&gt;Height,          Rck = Node-&gt;Right-&gt;Right == NULL ? -1 : Node-&gt;Right-&gt;Right-&gt;Height;      if ( Lck &gt; Rck )         RotateRight (Node-&gt;Right);       RotateLeft (Node);       HtAdjust(Node);   } } </pre><P><A HREF="#rl3">Back to Article</A></P></body></html>