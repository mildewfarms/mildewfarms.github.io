<html><head><title>Dec00: Building an  OS-Aware Debugger</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Building an  OS-Aware Debugger</h1><p><i>Dr. Dobb's Journal</i> December 2000</p><h2>Let your  RTOS do the work</h2><h3>By Stewart Christie</h3><I>Stewart is a senior engineer for Intel. He can be contacted at stewart.christie@intel.com.</I><hr><p>Debugging applications developed to run under real-time operating systems (RTOS) can be a difficult process. For one thing, it can be difficult for you to follow program flow. Imagine, for example, that the RTOS performs a task switch when you are stepping through a task investigating a bug. This can be as simple as entering the kernel and performing routine housekeeping tasks, then resuming the task being debugged. Because the monitor is part of the kernel, it can effectively suspend the debugging of kernel code and resume the debug session after the exit from the kernel. However, if a task switch occurs and a different task is resumed, then the Task window in the debugger will be updated. Source-level debugging of GNU-compiled and -linked applications highlight the active task.</p><p>Another typical problem scenario involves tasks that can't be stopped. To support tasks such as the watchdog timer (used in real-time systems to allow unattended recovery/shutdown of errant systems), three debug modes are typically implemented:</p><DDJADVERTISEMENT INLINE><ul>  <li>Standard Monitor Debug Mode.  <li>System Debug Mode (SDM).  <li>Task Debug Mode (TDM).</ul><p>To debug system problems, the Standard Monitor Debug Mode can be used without additional communication with the OS. The debugging of tasks can be done either in a System Debug Mode or in Task Debug Mode. In System Debug Mode, the whole system stops if the monitor gets control of a task. In Task Debug Mode, only the current task is stopped, but the monitor lets the system continue with any other tasks.</p><p>One solution to these kinds of problems is to use debuggers that are operating-system aware. With an OS-aware debugger, you can, for instance, access OS-specific structures and elements in an easy- to-view format, thereby increasing productivity. Without the task awareness of an OS-aware debugger, on the other hand, you must decode the raw data by hand -- a difficult, time-consuming, and error-prone process. OS-aware debuggers also let you view task-description blocks in a Task Window in their native format. This lets you immediately see the tasks that are, for example, blocked waiting on a semaphore. With nonOS-aware debuggers, you have to view the task-description block in a memory window as a series of bytes or words.</p><p>Similar benefits arise when looking at messaging structures, such as queues and FIFOs. With OS-aware debuggers, the debugger takes care of decoding all the links and structures and presents the data in a user-friendly manner. If your OS will support it, then your debugger can be used to set complex task-specific breakpoints, from simple ones that say "break on every task switch" to more complicated conditions, such as "break on executing <i>printf()</i>, but only if the SEND task is active." The benefits of these complex breakpoints are easily appreciated when you have a problem such as one task sending spurious data to the <i>printf()</i>. If you used a standard debugger, then you would have to examine every execution of the <i>printf()</i> to isolate the problem. With a task-aware debugger, however, you can isolate the tasks you suspect and ignore previously tested code.</p><p>There are numerous other occasions in which adding OS-aware features can either enhance the usability of the debugger or simply make the debugging task less onerous. For example, an OS-aware debugger can take advantage of the OS load functionality; tasks can be loaded by the debugger, allowing for an upgrade of the system while on line. You can use this load functionality to replace a faulty or inoperable task or incrementally add extra tasks to determine response time and processor burden.</p><h3>Making Debuggers OS Aware</h3><p>There are two different ways to make a debugger OS aware. The easiest approach is to make use of existing debug hooks in the operating system. This is the method we use in the XDB Debugger for pSOS from CAD-UL (http://www.cadul.com/; the company I used to work for). XDB connects directly to -- and speaks the language of -- pROBE, the standard console debugger supplied with the operating system. This method is also used in the Linux debugger I describe here, although some kernel patches and a user module were also required to get the necessary level of integration.</p><p>The second approach to debugger integration is used when there aren't any debug hooks for connecting to the OS. With this approach, you must add code to the monitor/debugger. This is the approach taken with the Real-Time Linux <i>RTL_monitor. </i>Essentially, RTLinux (http:// www.fsmlabs.com/) is a modification to the standard Linux kernel, which adds traditional hard real-time features (similar to the VenturCom add-in for Windows Embedded NT). For an in-depth description of RTLinux, see "Inside Real-Time Linux," by Jerry Epplin, <i>DDJ</i>, March 2000.</p><p>Linux thread debugging has forced modifications to the kernel source files. When a <i>fork()</i> system call is taken in a typical OS and a new process/task is created from the original task, then new code, data, and stack space are allocated and the original process is copied to this new memory location. To speed up the system, Linux operates a copy-on-write feature that defers the actual copying of a memory page until a request is made to write to one of the copies. This method can realize significant time savings because it avoids unnecessary paging of memory to and from the much slower secondary storage on disk.</p><p>Contrast this with the threads created using the <i>clone()</i> system call. When a thread is created, the same data and code segments are used as the original, but each new thread is given its own stack. If a process is being debugged and it already contains a software breakpoint, then it will be active in the next thread, but no breakpoint handler is active. Because the monitor is not normally aware of this new thread, the thread runs on its own and ultimately fails. To overcome this problem, the <i>Cadulclone()</i> function is added to the kernel to inform the monitor that a thread has been created, and that it must be attached to the monitor using the <i>ptrace()</i> system function.</p><p>If a breakpoint is subsequently requested in either copy after the thread is created, then the Linux copy-on-write feature lets one thread remain intact and the breakpoint is set in the other copy. Patched versions of the affected kernel files are supplied with the monitor source files. <A NAME="rf1"><A HREF="0012jf1.htm">Figures 1</A> and <A NAME="rf2"><A HREF="0012jf2.htm">2</A> list the files modified in the kernel.</p><p>From simple round-robin schedulers to traditional RTOS with task switching and intertask messaging, most operating systems have either a subset of the available debug hooks or something that can be easily modified to provide these hooks. Fortunately, it isn't necessary to implement all the features in one session -- you add only the features you need.</p><p>Both implementations I discuss here are based on CAD-UL's XDB ROM Monitor debugger. XDB is a remote cross-debugging client, currently available on Win32 and Sun Solaris systems. This version of XDB works together with a protected-mode ROM monitor loaded on the target. A communication link between the target Linux system and the host is used for transmission of data from the debugger to the monitor.</p><p>In <A NAME="rf1"><A HREF="0012jf1.htm">Figure 1</A>, the RTLinux implementation, Linux is running as a real-time task along with other real-time tasks. Apart from the idle task, Linux is actually the lowest priority task on this system. This is a traditional RTOS with little in the way of debugger hooks. <A NAME="rl1"><A HREF="#l1">Listing One</A> (moninit.c) handles much of the direct translation between the OS and monitor. For instance, the <i>OSGetTaskID</i> function returns the current task identifier by reading it directly from the RTLinux structure <i>rtl_sched[0].rtl_current</i>.</p><p>In contrast, <A NAME="rf2"><A HREF="0012jf2.htm">Figure 2</A>, which illustrates the Linux <i>user_monitor</i>, outlines a modified approach used when the OS supports some debug hooks. The <i>user_monitor</i> section of the monitor is run as a Linux process and uses the system calls <i>ptrace()</i> and <i>ioctl()</i> to interface to the OS information. There is a small <i>user_ module</i> that is added to the kernel to facilitate communication between the kernel and user space. Modifications to a few of the kernel files have been made to inform the monitor of a debugged program exiting or of the creation of a new thread.</p><h3>When the GNU  Debugger Just Isn't Enough</h3><p>Linux system developers for x86 systems can use only the GCC tools to compile Linux because no other compilers are supported. When developing an application to run on Linux, it makes sense to use the GNU debugger (GDB) as well as GCC. However, these debugger system calls and hooks are available only on a working system. Thus, the first step is to get Linux running on the target system.</p><p>It is important to understand the differences between the development process required for Linux running on a typical PC and running it on an embedded system. <A NAME="rf3"><A HREF="0012jf3.htm">Figure 3</A> outlines the basic differences between a desktop PC and a videophone in a visual format. Both are x86 systems, but the similarity ends as soon as you look at the hardware interfaces. Porting Linux to a known hardware platform is relatively easy, especially with tools from the likes of Red Hat and Caldera. However, while these vendors supply a list of supported motherboards, hard drives, and network cards, it is still likely that none of the devices on the embedded system would make this list. Thus, taking a standard PC and removing the display and keyboard and making a headless system is not for the faint of heart. Fortunately, companies that produce adaptation kits for even this scenario have sprung up. (Check out HardHat Linux from Montavista Software, http://www .montavistasoftware.com/ and Embedix from Lineo, http://www.lineo.com/, for supported versions of Linux that have been specifically designed for embedded development.)</p><h3>Up and Running</h3><p>Getting embedded hardware up and running to boot Linux requires patience and hard work. Although prototype systems might use a floppy disk drive, there isn't a hard drive to hold the Linux installation -- it must be loaded to the flash memory. This means that you can't use the standard IDE utilities that partition disks when installing Linux on a desktop. The next obstacle is the lack of support for the custom LCD display. This engenders problems with the BIOS, which assumes there is both a standard keyboard and standard screen. Due to these technical challenges, an emulator is usually required to debug the startup code. This was, in fact, the scenario for one of our large communications customers when I worked at CAD-UL, and it was the impetus for the RTLinux and user-level monitor development I describe here.</p><p>Source-level debugging of GNU-compiled and GNU-linked applications is available by processing the a.out file using the DBG2BD GNU filtering utility. This filter can process many flavors of x86 GCC output, including a.out elf/dwarf and coff/stabs++. <A NAME="rf4"><A HREF="0012jf4.htm">Figure 4</A> outlines this process. To get source-level visibility in the debugger, the output from the GNU linker must be processed to convert the symbol table information into a format that the XDB debugger can load. The BD symbol file can also be loaded into any emulator version of the XDB debugger, thereby giving emulator support to any GNU user.</p><p>Multiple options exist for modifying DBG2BD's operation, belying the tool's original incarnation as a part of the embedded developer's toolset. For example, although I'm assuming the use of Linux here, the filter can process files for WindRiver Systems' VxWorks, or any operating system that uses the GNU x86 Compiler tools. The utility generates two files from the output of the GNU linker. The first, the BD file contains the converted symbol tables and is retained on the host side; second, the HX file contains the executable code and constant data. The BD file is a proprietary symbol file format used by all of CAD-UL's debuggers. This provides two options:</p><ul>  <li>You can load this file into the Linux or RTLinux XDB and connect to the monitor.  <li>You can load it into any of the x86 emulators that XDB supports to get hardware-assisted debugging. If necessary, the HX file can be downloaded directly to the target memory, using the debugger.</ul><p>Once our customer's engineers successfully ported standard Linux to their custom target, they decided to stay with the same XDB debugger client for programming the RTLinux modifications and for application development. This enabled an easy transfer for programmers through different stages of the project, because only one debugger user interface had to be learned. There was also the added benefit of being able to plug in an in-circuit emulator if a difficult problem arose in the application development phase.</p><h3>OS Function Calls and the Monitor</h3><p>Our customer's engineers used CAD-UL's Protected Mode monitor to perform all the regular tasks any monitor is required to do. The monitor handles communication with the host debugger, parses the commands, and performs reading and writing of the target memory and registers. In addition, it can perform Run Control to start and stop execution and control breakpoints. However, normally it cannot handle OS-specific functions such as reading OS task lists or loading a task using the debugger. To enable these features and others, we've developed a standard mechanism to add OS extensions to the target monitor.</p><p><A NAME="rl2"><A HREF="#l2">Listing Two</A> lists the functions supported by the monitor and XDB. The interface between monitor and OS consists of a set of functions and monitor service calls (SVC) to exchange information about the system and the tasks. The SVCs are invoked by a user-definable software interrupt in a manner similar to the regular PC BIOS int13 and int20 interrupts. With this interface, a complete handling of debugging efforts for operating systems is possible. Because the interface and monitor don't contain any assumptions about the operating system, there are no restrictions on the operating system.</p><p>The interface to the operating system allows the display and control of tasks, task-specific breakpoints and complex, or OS-specific breakpoints. A pseudo Task Switch Selector (TSS) data structure, based upon the standard x86 TSS, passes information such as register values and flags between the monitor and the OS.</p><p>The execution control is split between the monitor and operating system. The operating system suspends and activates tasks as usual. The monitor tells the operating system if a task is in debug mode or not; it also tells the OS if it can be resumed to run on its own or if, for example, the single-step trap flag should be set.</p><p>Direct system commands can be used in the debugger by using the <i>OS_command</i> functions. This could be used to perform, for example, an "ls /proc"; the results can be returned to a window in the debugger, either directly or via the <i>OS_Get_Output</i>. The load functionality is extended to support OS-loadable files, which can be loaded by the operating system. The relocated address information is returned to the debugger, where it is used to relocate the debug symbol information.</p><p>A <i>struct</i>, (<i>osCalls</i>), is filled with pointers to OS-specific functions, as in <A NAME="rl1"><A HREF="#l1">Listing One</A>, an excerpt from the program Init.c (available electronically; see "Resource Center," page 5). First, the <i>struct</i> is cleared and then the flag element is loaded with a bitwise-OR of a defined list of contents. The specific bit for each function is defined in the CAD-UL-supplied MON386 manual. <A NAME="rl1"><A HREF="#l1">Listing One</A> shows the <i>#define</i>s for all the supported functions. For example, the OS_TASK_LIST bit in the flag is bit 0 and the OS_LOAD_INFO bit is defined as bit 11. For each bit set in the flag element, a corresponding function call must be supplied. Unused bits should be set to 0, and unused functions should have a null pointer, to allow an error message to be returned to the debugger if a mismatched monitor and debugger are invoked.</p><p>There are currently a total of 19 separate extension function types implemented in the debugger and monitor that are essentially similar in their implementation. Here, I'll use the <i>OS_Task_List</i> function  as an example.</p><p><A NAME="rl3"><A HREF="#l3">Listing Three</A> (again from Init.c) shows the <i>wrapper</i> function used to perform near/far pointer conversion. This function, <i>callOSTaskList</i>, is the one loaded into the <i>osCalls struct</i> in lines 687-699 in <A NAME="rl3"><A HREF="#l3">Listing Three</A>. It is used to build up a window of task states by repetitive calls. The function will return 0 when there are no more tasks in the list, otherwise it returns the ID number of the next available task. This method of returning both an element and a status byte that can be queried about any remaining elements is used throughout the implementation. This flexibility is used to allow for the retrieval and display of multiline OS Error Messages of an indeterminate length by recursively calling the same routine until all of the message is retrieved. If a task number of -1 is requested, then the function will return the total number of tasks in the OS.</p><p><A NAME="rl3"><A HREF="#l3">Listing Three</A> calls <i>pOSTaskList</i>, which is initialized to point to <i>OSTaskList</i> by the <i>init_module</i> routine found in the moninit.c file. <i>init_module</i> is called automatically on the monitor being loaded into the kernel and is also used to hook the monitor communication routines into the desired com-port interrupt handler. <A NAME="rl4"><A HREF="#l4">Listing Four</A> shows the essential parts of the <i>OSTaskList</i> routine. The <i>GetTask</i> routine is called to obtain the specific information about the requested task. <i>GetTask Call()</i> converts the RT-task information into the format expected by CAD-UL's OS-aware function calls. While it has some specific RT pieces, it is similar to the Linux version in <A NAME="rl5"><A HREF="#l5">Listing Five</A>. The true difference between the operating systems is evidenced by the <i>GetTask</i> routines. RTLinux information is read from the actual structures used in the RT kernel. Linux task or, more correctly, process information is read from the /proc filesystem directory entry for the process being debugged.</p><p>To summarize what happens when users open the Task List window in the debugger, this procedure is implemented:</p><p>1.	XDB requests the number of tasks, by calling OS Extension Function #1 with a task number parameter of -1.</p><p>2.	The monitor code performs a lookup to get the address of this function #1 from the osCalls struct. This points to the <i>callOSTaskList()</i> routine.</p><p>3.	After performing the near/far conversion, <i>callOSTaskList()</i> then calls the function pointed to by <i>pOSTaskList</i>.</p><p>4.	This was initialized on being loaded into the kernel to point to <i>OSTasklList()</i> and this routine is the first that looks at the data that was passed, for example -1.</p><p>5.	The <i>GetTaskCount()</i> routine is called and the answer is passed back to the debugger after another near/far conversion is performed in the <i>callOSTaskList()</i> routine.</p><p>6.	At this stage, XDB now has the number of tasks needed to fill the Task window; thus, it performs a call for each task, one by one, and is returned the task state, name, and ID number.</p><p>7.	When the highest numbered task state is requested, the returned value indicates that there are no more and the completed window is displayed.</p><p></p><p>In this implementation for Linux, users then have the option of selecting any of the tasks in the Task window and requesting further information. There is always a trade-off in developing a remote debugger client between displaying all the information at once and the time needed to interrogate the OS and retrieve the data for the display. With a fast TCP/IP connection and relatively few tasks, this does not present a problem, but the same debugger may need to work over a much slower serial link. Not many embedded systems are running on a 650-Mhz Pentium III system, so uploading a large amount of data to the debugger may have a significant impact on the overall performance of the product. Quite often, an item is designed with minimum memory and minimum speed to keep the power demands as low as possible.</p><p>In contrast to the RTLinux implementation, the regular Linux monitor differs only in the final details of the <i>GetTask()</i> call. Instead of reading an internal structure that contains the task information as in RTLinux, the Linux /proc filesystem is read using standard operating system <i>open()</i> and <i>read()</i> calls. <A NAME="rl5"><A HREF="#l5">Listing Five</A> is a section of the Linux file linuxos.c. It is easy to see the similarity between this file and the RTLinux version in <A NAME="rl4"><A HREF="#l4">Listing Four</A>.</p><h3>Implementing Extensions  For a Proprietary or Custom OS</h3><p>Whether you are using a large OS such as Linux -- as did our customer -- or a traditional RTOS, both dictate where to start adding in OS-aware features to your debugger. If you can modify something existing, then you can both reduce development time now and can lower subsequent maintenance costs each time a new release comes along.</p><p>Getting access to the OS developer or someone who is very familiar with the implementation is essential. Very few embedded operating systems are implemented as they are delivered. Commercial real-time operating systems are now available in source form, but even the traditional large vendors supply customization routines and multiple pieces that can be added or not, depending upon your needs.</p><p>To get started, obtain an evaluation copy of a commercial RTOS and the development tools and perform a thorough evaluation. Consider new visualization tools for gaining visibility into a running OS, using a completely separate task that logs data and presents it graphically. When compared to extending an existing monitor, this solution might more closely meet your needs because it presents a dynamic view of the data, rather than the snapshots available with a traditional debugger.</p><p>If you are already using a commercial RTOS, then some of the smaller vendors may be willing to trade OS licenses for the work you are doing, to allow them to pass on the benefits of an OS-aware debugger to present and future customers. Developing a good relationship with your OS company, in these days of consolidation, is recommended.</p><h3>Conclusion</h3><p>A complete set of code for the RTLinux Monitor for Beta 5 of RTLinux and the Linux User Monitor for the Version 2.2.11 kernel is available at the time of writing. Future versions will support RTLinux Version 2 and the Version 2.2.13 of the Linux kernel. This code and an evaluation version of the XDB debugger is available for download at http://www.cadul.com/ tools/ddj/. This version of the debugger is limited to a maximum of 10 source modules and 1000 symbols. A time-limited license that will remove this size restriction is available by sending an e-mail request to ddj_linux@cadul.com.</p><p></p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>  ....  memset(&amp;osCalls, 0, sizeof(osCalls));     osCalls.flag = OS_TASK_LIST | OS_TASK_INFO | OS_GET_TASK_ID |             OS_LOAD_INFO | OS_QUERY | OS_COMMAND | OS_GET_ERROR_MESSAGE;     osCalls.OS_Task_List = callOSTaskList;     osCalls.OS_Task_Info = callOSTaskInfo;     osCalls.OS_Get_Task_ID = callOSGetTaskID;     osCalls.OS_Load_Info = callOSLoadInfo;     osCalls.OS_Query = callOSQuery;     osCalls.OS_Command = callOSCommand;     osCalls.OS_Get_Error_Message = callOSGetErrorMessage;  m386_setOScalls((OS_calls_t far *)&amp;osCalls);  .....</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>/* Function Pointers */#pragma noalign  (s_calls)typedef struct s_calls {  OS_int flag;  /* flag for available functions */#define OS_TASK_LIST     (1 &lt;&lt;  0)#define OS_TASK_INFO     (1 &lt;&lt;  1)#define OS_SET_TASK     (1 &lt;&lt;  2)#define OS_GET_TASK     (1 &lt;&lt;  3)#define OS_GET_TSS     (1 &lt;&lt;  4)#define OS_SET_TSS     (1 &lt;&lt;  5)#define OS_GET_TASK_ID     (1 &lt;&lt;  6)#define OS_COMMAND     (1 &lt;&lt;  7)#define OS_GET_OUTPUT     (1 &lt;&lt;  8)#define OS_GET_ERROR_MESSAGE    (1 &lt;&lt;  9)#define OS_LOAD      (1 &lt;&lt; 10)#define OS_LOAD_INFO     (1 &lt;&lt; 11)#define OS_SET_COMPLEX_BREAKPOINT_CONDITION  (1 &lt;&lt; 12)#define OS_GET_COMPLEX_BREAKPOINT_CONDITION  (1 &lt;&lt; 13)#define OS_DELETE_COMPLEX_BREAKPOINT_CONDITION (1 &lt;&lt; 14)#define OS_QUERY     (1 &lt;&lt; 15)#define OS_GET_FPU     (1 &lt;&lt; 16)#define OS_SET_FPU     (1 &lt;&lt; 17)#define OS_BREAK     (1 &lt;&lt; 18)/*  1 */OS_int far (*OS_Task_List)(OS_asbyte, OS_task_t far *);/*  2 */OS_int far (*OS_Task_Info)(OS_int, OS_msg_t far *);/*  3 */OS_int far (*OS_Set_Task)(OS_int, OS_int, OS_int far *);/*  4 */OS_int far (*OS_Get_Task)(OS_int far *);/*  5 */OS_int far (*OS_Get_TSS)(OS_int, OS_tss_t far *, OS_void far *);/*  6 */OS_int far (*OS_Set_TSS)(OS_int, OS_tss_t far *);/*  7 */OS_int far (*OS_Get_Task_ID)(OS_asbyte, OS_byte far *);/*  8 */OS_int far (*OS_Command)(OS_asbyte, OS_byte far *, OS_msg_t far*);/*  9 */OS_int far (*OS_Get_Output)(OS_asbyte, OS_asbyte, OS_msg_t far*);/*  0 */OS_int far (*OS_Get_Error_Message)(OS_asbyte, OS_err_t far *);/* 11 */OS_int far (*OS_Load)(OS_asbyte, OS_byte far *, OS_msg_t far *);/* 12 */OS_int far (*OS_Load_Info)                     (OS_asbyte, OS_asbyte, OS_byte far *,OS_load_t far *);/* 13 */OS_int far (*OS_Set_Complex_Breakpoint_Condition)                    (OS_asbyte, OS_byte far *);/* 14 */OS_int far (*OS_Get_Complex_Breakpoint_Condition)                    (OS_asbyte, OS_msg_t far *);/* 15 */OS_int far (*OS_Delete_Complex_Breakpoint_Condition)(OS_long);/* 16 */OS_int far  (*OS_Query)(OS_asbyte, OS_byte far *, OS_msg_t far*);/* 17 */OS_int far  (*OS_Get_FPU)(OS_int, OS_fpu_t far *);/* 18 */OS_int far  (*OS_Set_FPU)(OS_int, OS_fpu_t far *);/* 19 */OS_int far  (*OS_Break)(OS_int *);#define OS_CALLS_MAX 19} OS_calls_t;</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>/* --------------------------------------------------------------------- * MethodName: callOSTaskList * --------------------------------------------------------------------- * Description: wrapper function for near/far pointer conversion; * OSTaskList  can be found in file 'moninit.c' * --------------------------------------------------------------------- * Access: global * --------------------------------------------------------------------- * Parameter: length * ----------------------------------------- * Parameter: pTask *            pointer to caller's task structure to be filled * --------------------------------------------------------------------- * Return: OS_SUCCESS, for successful result * --------------------------------------------------------------------- * Pre: none * --------------------------------------------------------------------- */OS_int far callOSTaskList(OS_asbyte length, OS_task_t far* pTask){ struct OS_near_task task; OS_int   result; task.ID = pTask-&gt;ID; task.state = pTask-&gt;state; task.length = pTask-&gt;length; task.name = (OS_byte*)pTask-&gt;name; result = (*pOSTaskList)(length, (OS_task_t*)&amp;task); pTask-&gt;ID = task.ID; pTask-&gt;state = task.state; pTask-&gt;length = task.length; pTask-&gt;name = (OS_byte far*)task.name; return result;}</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>OS_int OSTaskList(OS_asbyte n, OS_task_t* pTask){ pthread_t p; ... p = GetTask(n); if (p) {  static char szBuffer[20];  sprintf(szBuffer, "%08x", p);  pTask-&gt;ID = (OS_int)p;  pTask-&gt;state = p-&gt;state;  pTask-&gt;length = 9;  pTask-&gt;name = szBuffer; } else {.....      }      return n == GetTaskCount() - 1 ? OS_NONE : n + 1;}pthread_t GetTask(int n){ int  I = 0; pthread_t p = rtl_sched[i].rtl_tasks; for (i = 0; I &lt;= n &amp;&amp; p != 0; i++) {  // first element is 0, second is 1, etc.  if (i == n)  {   return p;  }  p = p-&gt;next; } return NULL;}</pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five</H4><pre>OS_int OSTaskList(OS_asbyte n, OS_task_t* pTask){ struct task* p; p = GetTask(n); if (!p) { pTask-&gt;ID = p-&gt;pid; pTask-&gt;state = p-&gt;state; pTask-&gt;length = strlen(p-&gt;cmdline) + 1; pTask-&gt;name = (void*)&amp;(p-&gt;cmdline); if (p-&gt;pid == GetAttachedProcessID()) {  pTask-&gt;state = OS_DEBUG; } return n == GetTaskCount() - 1 ? OS_NONE : n + 1;}</pre><P><A HREF="#rl5">Back to Article</A></P></body></html>