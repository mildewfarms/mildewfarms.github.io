<html><head><title>Dec00: C Programming</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Quincy 2000:  Customizing the Print Dialogs</h1><p><i>Dr. Dobb's Journal</i> December 2000</p><h3>By Al Stevens</h3><I>Al is a DDJ contributing editor. He can be contacted at astevens@ddj.com.</I><hr><p>I'm writing this column from a most unlikely place to be thinking about C++ programming. I'm seated at the laptop in my stateroom on the Disney Magic -- that huge cruise ship you see so often in TV commercials, the one with chipmunks, mice, and ducks running around, not to mention Cinderella, Alice in Wonderland, Goofy, and other lovely creatures.</p><p>I'm here because I had a free week and the ship needed a piano player. It came about rather quickly. I got the call Friday and sailed Saturday, and here I sit in the lap of luxury pounding out a column. When you work on a cruise ship, you go under either crew status or guest status. Crew members dwell and dine below in the low-rent district and do not avail themselves of the ship's amenities. They can't even show themselves to the guests except when duty requires their appearance, waiting tables or dressed in a mouse getup. Guests, of course, spend their free time partaking of whatever the ship has to offer--restaurants, bars, a health spa, pools, hot tubs, the obligatory shuffle board deck, lounge chairs galore, even a basketball court. If you ever work on a cruise ship in any capacity, request guest status.</p><DDJADVERTISEMENT INLINE><p>When I say "free week," that doesn't mean free from programming and writing duties. It means a week with no obligations that require me to be somewhere other than the Bermuda Triangle chugging along at 25 knots, heading for my first port of call, St. Maarten. Luxury's lap, cushy though it may be, has its price, though. Because of deadlines, I'll spend most of each morning in the stateroom banging away on the laptop. But not before a stroll around the upper decks and, if the muse demands it, a Bloody Mary to kickstart the creative juices. After a morning at the laptop, I have various afternoon and evening sessions at the old 88 keyboard, and, in between, enough food and drink to feed a small third-world country and pretty much the run of the place.</p><p>After St. Maarten<b>,</b> we sail for St. Thomas in the Virgin Islands and then Disney's Castaway Cay in the Bahamas. Guest status piano players get full use of the islands, bars, and beaches, too. I could get used to this. If memory serves, this was how Hemingway worked. Just call me Papa.</p><h3>Quincy 2000 Grows</h3><p>A few weeks ago I released Quincy 2000 Build 1. For the benefit of new readers, Quincy is an IDE integrating a programmer's editor and debugger with the gnu-mingw32 port of the GNU C/C++ compiler suite. You can download Quincy's source code from <i>DDJ</i> (see "Resource Center," page 5) and from http://www.midifitz .com/alstevens/quincy2000/ along with the binaries, installation instructions, and revision history.</p><p>Last month I was struggling with the new programmer's editor, problems with row and column numbers on the screen, and line and character positions in the document. I got it working, and although I cannot brag that the design is more orderly than when I started, at least it is now software that you don't mess with because it "ain't broke." I hope.</p><p>I keep a mailing list of Quincy users so I can announce new builds. This core group of dedicated users has helped out ever since I released Quincy 96, sending bug reports and suggestions and significantly influencing Quincy's evolution. Send e-mail to astevens@ddj.com and ask to be added to the list. Following the release of Build 1, Jill Kiminsky requested an option to print line numbers on source-code listings. Jill is a teacher and uses Quincy in the classroom. Line numbers would make it easier for Jill to discuss specific parts of a program with her students. Since Quincy 2000 is meant to be a free platform for teaching and learning C++, I added the option.</p><p>Printing line numbers is easy, but the program needs a place to turn the option on and off. Quincy 2000 has a tabbed dialog for options, and using that would have been easy. But traditional Windows applications put print options on the Print and Print Setup dialog boxes, implemented in MFC with the <i>CPrintDialog</i> class. Customizing the dialogs is not an easy task. First, you have to know how MFC interacts with <i>CPrintDialog</i> and your code to support printing.</p><h3>MFC and Printing</h3><p>MFC's document/view architecture provides <i>CView</i> member functions for printing. You override and call these functions to print a document. This assumes three things: </p><p></p><ul>  <li>The Print, Print Preview, and Print Setup commands are on the File menu associated with the ID_FILE_PRINT, ID_ FILE_PRINT_PREVIEW and ID_ FILE_ PRINT_SETUP command IDs.   <li>None of the program's derived classes -- from <i>WinApp</i>, <i>CFrameWnd</i>, <i>CDocument</i>, and <i>CView</i> -- intercept and process the commands without calling the base class member functions they override.   <li>Your view classes override <i>CView::OnPreparePrinting</i>, <i>CView::OnBeginPrinting</i>, <i>CView::OnPrint</i>, and <i>CView::OnEndPrinting</i>, doing what's needed to print the document. </ul><p>Given those assumptions, choosing the Print command on the File menu calls <i>CView::OnFilePrint</i>, which instantiates a <i>CPrintDialog</i> object on the heap with default values taken from current printer settings. The object's address goes into a <i>CPrintInfo</i> structure, and <i>CView::OnFilePrint</i> calls <i>CView::OnPreparePrinting</i>, passing the <i>CPrintInfo</i> structure. Up until the call to <i>OnPreparePrinting</i>, everything happens in the murky depths of MFC.</p><p>To print the document, your derived view class overrides <i>CView::OnPreparePrinting</i>, which must call <i>CView::DoPreparePrinting</i>, which, in the dark again, opens and processes the modal common Print dialog box. If you choose OK, <i>CView::OnFilePrint</i> calls <i>CView::OnBeginPrinting</i>, which you override to get the printing parameters from the <i>CPrintInfo</i> object, which was initialized from the user's selections in the Print dialog. The dark side takes over again when <i>OnBeginPrinting</i> returns.</p><p>Then, for each document page, <i>CView::On</i>FilePrint calls <i>CView::OnPrint</i>, which you override to print the page. You get the current page number from the <i>CPrintInfo*</i> argument and use that value instead of counting pages, because you might have chosen a subset of the document's pages to print. After the last page is printed, <i>CView::OnFilePrint</i> calls <i>CView::OnEndPrinting</i>, which you override to do any cleanup.</p><p>After calling <i>CView::OnEndPrinting</i>, or if you choose Cancel on the dialog box during the execution of <i>CView::DoPreparePrinting</i>, <i>CView::OnFilePrint</i> deletes the <i>CPrintDialog</i> object on the heap.</p><h3>Adding a Checkbox </h3><p>That's how it works when everything is according to the book. The underneath stuff is uninteresting because it does what it is supposed to do. Applications that modify the Print dialog's behavior, however, usually do it by overriding the <i>CPrintDialog</i> class, which is what Quincy 2000 does. The documentation tells you to do that and to provide a custom dialog template. The documentation does not, however, tell you how to insinuate your custom dialog into the printing process or what control IDs to assign to the controls on the dialog so that everything in the base class still works. If you follow the directions in the documentation, you provide everything that <i>CView::OnFilePrint</i> already provides, and manage the internal coordination of the dialog's settings and the program's use of them, too. In other words, you have to do everything <i>CView</i> and <i>CPrintDialog</i> do, and it's all in the dark and undocumented.</p><p>Since all I want is a new checkbox, I shouldn't need a custom dialog template; there is room in the lower left corner of the existing dialog for one checkbox. Instead, I need to modify the behavior of <i>CPrintDialog</i> to keep its supporting code and the code in <i>CView::OnFilePrint</i>. <A NAME="rf1"><A HREF="0012nf1.htm">Figure 1</A> shows the modified dialog box for printing from Quincy 2000. It ought to be easy, right? Wrong. Not easy. But doable.</p><p>I had three problems to solve: </p><ul>  <li>How to specialize the class derived from <i>CPrintDialog</i> so it has a new checkbox control that the dialog reacts properly to.  <li>How to get an object of the specialized class installed in place of the <i>CPrintDialog</i> object the framework has already instantiated.  <li>How to get the Print Setup command to behave similarly.</ul><h3>Specializing <i>CPrintDialog</i></h3><p>When you use ClassWizard to define a class derived from <i>CPrintDialog</i>, you don't get much help. You don't get to assign an ID number to associate the dialog with the template that the documentation says you should build (which I decided not to do). You don't get member variables or the ability to add them. ClassWizard just builds the source code for a derived class. After that you do everything manually.</p><p>I derived a class from <i>CPrintDialog</i> and called it <i>CQuincyPrintDialog</i>. <A NAME="rl1"><A HREF="#l1">Listing One</A> is QuincyPrintDialog.h, the header file that defines <i>CQuincyPrintDialog</i> and <i>CLineNumberButton,</i> which derives from <i>CButton</i>. <i>CQuincyPrintDialog</i> includes an instance of <i>CLineNumberButton</i> named <i>lnobutton</i>, which is the checkbox I am adding. The <i>logfont </i>data member is a LOGFONT<i> </i>structure that defines the font the dialog box uses for text labels. The <i>printlinenumbers</i> variable is a <i>bool</i> that represents your selection of the line number printing option.</p><p><A NAME="rl2"><A HREF="#l2">Listing Two</A> is QuincyPrintDialog.cpp. <i>CQuincyPrintDialog::OnInitDialog</i> calls <i>GetFont</i> and <i>GetLogFont</i> to get the dialog's font into the <i>logfont</i> structure. The reason for this soon becomes apparent. Then <i>OnInitDialog</i> calls <i>Create</i> for <i>lnobutton</i> using the dialog's client window coordinates to compute where to put the checkbox.</p><p>CLineNumberButton::OnCreate uses the dialog's <i>logfont</i> structure as the font for its own label, which explains why I needed a specialized <i>CButton</i> class. If you add a simple <i>CButton</i> object to a dialog this way, the framework stupidly assigns it the default system font rather than the default dialog font, and the button looks weird.</p><h3>Substituting  <i>CQuincyPrintDialog</i> for <i>CPrintDialog</i></h3><p>Building a specialized Print dialog is one thing. Getting the framework to use it is another. I had to reverse engineer some MFC code. <A NAME="rl3"><A HREF="#l3">Listing Three</A> is an extract from Quincy 2000's <i>CEditorView</i> class member functions showing how it handles communicating with <i>CView</i>. I adapted the <i>OnBeginPrinting</i>, <i>PrintPageHeader</i>, and <i>PrintPage</i> functions from Jeff Prosise's code in <i>Programming Windows 95 with MFC</i> (Microsoft Press, 1996). This book, though unfortunately out of print, is one you should have if you are programming with MFC.</p><p>The first entry into your code after you choose the Print command is the view class's overridden <i>OnPreparePrinting</i> function. The framework has already allocated a <i>CPrintDialog</i> object on the heap and stored its address in the <i>CPrintInfo</i> object. Consequently, you have to delete the one the framework built and instantiate an object of your derived class, putting the object's address in the <i>CPrintInfo</i>'s <i>m_pPD</i> data member. The framework uses the base <i>CPrintDialog</i> class's implementation and behavior to manage the printer selection and configuration process. The framework also takes care of deleting your object, thinking it is deleting its own object.</p><p>That's all there is to putting a specialized Print dialog in an application as long as you can modify the common dialog's template at run time. (Programs that need drastic changes to the dialog's format and appearance can't take this easy way out.)</p><h3>Specializing <i>CPrintSetupDialog</i></h3><p>Applications with Print commands usually have Print Setup commands, too. (An optional Page Setup command for applications controls margins and such, and the documentation suggests you use it instead of the Print Setup command. More about this later.)</p><p>The Print Setup command uses the <i>CPrintDialog</i> class, and the whole thing works in the dark. When users choose the command, the framework opens the dialog, gets the choices, and saves them away somewhere in the deep woods. When users choose the Print command, the most recent Print Setup choices are displayed in the Print dialog and vice versa.</p><p>The two dialogs use the same class, but different dialog templates. The first constructor argument is a BOOL that specifies which dialog to display. It follows that the <i>CQuincyPrintDialog</i> specialization ought to work with Print Setup, too. And so it does, but you have to know how to get inside <i>CView</i>'s inner workings to apply the specialized dialog class in place of the regular one. The secret is to find out what the framework does when the user chooses the Print Setup command. Remember, menu commands can be processed by the <i>application </i>class, <i>frame </i>class, <i>document </i>class, <i>view </i>class, or any combination of all of them. Print Setup ought to be unrelated to any particular instance of a document or its view and unrelated to the frame window, too. Consequently, I started a search for related code in the <i>CWinApp</i> class and, sure enough, I found the undocumented function in <A NAME="re1"><A HREF="0012ne1.htm">Example 1</A>. It's undocumented because the online help that tells you all about the <i>CWinApp</i> overridable functions does not list it. Yet there it is, and your derived application class can override it. It instantiates a <i>CPrintDialog</i> object on the stack frame, specifying a Print Setup dialog, and passes the object to another undocumented <i>CWinApp</i> member function named <i>DoPrintDialog</i>. Somehow, down in the depths of the relationship between <i>CWinApp </i>and <i>CView, </i>the user's choices get passed along. I didn't care how, though, once I realized I just needed to override <i>CWinApp::OnFilePrintSetup</i> in my application class. <A NAME="re2"><A HREF="0012ne2.htm">Example 2</A> is that overriding function. <A NAME="rf2"><A HREF="0012nf2.htm">Figure 2</A> is the modified Print Setup dialog box.</p><h3>And Now for the Gotcha</h3><p>Every success story has a gotcha, and this one is no exception. First some background.</p><p>A Win32 program has a lot of ID codes floating around. Developer Studio tries to maintain them as mnemonic global symbols. The standard ones, ID_FILE_OPEN and ID_EDIT_COPY, for example, have fixed numeric values assigned. Your program adds new command values as it needs them. There are IDs for commands to identify dialogs, to identify controls, and so on. The program communicates the user's actions by passing these ID codes around and, again, a lot of it happens in the dark. </p><p>It follows that the common dialog classes, which use common dialog templates, appropriate a range of codes that application programs avoid. Developer Studio tries to keep all these codes separate by maintaining independent ranges of values. When you use the Resource Editor to add a control to a dialog and give it a name, such as IDC_AUTOINDENT, Developer Studio assigns a number to the name, puts a <i>#define</i> statement in resource.h, and uses the name throughout the code that Developer Studio generates to support the control.</p><p>Recall that ClassWizard and Developer Studio don't help much when you derive from common dialog classes. The <i>CLineNumberButton</i> object needs an ID code. I chose the name IDC_LINENUMBERS and manually added a <i>#define </i>entry to resource.h, using the next available numeric value, which was 1060. Resource.h has <i>#define</i>s at the end that specify the next highest available numbers in each of the ranges, which Developer Studio uses to assign new numbers. I updated that number to 1061, which is when the trouble started.</p><p>While testing, I opened the Print Setup dialog and changed the printer selection to the HP Laserjet 4MP, whereupon the new checkbox was checked, disabled, and grayed out. All by itself. That was the gotcha, and it was an odd one indeed.</p><p>I won't bother you with the details of what I went through trying to unget the gotcha, but after a lot of code tweaking, I realized that the Print Setup dialog must be doing something to a control that had the same ID value as my checkbox, 1060. I found an available number well away from that one, changed the <i>#define</i> of IDC_LINENUMBERS, and the problem went away.</p><p>This was a mystery. None of the controls on the Print Setup dialog are changed when I select that particular printer. After some head scratching I concluded that Print Setup must use printer-device capabilities to enable and disable a bunch of controls, and that the procedures for Print Setup and Page Setup use common code. Something on the page setup dialog must use ID number 1060. I'm not using a Page Setup dialog, because Quincy users don't need to be changing margins and such, but the hidden code got in the way, nonetheless, and I got gotten by a gotcha.</p><h3>Pushing the Envelope</h3><p>Between getting the button installed, integrating the dialog, and fixing the phantom checkbox gotcha, I had a lot of false starts and made a lot of wrong turns during what ought to have been a simple job -- adding a checkbox to a dialog. I won't belabor the details because there's little to be learned from my mistakes, but I do complain that the literature fails me when it comes to explaining stuff like this. All the books that promise in their titles and on their back covers to reveal so-called secrets of Win32 MFC programming reveal very few actual secrets. Mostly what they do is explain how to write programs that stay within the boundaries that the designers of the Win32 API and MFC assumed you could live with.</p><p>Usually, I find those boundaries pertain only to the most trivial of applications, which is what books tend to use as examples, anyway. But when you want to push the envelope, break the bonds of convention, and escape those boundaries, forget the books. Your best bet is to trace the MFC source code and see what it's doing. Then you can decide what to override, what to specialize, what to replace, and how to do all that. Tracing through MFC's source code is easy enough. You can trace into it when your code calls a framework function, and you can set breakpoints in your own code and use the call stack to find where your code was called from in MFC. From there you can navigate into the MFC source code.</p><h3>Back to Reality</h3><p>Well, it looked for a while like I'd be here on the Disney Magic another week. The piano player I replaced is still on sick call, poor fellow, and they asked me to stay on. As part of the deal, I requested that Judy be permitted to join me so she could share my windfall of luxurious guest status tourism. But Disney management, operating on a tight budget, short on cash, and needing to reserve every possible space for paying guests, turned her down. They waited until the last day to let me know, too. Not knowing me very well, they figured I'm your typical desperate piano player who can't pass up a week's employment. Yeah, right. </p><p>In the meantime, I remain a busy guy with a full schedule. Let's see, right after the tour of the nude beaches of St. John Island I think I'm due for my personal massage. Or is it the wine-tasting party? Oh, bother, there's just too much debauchery for a guest piano player to keep track of.</p><p>Next month we add a second free compiler, Borland C++ 5.5, to Quincy 2000. But for now, I'll be on the ninth deck in the Quiet Cove bar sipping on a Mai Tai, tinkling "As Time Goes By," and dreaming about my next great work of literature.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>#if !defined(AFX_QUINCYPRINTDIALOG_H__                            64D73F03_7B38_11D4_B7A3_00207815827F__INCLUDED_)#define AFX_QUINCYPRINTDIALOG_H__                            64D73F03_7B38_11D4_B7A3_00207815827F__INCLUDED_#if _MSC_VER &gt;= 1000#pragma once#endif // _MSC_VER &gt;= 1000// QuincyPrintDialog.h////////////////////////////// CLineNumberButton classclass CLineNumberButton : public CButton{    DECLARE_DYNAMIC(CLineNumberButton)    CFont font;public:    CLineNumberButton();protected:    //{{AFX_MSG(CLineNumberButton)    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);    //}}AFX_MSG    DECLARE_MESSAGE_MAP()};/////////////////////////////////////////////////////////////////////////////// CQuincyPrintDialog dialogclass CQuincyPrintDialog : public CPrintDialog{    DECLARE_DYNAMIC(CQuincyPrintDialog)    CLineNumberButton lnobutton;    // print line number checkbox    static LOGFONT logfont;public:    bool printlinenumbers;  // publicly exposed for setting and testing    CQuincyPrintDialog(BOOL bSetup = FALSE);// Attributespublic:// Operationspublic:// Overrides    // ClassWizard generated virtual function overrides    //{{AFX_VIRTUAL(CMainFrame)    public:    //}}AFX_VIRTUALprotected:    //{{AFX_MSG(CQuincyPrintDialog)    virtual void OnOK();    virtual BOOL OnInitDialog();    //}}AFX_MSG    DECLARE_MESSAGE_MAP()};//{{AFX_INSERT_LOCATION}}// Microsoft Developer Studio will insert additional declarations //                                  immediately before the previous line.#endif // !defined(AFX_QUINCYPRINTDIALOG_H__                           64D73F03_7B38_11D4_B7A3_00207815827F__INCLUDED_)</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>// QuincyPrintDialog.cpp#include "stdafx.h"#include "quincy.h"#include "QuincyPrintDialog.h"#ifdef _DEBUG#define new DEBUG_NEW#undef THIS_FILEstatic char THIS_FILE[] = __FILE__;#endifLOGFONT CQuincyPrintDialog::logfont;////////////////////////////// CLineNumberButton classIMPLEMENT_DYNAMIC(CLineNumberButton, CButton)CLineNumberButton::CLineNumberButton(){}BEGIN_MESSAGE_MAP(CLineNumberButton, CButton)    //{{AFX_MSG_MAP(CLineNumberButton)    ON_WM_CREATE()    //}}AFX_MSG_MAPEND_MESSAGE_MAP()int CLineNumberButton::OnCreate(LPCREATESTRUCT lpCreateStruct) {    if (CButton::OnCreate(lpCreateStruct) == -1)        return -1;    font.CreateFontIndirect(&amp;CQuincyPrintDialog::logfont);    SetFont(&amp;font);    return 0;}/////////////////////////////////////////////////////////////////////////////// CQuincyPrintDialogIMPLEMENT_DYNAMIC(CQuincyPrintDialog, CPrintDialog)CQuincyPrintDialog::CQuincyPrintDialog(BOOL bSetup) :   CPrintDialog(bSetup, PD_ALLPAGES | PD_USEDEVMODECOPIES | PD_NOSELECTION, 0){    m_pd.nMinPage = 1;    m_pd.nMaxPage = 0xffff;    printlinenumbers = false;}BEGIN_MESSAGE_MAP(CQuincyPrintDialog, CPrintDialog)    //{{AFX_MSG_MAP(CQuincyPrintDialog)    //}}AFX_MSG_MAPEND_MESSAGE_MAP()BOOL CQuincyPrintDialog::OnInitDialog() {    CPrintDialog::OnInitDialog();    GetFont()-&gt;GetLogFont(&amp;logfont);    CRect rc;    GetClientRect(&amp;rc);    rc.top = rc.bottom - 30;    rc.bottom = rc.top + 20;    rc.left = 15;    rc.right = rc.left + 110;    BOOL b = lnobutton.Create(  "Print line numbers:",                     BS_AUTOCHECKBOX |                     BS_LEFTTEXT     |                     WS_VISIBLE      |                     WS_TABSTOP      |                    WS_CHILD,                    rc,                    this,                    IDC_LINENUMBERS);    lnobutton.SetCheck(printlinenumbers);    return TRUE;}void CQuincyPrintDialog::OnOK(){    printlinenumbers = lnobutton.GetCheck() != 0;    CPrintDialog::OnOK();}</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>// CEditorView printingBOOL CEditorView::OnPreparePrinting(CPrintInfo* pInfo){    delete pInfo-&gt;m_pPD;        // framework has one built on heap    pInfo-&gt;m_pPD = new CQuincyPrintDialog;                                  // framework will delete this object    static_cast&lt;CQuincyPrintDialog*&gt;(pInfo-&gt;m_pPD)-&gt;printlinenumbers =                     theApp.PrintLineNumbers();    return DoPreparePrinting(pInfo);}void CEditorView::OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo){    printlinenos =            static_cast&lt;CQuincyPrintDialog*&gt;(pInfo-&gt;m_pPD)-&gt;printlinenumbers;    int nHeight = -((pDC-&gt;GetDeviceCaps(LOGPIXELSY) * 10) / 72);    m_printerfont.CreateFont(nHeight, 0, 0, 0, FW_NORMAL, 0, 0, 0,        DEFAULT_CHARSET, OUT_CHARACTER_PRECIS, CLIP_CHARACTER_PRECIS,        DEFAULT_QUALITY, DEFAULT_PITCH | FF_DONTCARE, "Courier");    TEXTMETRIC tm;    CFont* pOldFont = pDC-&gt;SelectObject(&amp;m_printerfont);    pDC-&gt;GetTextMetrics(&amp;tm);    m_cyPrinter = tm.tmHeight + tm.tmExternalLeading;    pDC-&gt;SelectObject(pOldFont);    m_nLinesPerPage =(pDC-&gt;GetDeviceCaps(VERTRES) -       (m_cyPrinter * (3 + (2 * PRINTMARGIN)))) / m_cyPrinter;    UINT nMaxPage = max(1, (GetDocument()-&gt;linecount() +                            (m_nLinesPerPage - 1)) / m_nLinesPerPage);    pInfo-&gt;SetMaxPage(nMaxPage);}void CEditorView::OnPrint (CDC* pDC, CPrintInfo* pInfo){    PrintPageHeader(pDC, pInfo-&gt;m_nCurPage);    PrintPage(pDC, pInfo-&gt;m_nCurPage);}void CEditorView::OnEndPrinting(CDC* /*pDC*/, CPrintInfo* pInfo){    m_printerfont.DeleteObject ();    bool plno =           static_cast&lt;CQuincyPrintDialog*&gt;(pInfo-&gt;m_pPD)-&gt;printlinenumbers;    theApp.SetPrintLineNumbers(plno);}void CEditorView::PrintPageHeader(CDC* pDC, UINT nPageNumber){    CString strHeader = GetDocument()-&gt;GetTitle();    CString strPageNumber;    strPageNumber.Format(" (Page %d)", nPageNumber);    strHeader += strPageNumber;    UINT y = m_cyPrinter * PRINTMARGIN;    CFont* pOldFont = pDC-&gt;SelectObject(&amp;m_printerfont);    pDC-&gt;TextOut(0, y, strHeader);    pDC-&gt;SelectObject(pOldFont);}void CEditorView::PrintPage (CDC* pDC, UINT nPageNumber){    int lines = GetDocument()-&gt;linecount();    if (GetDocument()-&gt;linecount() != 0) {        UINT nStart = (nPageNumber - 1) * m_nLinesPerPage;        UINT nEnd = min(lines - 1, nStart + m_nLinesPerPage - 1);        CFont* pOldFont = pDC-&gt;SelectObject(&amp;m_printerfont);        for (int i = nStart; i &lt;= nEnd; i++) {            std::string str = GetDocument()-&gt;textline(i);            for (int j = 0; j &lt; str.length(); j++)                if (str[j] == '\t')                    str[j] = ' ';            int y = ((i - nStart) + PRINTMARGIN + 3) * m_cyPrinter;            CString line;            if (printlinenos)                line.Format("%-4d ", i + 1);            line += str.c_str();            pDC-&gt;TextOut(0, y, line);        }        pDC-&gt;SelectObject(pOldFont);    }}</pre><P><A HREF="#rl3">Back to Article</A></P></body></html>