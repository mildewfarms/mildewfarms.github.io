<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 4.0//EN">


<HTML>
<HEAD>
<TITLE>v09, i03: FreeBSD for the SVR4/Linux Administrator</TITLE>
<LINK REL=StyleSheet HREF="../../resource/css/sacdrom.css" TYPE="text/css" TITLE="CSS1">
</HEAD>

<body bgcolor="#ffffff" text="#000000" link="#000000" alink="#669999" vlink="#333366" topmargin=0 leftmargin=0>

<! -- Begin MASTER TABLE -- >
<!center><table width=600 cellpadding=0 cellspacing=0 border=0 bgcolor="#ffffff">

<tr>

<table cellpadding=5 cellspacing=0 border=0>
	<tr>

		<td><span class=navbarLink>Article</a></span></td>
		<td><a href="../../../../source/SA/2000/mar2000.tar"><b class=codeListing>mar2000.tar</b></a></td>

	</tr>
</table>


</tr>
<tr>
<! -- Begin Content ------ >
<td valign=top width=440 bgcolor="#ffffff">
<table width=100% cellpadding=15 cellspacing=0 border=0>
<tr><td valign=top>
<! -- Insert Content ------ >

<H1>FreeBSD for the SVR4/Linux Administrator</H1><p>
<P>Michael Lucas
<P>
Typically, UNIX systems administrators are familiar with header files, compilers, and the vagaries of their preferred UNIX. Even though this knowledge can be leveraged across multiple UNIX breeds, the basics of systems administration on an unfamiliar platform can frustrate even an experienced admin. Although I have years of experience in BSD-based UNIXes, two years in Linux, plus a smattering of Solaris, I still sometimes find myself confused when dealing with a new UNIX. The first time I logged onto a SCO UNIX machine, for example, I spent almost half an hour looking for the proper way to set a default route. Essential concepts were the same, but the simple issues of administration and software management cost me hours. System V admins that I know gripe about similar problems when working on a BSD-style machine.<P>
This article attempts to give a System V or Linux administrator a basic grounding in FreeBSD configuration and usage. All references are given for FreeBSD 3.x on the x86 architecture, which is slightly different than the Alpha architecture, the obsolete 2.x, or the bleeding-edge 4.0 versions.<P>
<B>System Contents</b><p>The FreeBSD core system includes the kernel and a small assortment of utilities. The core utilities are kept deliberately few. Some items that other UNIX-style operating systems consider absolutely vital, such as the X Window system, are not included by default. (The ports and packages systems simplify adding extra software.)<P>
FreeBSD is also designed to be light by modern standards; a base install takes about 50 megs. Unlike a Linux system, FreeBSD does not have &#147;distributions.&#148; Strictly speaking, Linux is just a kernel; the distribution is the assortment of programs and utilities that come with the kernel. In FreeBSD the kernel and core utilities are a unified whole, and are expected to be used as one.<P>
<B>Booting</b><p>The FreeBSD boot loader loads the kernel, waits for 10 seconds by default, and then executes it. You can interrupt during the 10-second lag to issue configuration commands or select another kernel to boot.<P>
When the loader starts, you will see a countdown of time remaining (in seconds) until the system boots. Hit enter to boot immediately, or the space bar to get a loader command prompt. At the loader prompt, typing &#147;?&#148; will give you simple on-line help, or check the <B>loader(8)</B> man page on a running system.<P>
Some helpful loader commands include:<P>
<P>
<B>unl oad </B>-- Remove all modules from memory. This includes the not-yet-booted kernel.<P>
<B>loa d</B> -- Load a module into memory. For example, to boot with	kernel.old, you would use <B>load kernel.old</B>.<P>
<B>boot</B> -- Continue booting.<P>
<B>boot_single</B> -- Boot the system in single-user mode (see below).<P>
<B>boo t_userconfig</B> -- Boot the system in hardware-configuration mode. This will let you set and change hardware settings, such as memory ports and IRQs. Note that changes you make to one kernel in this mode will not affect other kernels.<P>
<P>
Hit &#147;?&#148; for help within the hardware configuration tool. Once you have found this tool, it is fairly self-explanatory if you are familiar with x86 hardware. System booting behavior can be customized with files under <B>/boot</B>. Some of the more interesting files include:<P>
<P>
<B>/bo ot/kernel.conf</B> -- This contains any changes made with userconfig during an interrupted boot. You can edit this file directly if you wish, but it is generally recommended to just use userconfig.<P>
<B>/bo ot/defaults/loader.conf</B> -- This contains the default booting behavior. You can browse this file for configurable behavior. Do not edit this file directly; the system overwrites it during the upgrade process.<P>
<B>/boot/loader.conf</B> -- This is for local customizations of booting behavior. Any entries here override the defaults in <B>/boot/defaults/loader.conf</B>. See man <B>loader.conf </B>(5) for details.<P>
<B>Initial Multiuser Configuration</b><p>When the boot process reaches the multi-user stage, the system runs the script <B>/etc/rc</B>. There is no <B>/etc/init.d</B> or <B>/etc/inittab</B>. <B>/etc/rc</B> reads all system configuration information, calls all other system startup scripts, and performs all other system initialization work. The <B>/etc/rc</B> script is configured by two other shell scripts: <B>/etc/defaults/rc.conf</B> and <B>/etc/rc.conf</B>.<P>
The script <B>/etc/defaults/rc.conf</B> contains the systems default, out-of-the-box configuration in shell variable assignments. This file is replaced each time you upgrade the system (see my article &#147;Maintaining Patch Levels in Open Source BSDs&#148;, <I>Sys Admin </I>September 1999). Don't edit this file; any changes made here will be lost in the next upgrade.<P>
The script <B>/etc/rc.conf</B> contains more shell variables. Anything you enter here overrides the defaults. This file is for your local use. You can copy any variable assignment from <B>/etc/defaults/rc.conf</B> to <B>/etc/rc.conf</B>, changing the value to fit your needs.<P>
For example, <B>/etc/defaults/rc.conf</B> contains the lines:<P>
<PRE>
sendmail_enable="YES"
sendmail_flags="-bd q30m"
</PRE>
<P>By default, a FreeBSD system has Sendmail enabled at boot. To prevent this, edit <B>/etc/rc.conf</B> and add the line:<P>
<PRE>
sendmail_enable="NO"
</PRE>
<P>Don't worry about the <B>sendmail_flags</B> entry. If a program isn't set to run, <B>/etc/rc</B> will ignore any flags given for it. Similar changes will enable or disable daemons and services included with the system at boot time.<P>
If you don't like editing shell scripts directly, FreeBSD includes the configuration tool <B>/stand/sysinstall</B>. This will edit all files as you choose.<P>
Depending on detected hardware and your <B>rc.conf</B> settings, <B>/etc/rc</B> will call some of the following scripts:<P>
<P>
<B>/etc/rc.alpha</B> -- for Alpha systems.<P>
<B>/etc/rc.i386</B> -- for x86 systems.<P>
<B>/et c/rc.firewall</B> -- for systems with <B>FIREWALL_ENABLE="YES"</B>set in <B>rc.conf</B>.<P>
<B>/et c/rc.pccard</B> -- for systems with <B>PCCARDD_ENABLE="YES"</B> set in <B>rc.conf</B>.<P>
<B>/et c/rc.network</B> -- standard network startup routines.<P>
<B>/etc/rc.atm</B> -- ATM card configuration.<P>
<B>/et c/rc.isdn</B> -- <B>isdnd</B> initial configuration. Called if <B>isdn_enable="YES"</B>. <P>
<B>/et c/rc.serial</B> -- serial port configuration. Always called.<P>
<B>Local daemons</b><p>One important <B>/etc/defaults/rc.conf</B> entry is:<P>
<PRE>
local_startup="/usr/local/etc/rc.d/usr/X11R6/etc/rc.d"<P>
</PRE>
<P>After running <B>/etc/rc</B> and its dependent scripts, the system checks these directories for additional scripts. If it finds any files with a .sh extension, it attempts to execute them. All non-core daemons such as Web servers, sshd, and databases, are started by scripts in these directories. Any locally installed daemons and services are started in these directories. Some places still use the script <B>/etc/rc.local</B> to start local services.  This is deprecated, and should be avoided.<P>
<B>Runlevels in FreeBSD</b><p>FreeBSD doesn't have runlevels. If you need to work on the system before it completes booting, you can set the system to boot only in single-user mode (see above). In single-user mode, the <B>/ </B>filesystem is mounted read-only. No <B>fsck</B> has been run, other filesystems are not mounted, and swap is not active. Essentially, it is the earliest point where the system can give you a shell prompt. During single-user mode, you can choose exactly which system components you want to use. All the commands you need for a complete boot are documented in <B>/etc/rc</B>. A <B>^D</B> or <B>exit</B> in single-user mode will continue the boot process and bring the system up normally.<P>
<B>Third-Party Software</b><p>The FreeBSD packages and ports systems handle third-party software for the systems administrator. Packages are pre-compiled binaries with system-readable installation instructions, similar to Solaris <B>pkgadd</B>, RedHat's <B>rpm</B>, or Debian's <B>dpkg</B>. Packages are available on your FreeBSD CD-ROM, or from a FreeBSD <B>ftp</B> site, for example:<P>
<PRE>
ftp://ftp.freebsd.org/pub/FreeBSD/ports/packages
</PRE>
<P>Packages are installed with the <B>pkg_add</B> command. For example, if you want to install the sharity-light package (a CIFS client), simply download it and run:<P>
<B><P>
pkg_add sharity-light.12.tgz<P>
</b><p>Alternately, if you have a live Net connection, you can simply use:<P>
<PRE>
pkg_add
ftp://ftp.freebsd.org/pub/FreeBSD/ports/packages/net/sharity-light.12.tgz
</PRE>
<P>This will automatically fetch and install the package.<P>
If a package depends on other software being installed to function, <B>pkg_add</B> will automatically detect these dependencies. FreeBSD will look under <B>/cdrom/packages</B> for software dependencies. If it doesn't find the necessary packages there, it will download them from the Internet. If <B>pkg_add</B> cannot fetch required packages, the install will fail.<P>
Similarly, the ports tree helps the sysadmin build software from source code. The ports tree is under <B>/usr/ports</B> and is divided into several categories. A quick <B>grep</B> of <B>/usr/ports/INDEX</B> will tell you whether a desired piece of software is part of the official FreeBSD ports system.<P>
To install sharity-light from source code via ports, you simply go into<B> /usr/ports/net/sharity-light</B>. If you do a <B>ls</B>, you'll see:<P>
<PRE>
%ls -lai
total 13
253975 drwxr-xr-x    7 root  wheel   512 Oct 26 13:04 .
622586 drwxr-xr-x  230 root  wheel  4096 Oct 13 15:21 ..
553485 drwxr-xr-x    2 root  wheel   512 Jan  2  1999 CVS
254264 -rw-r--r--    1 root  wheel  1190 Oct 13 15:21 Makefile
253977 -rw-r--r--    1 root  wheel   735 Nov 29  1998 README.html
561174 drwxr-xr-x    3 root  wheel   512 May 25 22:52 files
591887 drwxr-xr-x    3 root  wheel   512 Aug 11 17:39 patches
668644 drwxr-xr-x    3 root  wheel   512 May 25 22:52 pkg
%
</PRE>
<P>This isn't much at all! What about the source code? It isn't there. All you will find under the port directory is a Makefile on how to build the software, a few FreeBSD-specific patches, and some descriptive information. When you type <B>make install</B>. the system fetches the source code, verifies checksums, decompresses it appropriately, checks for dependencies, applies the patches, builds, and installs.<P>
The ports tree will check the following places for a source code tarball, or &#147;distfile&#148;:<P>
<PRE>
/usr/ports/distfiles
/cdrom/distfiles
the Internet
</PRE>
<P>The port Makefile includes information on Internet sites where the distfile can be found.<P>
If you don't like this sort of automated install, you can use the patches provided as hints when compiling it yourself. Reading the patches provided can also help introduce you to the internals of FreeBSD. If you like automated installs, but want to check or change the defaults on a port before compilation, you can slow the process with a series of <B>make</B> commands rather than the all-inclusive <B>make all install</B>:<P>
<PRE>
make fetch
make checksum
make extract
make patch
make configure
make build
make install
</PRE>
<P>The software is built in the port directory, in a &#147;work&#148; subdirectory. If you want to keep the sources, object files, etc. on hand for later reference, you're done. Otherwise, you can do a <B>make clean</B> to remove the work subdirectory and save disk space.<P>
Whether you're installing from packages or ports, the new software will be installed under <B>/usr/local </B>or <B>/usr/X11R6</B>, as appropriate. In no case should a port or package install something in a core system directory, such as <B>/bin</B> or <B>/usr/lib</B>. If you should encounter a port or package that does this, please notify the port/package maintainer (available in the port Makefile) or <B>ports@freebsd.org</B>. If you want to reserve <B>/usr/local</B> for truly local software, you can change the default location. Set the <B>PREFIX</B> environment variable if you want to do this.<P>
You can make a package out of your custom-compiled port with <B>make package</B>. You can build your software once and distribute the compiled package across several machines. (Be sure to run <B>make package</B> before <B>make clean</B>!)<P>
If you're interested in the internals of the FreeBSD ports system, take a look at the file <B>/usr/ports/Mk/bsd.port.mk</B>. This contains the guts of the port-building system. You don't want to edit this file directly, because it can be overwritten by the upgrade process. Instead, take a look at <B>/etc/make.conf</B> for local customization of port builds.<P>
Quite a few third-party programs are not included in the ports system. If you successfully compile a software package on FreeBSD that isn't in the ports, please send your patches to <B>freebsd-ports@freebsd.org</B>, so other people can benefit from your work.<P>
Whether you installed software as a package or a port, once it's compiled and in place, it's treated as a package. It becomes a binary, after all. For the rest of this article, both packages and ports will be referred to as packages.<P>
For information on installed software, look at <B>/var/db/pkg</B>. The software installation procedure leaves a directory here for each package that has been installed locally. The directory names here are the same as the name of the package. Looking at a typical directory under <B>/var/db/pkg</B>, we see:<P>
<PRE>
%ls
+COMMENT        +CONTENTS       +DESC           +REQUIRED_BY
%
</PRE>
<P>&#147;+COMMENT&#148; gives a brief description of the software. &#147;+DESC&#148; is a longer, more detailed description. &#147;+REQUIRED_BY&#148; lists other packages that depend on this package. &#147;+CONTENTS&#148; is the &#147;packing list&#148; that describes what was installed where, and the checksums of installed files.<P>
To remove a package, use the <B>pkg_delete</B> command. A simple <B>pkg_delete pkgname</B> will remove it from your system. The command <B>pkg_info -aI</B> will give you a list of all installed packages. The <B>pkg_delete</B> command will also prevent you from deleting a package required by other packages.<P>
<B>Kernel Configuration</b><p>The kernel configuration is under <B>/usr/src/sys/i386/conf</B>. The two files you will probably be most interested in are LINT and the config file for your existing kernel. You can get the name of your existing kernel configuration file from the command <B>uname -v</B>. LINT contains a brief description of all kernel options for FreeBSD, both supported and unsupported. Although LINT can be compiled for test purposes, you cannot actually run a LINT kernel.<P>
When building a new kernel, you probably want to start with the GENERIC configuration. Copy GENERIC to a file of your choosing and edit it.  I suggest first removing whatever options and hardware drivers you don't need. If you're not sure about the hardware on your system, the file <B>/var/log/dmesg.boot</B> will give you the boot-time hardware probes and debugging messages. Then, add desired options from LINT.<P>
When building a kernel to support some particular x86 equipment (usually older ISA cards), you might need to specify IRQs, DRQs, or memory ports in the kernel config file. You can also specify flags to some device drivers. Check LINT or the driver man page for details. Then do:<P>
<PRE>
/usr/sbin/config kernelconfigfile
</PRE>
<P>If config gives you errors, correct them before continuing. Most errors are fairly self-explanatory. If config succeeds, go to the compile directory (returned by a successful &#147;config&#148;) and do:<P>
<PRE>
make depend
make all
make install
</PRE>
<P>This will build and install the new kernel. If you are editing an existing kernel, rather than building one from scratch, this process will only compile changed kernel components.<P>
<B>Getting Help</b><p>To get help, first check the FreeBSD FAQ and Handbook. If the documentation distribution is installed on your system, these can be found under <B>/usr/share/doc</B>. If not, they can be found on the FreeBSD Web site, at: <B>http://www.freebsd.org</B>. A variety of other documents can also be found there; check the &#147;Documentation&#148; link. If you have a specific problem, check the FreeBSD mailing lists at:<P>
<PRE>
http://www.freebsd.org/search/
</PRE>
<P>Chances are someone has had the problem before you. Search for your particular error message in the FreeBSD-questions archive. If the mailing list archive cannot help you, send your question to <B>FreeBSD-questions@FreeBSD.org</B>. Describe your setup completely, including your hardware setup, any error messages you receive, and software installed. Be as complete as possible. Although the FreeBSD crowd has a reputation for being less helpful to newbies than some of the other free UNIX groups, they are actually quite helpful when given the necessary information to debug a problem.<P>
If you're looking for information about a change made to a particular FreeBSD component since the BSD 4.4-Lite days, look at the Web-based CVS repository at:<P>
<PRE>
http://www.freebsd.org/cgi/cvsweb.cgi
</PRE>
<P>You can see every change made and the log message showing the rationale for it.<P>
The site <B>http://www.daemonnews.org/ </B>publishes monthly articles on all the BSD variants, and is well worth checking for FreeBSD-specific documentation.<P>
<B>Shutdown</b><p>When a FreeBSD system shuts down, it calls the shell script <B>/etc/rc.shutdown</B>. If you are running applications that need to be terminated gracefully (such as databases), you can add their shutdown procedures here.<P>
<B>Summary</b><p>From an end user or systems administration viewpoint, the differences between FreeBSD and other UNIXes are fairly cosmetic. The systems administrator is expected to have a reasonably extensive knowledge of x86 hardware for in-depth administration tasks. A basic knowledge of FreeBSD configuration will extend your UNIX repertoire.<P>
<p>
<h1>About the Author</h1><p>
Michael Lucas is a networking and FreeBSD consultant who works for the Great Lakes Technologies Group. He lives in Detroit, Michigan, with his wife Liz, five gerbils, and assorted fish. The author wishes to thank Christian Weisgerber, Ronald F. Guilmette, Keith Stevenson, Wes Peters, and David Wolfskill for reviewing this article. </I></BODY>



<! -- Begin Content ------ >
<br>&nbsp;<br>
</table></center></td>
<! -- End Content ------ >

</table><!/center>
<! -- End MASTER TABLE -- >

</body></html>
