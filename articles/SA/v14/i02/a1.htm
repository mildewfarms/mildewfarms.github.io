<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 4.0//EN">


<HTML>
<HEAD>
<TITLE>v14, i02: Centralized User Management with Kerberos and LDAP</TITLE>
<LINK REL=StyleSheet HREF="../../resource/css/sacdrom.css" TYPE="text/css" TITLE="CSS1">
</HEAD>

<body bgcolor="#ffffff" text="#000000" link="#000000" alink="#669999" vlink="#333366" topmargin=0 leftmargin=0>
<! -- Begin MASTER TABLE -- >
<!center>
<table width=98% cellpadding=0 cellspacing=0 border=0 bgcolor="#ffffff">
  <tr>

<table cellpadding=5 cellspacing=0 border=0>
	<tr>

		<td><span class="navbarLink">Article</span></td>
		<td><span class="navbarLink"><a href="a1_f1.htm">Figure 1</a></span></td>
		<td><a href="../../../../source/SA/2005/feb2005.tar"><b class=codeListing>feb2005.tar</b></a></td>

	</tr>
</table>


</tr>
<tr>
<! -- Begin Content ------ >
    <td valign=top width=527 bgcolor="#ffffff"> 
      <table width=100% cellpadding=15 cellspacing=0 border=0>
<tr>
          <td valign=top> 
            <! -- Insert Content ------ >
            <h1><B><img src="a1.gif" width="200" height="167" align="right">Centralized 
              User Management with Kerberos and LDAP</B></h1>
            <P> <I>Travis Crawford</i>
            <p> Many computing environments are designed to make network resources 
              available to users from any location, such as personal workstations, 
              public workstations, and the Web. User management is an important 
              part of this type of distributed computing environment because it 
              provides the consistent authentication and authorization service 
              necessary for universal access. Kerberos and LDAP are two protocols 
              that have been designed to solve the distributed authentication 
              and authorization problem.
            <P> Centralized management of user accounts solves a major problem 
              in distributed computing environments. Without centralization in 
              an environment with X users, Y computers, and Z services, we have 
              (X*Y)+(X*Z) accounts to manage. With centralization, we have X+Y+Z 
              accounts to manage.
            <P> In this article, I will provide an overview of user account management 
              with Kerberos and LDAP. I will describe the protocols and how they 
              work as well as their implementation. Finally, I will discuss how 
              to manage accounts using this new system.
            <P> <B>Login Overview</B>
            <P> The login process for a Linux system must first be understood 
              before it can be extended. The process begins with a user entering 
              credentials such as username and password into the login program 
              (step 1). Login uses the PAM abstraction layer to authenticate the 
              user (step 2). Typically, the <B>pam_unix</B> module (step 2.1) 
              is used to compare the password entered by the user to the hash 
              stored in the <B>shadow</B> file (2.2). If no entry exists in the 
              <B>shadow</B> file, the normal login process will fail. However, 
              this environment has Kerberos configured, and the <B>pam_krb5</B> 
              PAM module (2.3) authenticates the user by obtaining a ticket-granting-ticket 
              from the Kerberos server (2.4).
            <P> Authentication is only part of the login process. At this point, 
              login has verified that a user is who they claim to be. The authorization 
              phase determines whether the user is allowed to use this resource. 
              Login uses the name service switch (step 3) to look up user information, 
              such as uid number, shell, and home directory. Typically, the <B>nss_files</B> 
              module (3.1) looks up this information in the <B>passwd</B> file 
              (3.2). If the user information is not found locally, this environment 
              uses the <B>nss_ldap</B> module (3.3) to look up the user information 
              from the LDAP server (3.4). The success or failure of this login 
              attempt is reported to the system logger (4), and finally, if steps 
              2 and 3 are completed successfully, the user is granted access (5) 
              (see Figure 1).
            <P> <B>Kerberos</B>
            <P> The Kerberos protocol is designed to securely authenticate users 
              over an insecure network and to enable single sign-on. A trusted 
              third party and strong cryptography are used to meet these goals.
            <P> Passwords are never sent over the network while using Kerberos. 
              Additionally, mutual authentication verifies the identity of both 
              parties involved in any communication. Finally, single sign-on securely 
              authenticates users automatically after they have logged into the 
              realm.
            <P> Kerberos tickets are analogous to a weekend pass at a ski resort. 
              Upon arrival, one obtains a passcard that is valid for a limited 
              period of time. At each mountain, the passcard can be used to obtain 
              a lift ticket. At the end of the weekend, the passcard expires as 
              well as all lift tickets. Kerberos calls its weekend passcard a 
              Ticket Granting Ticket (TGT), which is by default valid for the 
              length of a typical work day. TGTs are used to obtain service tickets 
              that grant access to a specific service, such as LDAP. Additional 
              service tickets must be obtained for additional services.
            <P> While this method was first implemented at MIT, Roger Needham 
              and Michael Schroeder designed much of the original protocol at 
              the Xerox Palo Alto Research Center. Their research included both 
              public and private key cryptography and compared the strengths and 
              weaknesses of each method. They concluded that private key cryptography 
              was superior for a network authentication system because it required 
              fewer protocol operations per transaction while remaining equally 
              secure.
            <P> Kerberos was first released to the public as Kerberos-4, with 
              the first three releases used internally at MIT; the current release 
              is Kerberos-5. Because of the export controls on strong encryption 
              technologies, an independent Kerberos implementation called Heimdal 
              has been developed at the Center for Parallel Computers in Sweden. 
              Both implementations are well supported and are functionally the 
              same.
            <P> Kerberos is an Internet standards track protocol defined in RFC 
              1510: The Kerberos Network Authentication Service (V5).
            <P> <B>Protocol</B>
            <P> The Kerberos protocol is designed to securely authenticate users 
              over an insecure network and to enable single sign-on. With these 
              goals in mind, we define two major modes of operation. Initial sign-on 
              (ISO) describes the mode in which a user authenticates as a principal 
              in a Kerberos realm, a concept similar to logging in as a user to 
              a Windows domain. Successful completion of ISO provides the user 
              with a ticket-granting ticket, an electronic ID card that verifies 
              the identity of its owner. Single sign-on (SSO) describes the mode 
              in which a user authenticates to an application in the Kerberos 
              realm; this authentication is automatically performed for the user 
              by the Kerberos client. SSO enables users to enter their username 
              and password just once per computing session.
            <P> <B>Initial Sign-On</B>
            <P> Initial sign-on describes the following Kerberos Authentication 
              Service protocol exchange:
            <P> 
            <P> 1. Client to Kerberos: Authentication service request (<B>KRB_AS_REQ</B>) 
            <P> 2. Kerberos to Client: Authentication service reply (<B>KRB_AS_REP</B>) 
              or Error (<B>KRB_ERROR</B>)
            <P> 
            <P> The <B>KRB_AS_REQ</B> request message is constructed by a Kerberos 
              client and sent to a Kerberos server. This plain-text message contains 
              the client identity assertion, local time, authentication server 
              principal name, and requested lifetime. The client identity assertion 
              is described as such because a user may attempt to acquire the credentials 
              of a different user; this type of brute force attack is preventable 
              with pre-authentication and will be discussed later. The client's 
              local time is used to ensure reasonably synchronized clocks; although 
              the request message does not rely on synchronized clocks, future 
              protocol operations do, and this helps prevent errors later on. 
              The authentication server principal name is usually <B>krbtgt/INSTANCE@REALM</B>. 
              The requested lifetime is used to request a non-default ticket lifetime.
            <P> Pre-authentication is used to prevent the construction of request 
              messages with arbitrary principal names. In response to <B>KRB_AS_REQ</B> 
              request messages for a principal that requires pre-authentication, 
              the Kerberos server returns an encrypted challenge value inside 
              a <B>KRB_ERROR</B> error message. The client must decrypt the challenge 
              value with the user's password and resend the <B>KRB_AS_REQ</B> 
              request message with the appended challenge value. If the server 
              accepts the challenge response, a <B>KRB_AS_REP</B> reply message 
              is constructed and sent to the client. Note that the user has been 
              authenticated without sending his or her password over the network, 
              even in encrypted form.
            <P> The <B>KRB_AS_REP</B> reply message is constructed by a Kerberos 
              server and sent to clients in response to <B>KRB_AS_REQ</B> request 
              messages. This message, encrypted with the user's password, contains 
              the user's copy of the unique session key, authentication server 
              principal name, ticket lifetime, and TGT encrypted with the authentication 
              server's password. The encrypted TGT contains the authentication 
              server's copy of the unique session key, client principal name, 
              ticket lifetime, timestamp, and client IP address.
            <P> Subsequent communication is encrypted with the session key known 
              only to client and server that is valid for a limited time, for 
              a specific user, from a specific host. These checks ensure that, 
              in the event a <B>KRB_AS_REP</B> reply message is captured and decrypted, 
              the TGT is invalid because either the IP address is incorrect or 
              the ticket lifetime has been exceeded.
            <P> The session key contained in a <B>KRB_AS_REP</B> reply message 
              is a private encryption key known only to client and server and 
              is valid only for the current session. Encrypting client to Kerberos 
              server and client to application server communication with unique 
              session keys increases security in several ways. First, every two 
              principals in a Kerberos realm that wish to communicate have a unique 
              session key, thus providing mutual authentication. Second, breaking 
              the encryption on a single session is time sensitive because tickets 
              expire after a period of time.
            <P> While confusing at first, the ISO process becomes clear with some 
              inspection. Clients construct a clear-text request message for a 
              TGT that is sent to the server. If pre-authentication is enabled, 
              the server returns an error message that includes a challenge value 
              encrypted with the user's password. The client decrypts the challenge 
              value and appends it to a second TGT request message. The server 
              has now verified the user's identity and sends the client a reply 
              message containing a TGT encrypted with the user's password. The 
              client decrypts the TGT and is authenticated.
            <P> <B>Single Sign-On</B>
            <P> Single sign-on describes the following Kerberos Authentication 
              Service protocol exchange:
            <P> 
            <P> 1. Client to Kerberos: Authentication service request (<B>KRB_AS_REQ</B>).
            <P> 2. Kerberos to Client: Authentication service reply (<B>KRB_AS_REP</B>) 
              or Error (<B>KRB_ERROR</B>).
            <P> 3. Client to Application server: Application request (<B>KRB_AP_REQ</B>) 
            <P> 4. [Optional] Application server to Client: Application Reply 
              (<B>KRB_AP_REP</B>) or Error (<B>KRB_ERROR</B>).
            <P> 
            <P> The <B>KRB_AS_REQ</B> authentication service request message is 
              constructed by a Kerberos client and sent to a server, similar to 
              ISO, except that the authentication server principal name is replaced 
              with the application server principal name. The <B>KRB_AS_REP</B> 
              authentication server reply message contains the user's copy of 
              a unique session key and a service ticket encrypted with the application's 
              password.
            <P> After acquiring a service ticket, the client constructs a <B>KRB_AP_REQ</B> 
              application request message and sends it to the application. This 
              message contains the service ticket and authenticator encrypted 
              with the session key; the authenticator contains a timestamp and 
              client principal name. The application decrypts the service key 
              with its password and decrypts the authenticator with the session 
              key. Mutual authentication is achieved because only the appropriate 
              application can decrypt the service ticket, and only the appropriate 
              client has knowledge of the session key to encrypt the authenticator.
            <P> <B>Installation and Configuration</B>
            <P> Before configuring Kerberos, it is important to decide which implementation 
              to use. Two major Kerberos implementations are freely available 
              for Linux: MIT Kerberos and Heimdal. Both implementations are stable, 
              well supported, and have an active user base. The major difference 
              is that Heimdal is developed outside the United States and therefore 
              is not subject to export control restrictions; many free operating 
              systems use Heimdal for that reason.
            <P> The following installation and configuration description is based 
              on MIT Kerberos on Fedora. Begin by downloading the source code 
              from the MIT Web site or installing the <B>krb5-servers</B> and 
              <B>krb5-workstation</B> packages. The default installation path 
              for the source distribution is <B>/usr/local</B> and the packages 
              install to <B>/usr/kerberos</B>.
            <P> A new Kerberos server configuration comprises the following steps:
            <P> 
            <P> 1. The Kerberos configuration file <B>krb5.conf</B> sets defaults 
              used during the configuration process.
            <P> 2. <B> [libdefaults]</B>
            <P> 3. <B> default_realm = EXAMPLE.EDU</B>
            <P> 4.
            <P> 5. <B> [realms]</B>
            <P> 6. <B> EXAMPLE.EDU = {</B>
            <P> 7. <B> kdc = kerberos.example.edu:88</B>
            <P> 8. <B> admin_server = kerberos.example.edu:749</B>
            <P> 9. <B> }</B>
            <P> 10. Initialize a new Kerberos database using <B>kdb5_util</B>. 
              The <B>-s</B> option is used to create a stash file that includes 
              the master database password for unattended server startup.
            <P> 11. <B>kdb5_util create -s</B>
            <P> 12. Create administrative and regular users and policies using 
              <B>kadmin.local</B>.
            <P> 
            <P> This administrative interface directly modifies the Kerberos database 
              and must be run as root on the KDC; use this interface because no 
              principals currently exist with which to log in. Use <B>kadmin</B> 
              after creating the administrative principal and setting the appropriate 
              access control list.
            <P> Kerberos-5 principals are written in the form <B>username/instance@REALM</B>, 
              where <B>username</B> is a user's unique name, instance is an optional 
              group (such as admin), and <B>realm</B> is the realm name in which 
              this ticket is valid.
            <P> Create the administrative and default policies:
            <P> 
            <pre>
# kadmin.local -q "addpol -maxlife \"1 month\" -minlength 8 \
  -minclasses 3 admin"
# kadmin.local -q "addpol -maxlife \"3 months\" -minlength 8 \
  -minclasses 3 default"
</pre>
            Create an administrative and regular principal for testing the environment:
            <P> 
            <pre>
# kadmin.local -q "addprinc -policy admin +requires_preauth travis/admin"
Authenticating as principal root/admin@EXAMPLE.EDU with password.
Enter password for principal "travis/admin@EXAMPLE.EDU":
Re-enter password for principal "travis/admin@EXAMPLE.EDU":
Principal "travis/admin@EXAMPLE.EDU created.
# kadmin.local -q "addprinc travis"
Authenticating as principal root/admin@EXAMPLE.EDU with password.
NOTICE: no policy specified for travis@EXAMPLE.EDU; assigning "default"
Enter password for principal "travis@EXAMPLE.EDU":
Re-enter password for principal "travis@EXAMPLE.EDU":
Principal "travis@EXAMPLE.EDU created.
</pre>
            13. Edit the <B>kadmind</B> access control list. <B>/var/kerberos/krb5kdc/kadm5.acl</B>. 
            This file contains a list of principals that are authorized to perform 
            administrative tasks. From the <B>kadmind(8)</B> man page we find 
            the following access controls. If the character is lowercase, then 
            the operation is permitted; if the character is uppercase, then the 
            operation is disallowed.
            <P> 
            <P> 14. <B>a</B> -- <B>[Dis]allows the addition of principals or policies 
              in the database.</B>
            <P> 15. <B>d</B> -- <B>[Dis]allows the deletion of principals or policies 
              in the database.</B>
            <P> 16. <B>m</B> -- <B>[Dis]allows the modification of principals 
              or policies in the database.</B>
            <P> 17. <B>c</B> -- <B>[Dis]allows the changing of passwords for principals 
              in the database.</B>
            <P> 18. <B>i</B> -- <B>[Dis]allows inquiries to the database.</B>
            <P> 19. <B>l</B> -- <B>[Dis]allows the listing of principals or policies 
              in the database.</B>
            <P> 20. <B>x</B> -- <B>Short for admcil.</B>
            <P> 21. <B>*</B> -- <B>Same as x.</b>
            <p> A simple ACL that allows all principals with an administrative 
              instance full control may be sufficient in small environments, while 
              more complex lists may be required in environments with distributed 
              support groups:
            <P> 
            <pre>
*/admin@EXAMPLE.EDU   *
</pre>
            22. Start the <B>krb5kdc</B> and <B>kadmind</B> services and test 
            that everything works by logging into <B>kadmin</B> with the principals 
            you created.
            <P> 
            <P> A minimal Kerberos server is now configured and should be adequate 
              for testing purposes. Before using in a production environment, 
              be sure to read the man pages and understand very well what you 
              are doing.
            <P> <B>Backup and Restore</B>
            <P> Several methods are available for backing up the Kerberos-5 database, 
              including a full filesystem backup and Kerberos database dump. The 
              recommended backup method is to use the dump mode of <B>kdb5_util(8)</B>. 
              As root, stop the server process, dump the Kerberos database, and 
              then restart the process:
            <P> 
            <pre>
service krb5kdc stop
kdb5_util dump kerberos-backup.txt
service krb5kdc start
</pre>
            The backup file is encrypted with either the KDC password or dump-specific 
            password if the <B>mkey_convert</B> option is used. Write this file 
            to tape or a remote filesystem and protect it to the same extent as 
            the live KDC; compromising the backup database is as dangerous as 
            compromising the live database.
            <P> Restore the KDC database using the load mode of <B>kdb5_util</B>. 
              Load creates a new database containing only the principals in the 
              dump file, overwriting any existing principals. Existing principals 
              are kept when using the update option. As root, stop the server 
              process, load the Kerberos database, and then restart the process:
            <P> 
            <pre>
service krb5kdc stop
kdb5_util load kerberos-backup.txt current-database
service krb5kdc start
</pre>
            A Kerberos database into which the backup will be loaded must already 
            exist.
            <P> <B>LDAP</B>
            <P> The Lightweight Directory Access Protocol (LDAP) defines a method 
              to search and modify a remote database. Directory services are used 
              to reduce the number of administrative data repositories in an organization.
            <P> LDAP has its roots in the X.500 series of specifications, a worldwide 
              directory service complete with protocol, object classes, attribute 
              types, authentication framework, and replication. The directory 
              as defined was so thorough in its design that it became difficult 
              to implement. The complexity of implementation was not limited to 
              servers; clients were difficult to write as well. The University 
              of Michigan recognized this limitation and created LDAP, a gateway 
              to X.500 servers with a simple client interface. By making LDAP 
              clients easier to implement, more applications began to use the 
              directory, thus making it more useful. Eventually the gateway became 
              the first standalone LDAP server.
            <P> LDAP is an Internet standards track protocol defined in RFC 2251: 
              Lightweight Directory Access Protocol (v3).
            <P> <B>Protocol</B>
            <P> LDAP directory access operations describe the following protocol 
              exchange:
            <P> 
            <P> 1. Client to server: <B>Bind request</B>
            <P> 2. Server to client: <B>Bind result</B>
            <P> 3. Client to server: <B>Search request</B>
            <P> 4. Server to client: <B>Search entry</B>
            <P> 5. Server to client: <B>Search result</B>
            <P> 6. Client to server: <B>Unbind request</b>
            <p> The <B>bind request</B> message is constructed by an LDAP client 
              and sent to an LDAP server. It indicates the beginning of a new 
              connection and contains the distinguished name and password credentials 
              with which to bind. LDAP supports several authentication methods 
              (specified by the Auth Type), including Kerberos through the GSSAPI, 
              so this data may or may not be encrypted, depending on how the server 
              is configured.
            <P> Servers respond with a <B>bind result</B> message to bind request 
              messages. A result code, such as success, or error message indicates 
              whether the bind was successful and whether the connection should 
              continue.
            <P> Once bound, the client sends a <B>search request</B> message that 
              contains a Base DN, scope, and filter. The Base DN, such as <B>ou=people,dc=example,dc=edu</B>, 
              specifies where in the namespace hierarchy to start the search. 
              For example, a search for user accounts might be limited to the 
              user section of the namespace and omit searching application settings.
            <P> The scope specifies how deep to look and may be <B>base</B> (base 
              DN only), <B>oneLevel</B> (children of the base DN), or <B>sub</B> 
              (all entries below the base DN). Finally, the search filter specifies 
              what to look for.
            <P> Search filters are written in the form <B>attribute=value</B> 
              and may be combined with a subset of boolean operators. To find 
              the entry that represents my user account, I would construct a query 
              such as <B>(&amp;(objectClass=posixAccount)(uid=travis))</B>. Most 
              LDAP-aware applications take care of constructing the search filter; 
              however, the command-line program <B>ldapsearch</B> allows you to 
              specify a custom filter. You might be surprised at how much information 
              can be extracted from public LDAP servers by constructing custom 
              queries because many sites implement access control, not in the 
              LDAP server itself, but in their Web-based front-end.
            <P> The <B>search entry</B> message is sent from server to client, 
              with one message per entry matching the search filter. These messages 
              contain the distinguished name and all associated attribute/value 
              pairs. The results are either returned printed to the screen or 
              returned to the application as an array for processing. The <B>Search 
              result</B> message is sent from server to client to indicate a successful 
              operation after all <B>search entry</B> messages have been sent.
            <P> Finally, an <B>unbind request</B> message is sent from client 
              to server to indicate no additional search requests will be sent. 
              This implies that multiple search requests may be sent during a 
              single connection, which reduces overhead.
            <P> <B>Schema</B>
            <P> The LDAP schema defines what data can be stored in the directory. 
              It is the collection of attribute types and object classes that 
              are valid. Attribute types define a specific type of variable for 
              use in the directory. It defines the name, matching rule, and whether 
              the attribute may be defined multiple times for a specific entry. 
              Directory-enabled applications use attribute types to store their 
              data.
            <P> RFC2307 defines a schema that enables Linux clients to store user 
              accounts in a directory server. The <B>nis.schema</B> file packaged 
              with OpenLDAP implements RFC2307 and provides the attribute and 
              object class definitions to store the contents of <B>/etc/passwd</B>, 
              <B>/etc/shadow</B>, and <B>/etc/group</B> in a directory. Providing 
              the functionality of these files in the directory allows it to replace 
              local databases throughout an organization.
            <P> Structural object classes typically represent real-world objects, 
              such as people or organizations. Every LDAP entry has exactly one 
              structural object class but may have additional auxiliary object 
              classes. For example, the structural object class <B>person</B> 
              represents a person, and the auxiliary object classes <B>posixAccount</B> 
              and <B>shadowAccount</B> represent the person's computer account. 
              Object classes and attributes are defined in the schema files included 
              with directories and directory-enabled applications.
            <P> Directory entries with structural object class <B>person</B> represent 
              individual people who may or may not have a computer account:
            <P> 
            <pre>
objectclass ( 2.5.6.6 NAME 'person' SUP top STRUCTURAL
MUST ( sn $ cn )
MAY ( userPassword $ telephoneNumber $ seeAlso $ description ) )
</pre>
            Directory entries with auxiliary object class <B>posixAccount</B> 
            represent user accounts by allowing attributes that map directly to 
            each field in the <B>/etc/passwd</B> file:
            <P> 
            <pre>
objectclass ( 1.3.6.1.1.1.2.0 NAME 'posixAccount' SUP top AUXILIARY
    DESC 'Abstraction of an account with POSIX attributes'
    MUST ( cn $ uid $ uidNumber $ gidNumber $ homeDirectory )
    MAY ( userPassword $ loginShell $ gecos $ description ) )
</pre>
            Directory entries with auxiliary object class <B>shadowAccount</B> 
            allow attributes that map directly to each field in the <B>/etc/shadow</B> 
            file:
            <P> 
            <pre>
objectclass ( 1.3.6.1.1.1.2.1 NAME 'shadowAccount' SUP top AUXILIARY
    DESC 'Additional attributes for shadow passwords'
    MUST uid
    MAY ( userPassword $ shadowLastChange $ shadowMin $
    shadowMax $ shadowWarning $ shadowInactive $
    shadowExpire $ shadowFlag $ description ) )
</pre>
            Directory entries with the object class <B>posixGroup</B> represent 
            groups; these entries are used to replace the <B>/etc/group</B> file:
            <P> 
            <pre>
objectclass ( 1.3.6.1.1.1.2.2 NAME 'posixGroup' SUP top STRUCTURAL
    DESC 'Abstraction of a group of accounts'
    MUST ( cn $ gidNumber )
    MAY ( userPassword $ memberUid $ description ) )
</pre>
            Attributes are given a name, unique object identifier, matching rule, 
            and type. The object type specifies whether this attribute may exist 
            more than once for the same entry. For example, the <B>homeDirectory</B> 
            attribute may be assigned only once to an entry and, like all Linux 
            path names, is case sensitive:
            <P> 
            <pre>
attributetype ( 1.3.6.1.1.1.1.3 NAME 'homeDirectory'
    DESC 'The absolute path to the home directory'
    EQUALITY caseExactIA5Match
    SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 SINGLE-VALUE )
	</pre>
<b>Configure the Server</B><P>
The OpenLDAP configuration file <B>slapd.conf</B> contains configuration information for the OpenLDAP server. It should not be world-readable because several secret pieces of information must be stored in it, such as the root directory account and password and access control list definitions. Schema files that represent Linux user accounts and groups must be imported and the schema check enabled to ensure the schema are followed:<P>
<pre>
# Linux user accounts (objectClass posixAccount) are defined in 
# nis.schema
# core.schema and cosine.schema are required by nis.schema
include       /etc/openldap/schema/core.schema
include       /etc/openldap/schema/cosine.schema
include       /etc/openldap/schema/nis.schema
schemacheck   on
</pre>
Logging will be very useful when configuring the server; the level of verbosity is specified with the <B>loglevel</B> option:<P>
<pre>
# Messages are logged to LOCAL4
# Add "local4.* /var/log/slapd.log" to your syslogd configuration
loglevel    256
</pre>
The database section of <B>slapd.conf</B> specifies the backend database in which the directory will be stored. Specify the database format, where to store the database files, mode for new files, and the directory suffix:<P>
<pre>
# back-end database configuration
database    ldbm
directory   "/var/lib/ldap"
mode    0600
suffix  "dc=example,dc=edu"
</pre>
The root directory user specifies a distinguished name that, when bound as, has no search or modify restrictions. Although the password may be stored in this file as plain text, that practice is highly discouraged; use a password hash instead. Again, ensure the permissions on the configuration file prevent read access:<P>
<pre>
# root directory user account
rootdn      "cn=Manager,dc=example,dc=edu"
rootpw      {MD5}Xr4ilOzQ4PCOq3aQ0qbuaQ==
SASL AND GSSAPI
</pre>
OpenLDAP does not directly support Kerberos-5 authentication. However, support is available through the SASL GSSAPI mechanism. The Simple Authentication and Security Layer (SASL) is a framework for integrating external authentication methods into an existing protocol. SASL does not provide any authentication methods of its own; it simply provides a framework to integrate third-party authentication services. One supported SASL authentication source is Kerberos-5, which is accessed via the Generic Security Services Application Programming Interface (GSSAPI):<P>
<pre>
LDAP &lt;--&gt; SASL &lt;--&gt; GSSAPI &lt;--&gt; Kerberos
</pre>
The following options are available in <B>slapd.conf</B> for enabling Kerberos support. Specify the server, realm, and security properties:<P>
<pre>
sasl-host      kerberos.example.edu
sasl-realm     EXAMPLE.EDU
sasl-secprops  noplain,noactive,noanonymous
</pre>
The <B>sasl-secprops</B> option specifies which security options to use; the above listed values are sufficient for GSSAPI.<P>
When GSSAPI is used as an authentication source, <B>slapd.conf</B> ACL entries must be modified because GSSAPI-distinguished names end with <B>cn=gssapi,cn=auth</B>. To allow all users who authenticate with GSSAPI to have read access, machines to have read access, and everyone to have no access, use an ACL similar to the following:<P>
<pre>
access to *
    by dn.children="cn=gssapi,cn=auth" read
    by dn.children="ou=Machines,dc=example,dc=edu"
    by anonymous auth
</pre>
A Kerberos principal must be created for LDAP, and the LDAP server keytab must be updated. Ensure <B>slapd</B> has read access to the keytab:<P>
<pre>
kadmin -q "addprinc -randkey ldap/ldap.example.edu@EXAMPLE.EDU"
kadmin -q "ktadd ldap/ldap.example.edu@EXAMPLE.EDU"
</pre>
Clients can query the LDAP server using GSSAPI for authentication by first obtaining a TGT and specifying the appropriate SASL mechanism:<P>
<pre>
kinit travis
ldapsearch "(uid=travis)" -Y gssapi
</pre>
<b>Transport Layer Security</B><P>
Transport Layer Security (TLS) is the evolution of SSL and is used to encrypt the communication between hosts at the transport layer. Enabling TLS first requires the creation of a digital certificate and key:<P>
<pre>
/usr/local/ssl/misc/CA -newcert
</pre>
The script will prompt you for several pieces of information, such as country, state, etc. These values can be filled with whatever you like, except for the common name of your server. This <B>must</B> be the DNS name of your LDAP server or TLS will not work. List the required cipher strength, certificate, and key in:<P>
<pre>
slapd.conf.
TLSCipherStrength       HIGH
TLSCertificateFile      /etc/openldap/ldap-key-cert.pem
TLSCertificateKeyFile   /etc/openldap/ldap-key-cert.pem
</pre>
<b>Backup and Restore</b><P>
A comprehensive backup strategy will allow the directory to be restored after a disaster, user error, or malicious network attack. Two methods are available for backing up directory data: back up the entire filesystem on which the directory database is stored, or create an LDIF file containing all directory entries. The <B>dump</B> and <B>restore</B> commands are used to back up and restore entire filesystems. The <B>slapcat</B> and <B>slapadd</B> commands are used to create and restore LDIF files.<P>
Creating then archiving an LDIF file is the recommended backup method because the format is server independent and stored as ASCII text rather than in binary format. This allows an administrator to make changes or correct errors before restoring the directory. As root, stop the LDAP server, write the directory contents to a file on disk, and then restart the server:<P>
<pre>
service ldap stop
slapcat &gt; directory-backup.ldif
service ldap start
</pre>
This method may be unacceptable because it requires stopping the service. In a replicated environment, a slave server may be used to export the database, thus keeping the service available.<P>
The <B>directory-backup.ldif</B> file may be copied to tape or a remote file system for safekeeping. Security of the backup is critical because access control restrictions are implemented in the LDAP server, not the data file itself. This file is organized in superior first order, the same format that <B>slapadd</B> requires. The directory may be restored with:<P>
<pre>
service ldap stop
slapadd &lt; directory-backup.ldif
service ldap start
</pre>
The LDAP server must be properly configured, purged of any old data, and not running before data can be added.<P>
<B>Client Configurations</B><P>
Each Linux client must be configured to authenticate users and look up account information over the network rather than to use the default local databases. These network services should be transparently accessed to make the login process easy for the user. Kerberos and Pluggable Authentication Modules (PAM) implement authentication, while LDAP and the Name Service Switch (NSS) implement look up of user information in the directory.<P>
<B>Kerberos Client Configuration</B><P>
The Kerberos client configuration file <B>/etc/krb5.conf</B> specifies the local realm name and other parameters needed for authentication. More information is available in <B>krb5.conf(5)</B>:<P>
<pre>
[libdefaults]
    default_realm = EXAMPLE.EDU

[realms]
    EXAMPLE.EDU = {
        kdc = kerberos.example.edu:88
        admin_server = kerberos.example.edu:749
    }
</pre>
<b>Pluggable Authentication Modules</b><P>
PAM is the Linux subsystem that handles authentication tasks on behalf of applications. It breaks down authentication into four distinct tasks: authentication, account management, session management, and password management. Authentication verifies the user is who he or she claims to be. Account management determines whether the authenticated user is permitted access at this time. Session management functions trigger events at login and logout, such as writing log entries. Password management functions change users' passwords.<P>
PAM-aware applications can be configured globally with <B>/etc/pam.conf</B> or individually with files in <B>/etc/pam.d</B>. The presence of the <B>/etc/pam.d</B> directory causes the global configuration file to be ignored. The <B>pam_stack.so</B> module can be used to include configuration files.<P>
We enable the Kerberos authentication service in PAM by adding the <B>pam_krb5.so</B> module to the appropriate PAM stack, such as the <B>system-auth</B> file that is included in most application configurations. Enable Kerberos for authentication and password tasks:<P>
<pre>
# /etc/pam.d/system-auth

auth        required    pam_env.so
auth        sufficient  pam_unix.so likeauth nullok
auth        sufficient  pam_krb5.so use_first_pass
auth        required    pam_deny.so

account     required    pam_unix.so

password    required    pam_cracklib.so retry=3 type=
password    sufficient  pam_unix.so nullok use_authtok md5 shadow
password    sufficient  pam_krb5.so use_authtok
password    required    pam_deny.so

session     required    pam_limits.so
session     required    pam_unix.so
</pre>
After enabling Kerberos authentication in PAM, test the configuration by logging in with Kerberos credentials. More information is available in <B>pam(8)</B>, <I>The Linux-PAM System Administrators' Guide</I>, and <I>The Linux-PAM Module Writers' Guide</I> (see References).<P>
<B>LDAP Client Configuration</B><P>
The LDAP client configuration file <B>/etc/ldap.conf</B> specifies server connection parameters. More information is available in <B>ldap.conf(5)</B>:<P>
<pre>
uri ldaps://ldap.example.edu
base dc=example,dc=edu
</pre>
<b>Name Service Switch</b><P>
The NSS specifies where to look up name information and in what order. Traditionally, names were looked up in the passwd file by each application. The introduction of NSS allowed multiple name services by abstracting the lookup request from the actual lookup. Programs now make a request to NSS for a lookup and the appropriate library is used. Specify LDAP as a source for user account and group information in <B>nsswitch.conf(5)</B>:<P>
<pre>
passwd: files ldap
shadow: files ldap
group: files ldap
</pre>
Each line specifies a type of information to look up, followed by a list of locations in which to look it up. Local files are first consulted for account information. If a user account does not exist locally, the LDAP server is queried. This allows local users to still log in if the LDAP server is unavailable. After LDAP and NSS are configured, user account information may be looked up in the directory.<P>
<B>Configuration Tools</B><P>
Most Linux distributions have tools for configuring Kerberos, PAM, LDAP, and NSS. Red Hat and Fedora users have <B>authconfig(8)</B> and the GUI-equivalent, <B>authconfig-gtk</B>, for reconfiguring an existing installation and Kickstart for new installations. Kickstart allows an administrator to automate the installation process by providing an answer file for common configuration questions, such as authentication and user account lookup methods. Check the documentation of your distribution for more information on configuration tools.<P>
<B>Account Management</B><P>
The creation, modification, and deletion of user accounts on a single Unix system are simple tasks with the <B>user{add|mod|del}, group{add|mod|del}</B> and <B>passwd</B> commands. These commands are not compatible with Kerberos or LDAP, so we must look elsewhere for user management tools.<P>
<B>Administrative Tools</B><P>
Kadmin is the Kerberos administrative interface for use over a network. It can be used to create, modify, and delete principals and policies. It authenticates using Kerberos and supports both command-line and interactive use. Kadmin replaces the <B>passwd</B> command in this environment.<P>
Change password utility (CPU) is a user and group management tool that supports an LDAP backend. CPU replaces <B>user{add|mod|del}</B>, and <B>group{add|mod|del}</B>, making it a useful tool in our environment, performing most user and group management tasks.<P>
Kadmin uses the main Kerberos configuration file <B>krb5.conf(5)</B>. CPU uses the configuration file <B>cpu.conf</B>. Most of the defaults are sensible; however, be sure to change the connection parameters and directory suffix. See <B>cpu.conf(5)</B> for more information.<P>
<B>Password Policies</B><P>
The policies feature allows an administrator to set password requirements such as length and number of required character classes. Specific policies may be assigned to principals during creation; if it exists, the policy named "default" is used when no policy is specified. See <B>kadmin(8)</B> for more <B>addpol</B> options:<P>
<pre>
kadmin -q "addpol -maxlife \"90 days\" -minlength 8 -minclasses 3 default"
kadmin -q "addpol -maxlife \"30 days\" -minlength 12 -minclasses 3 admin"
</pre>
<b>Creating Accounts</b><P>
Users, machines, and services are represented as principals in the Kerberos database. Password and account aging similar to <B>chage</B> is supported, along with some Kerberos-specific options such as pre-authentication. It is recommended to assign each user the default policy, as well as to require pre-authentication. See <B>kadmin(8)</B> for more <B>add_principal</B> options.<P>
The workflow for creating a user account in an environment with Kerberos and LDAP is very similar to creating users on a traditional Unix system. Create the user account with an LDAP-aware tool such as <B>cpu</B>, then create the Kerberos principal. These steps are very similar to creating a user with <B>useradd</B> and setting the password with <B>passwd</B>. Principals with an administrative instance typically do not require an LDAP user account because these principals are reserved for Kerberos administrative tasks only:<P>
<pre>
cpu useradd travis
kadmin -q "addprinc -policy admin travis/admin"
kadmin -q "addprinc travis"
</pre>
<b>Disabling Accounts</b><P>
Users come and go, so occasionally user accounts will need to be disabled. The process of disabling an account is similar to the method used with passwd and shadow files. We delete the user's Kerberos principal to prevent password-based authentication and change the user's shell to <B>/sbin/nologin</B> to prevent authentication with SSH keys. This method preserves a record of the user and ensures the uid is not reused. Remember to remove all principals for the users, such as their principal with an administrative instance:<P>
<pre>
kadmin -q "delprinc travis"
cpu usermod -s /sbin/nologin travis
</pre>
<b>References</b><P>
MIT Kerberos Site -- <B>http://web.mit.edu/kerberos/</B><P>
RFC 1510 (Kerberos specification) -- <B>http://www.ietf.org/rfc/rfc1510.txt</B><P>
Kerberos FAQ -- <B>http://www.cmf.nrl.navy.mil/CCS/people/kenh/kerberos-faq.html</B><P>
Heimdal -- <B>http://www.pdc.kth.se/heimdal/</B><P>
Fedora -- <B>http://fedora.redhat.com/</B><P>
comp.protocols.kerberos -- <B>http://www.google.com/groups?group=comp.protocols.kerberos</B><P>
Needham, R., and M. Schroeder. "Using Encryption for Authentication in Large Networks of Computers." <I>Communications of the ACM</I>, 21(12):993-999.<P>
Carter, Gerald. 2003. <I>LDAP System Administration</I>. O'Reilly &amp; Associates.<P>
RFC 2251 (LDAP specification) -- <B>http://www.ietf.org/rfc/rfc2251.txt</B><P>
Linux-PAM System Administrator's Guide -- <B>http://www.kernel.org/pub/linux/libs/pam/Linux-PAM-html/pam.html</B><P>
Linux-PAM Module Writer's Guide --<B>http://www.kernel.org/pub/linux/libs/pam/Linux-PAM-html/pam_modules.html</B><P>
Garman, Jason. 2003. <I>Kerberos: The Definitive Guide</I>. O'Reilly &amp; Associates.<P>
Howes, T., M.G. Smith, and G.S. Good. 2003. <I>Understanding and Deploying LDAP Directory Services</I>, 2nd Ed. Addison-Wesley.<P>
Change Password Utility -- <B>http://cpu.sourceforge.net/</B><P>
<I>Travis Crawford is a Systems Administrator at Google, where he works with large Linux clusters, and recently a graduate of the Rochester Institute of Technology where he studied Information Technology. He can be reached at <B>traviscrawford@gmail.com</B>.</I></pre></table></table>&nbsp;

<! -- End Content ------ >

<!/center>
<! -- End MASTER TABLE -- >

</body>



<! -- Begin Content ------ >
</html>
