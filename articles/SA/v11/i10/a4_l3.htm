<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 4.0//EN">


<HTML>
<HEAD>
<TITLE>v11, i10: Listing 3 CSV2db::Uti</TITLE>
<LINK REL=StyleSheet HREF="../../resource/css/sacdrom.css" TYPE="text/css" TITLE="CSS1">
</HEAD>

<body bgcolor="#ffffff" text="#000000" link="#000000" alink="#669999" vlink="#333366" topmargin=0 leftmargin=0>

<! -- Begin MASTER TABLE -- >
<!center>
<table width=98% cellpadding=0 cellspacing=0 border=0 bgcolor="#ffffff">
  <tr>

<table cellpadding=5 cellspacing=0 border=0>
	<tr>

		<td><span class="navbarLink"><a href="a4.htm">Article</a></span></td>
		<td><span class="navbarLink"><a href="a4_l1.htm">Listing 1</a></span></td>
		<td><span class="navbarLink"><a href="a4_l2.htm">Listing 2</a></span></td>
		<td><span class="navbarLink">Listing 3</span></td>
		<td><span class="navbarLink"><a href="a4_l4.htm">Listing 4</a></span></td>
		<td><a href="../../../../source/SA/2002/oct2002.tar"><b class=codeListing>oct2002.tar</b></a></td>

	</tr>
</table>


</tr>
<tr>
<! -- Begin Content ------ >
    <td valign=top width=527 bgcolor="#ffffff"> 
      <table width=100% cellpadding=15 cellspacing=0 border=0>
<tr>
          <td valign=top> 
            <! -- Insert Content ------ >
            <h1><b>Listing 3 </b><i>CSV2db::Util</i></h1>
            <p> 
            <pre>
package CSV2db::Util;

use strict;
use vars qw($VERSION @ISA @EXPORT_OK);
use IO::File;
require Exporter;

$VERSION = substr q$Revision: 1.0 $, 10;
@ISA = qw(Exporter);
@EXPORT_OK = qw(fixlineends trim);

### Some utility functions that might be useful as preprocess and
### per-field processing functions.  If so, you'll want their exported
### names.  THESE ARE NOT CLASS METHODS, though they have a classy
### namespace.

# Preprocess function: read from one fh to another, fixing lineends
# along the way.  CAREFUL: this _might_ read in the whole input file
# in a single slurp.
sub fixlineends {
    my($in, $out) = @_;

    while (&lt;$in&gt;) {
    s/\015\012/\n/g;  # DOS/Windows
    s/\015/\n/g;      # Macintosh
    s/\012/\n/g;      # Unix (we might not be on Unix, eh?)
    $out-&gt;print($_);
    }
}

# Should do nothing, can be used as a test preprocessor.
# Put a gross substitute in to see it work (e.g. s/e/#/g;)
sub testcopy {
    my($in, $out) = @_;
    while (&lt;$in&gt;) {
    $out-&gt;print($_);
    }
}

# General or per-field processing function to trim leading and
# trailing whitespace.  Expects a single string, returns the trimmed
# string.
sub trim {
    my $s = shift @_;
    $s =~ s/^\s*//;
    $s =~ s/\s*$//;
    $s;
}


1;
</pre>
          </table></table>&nbsp;

<! -- End Content ------ >

<!/center>
<! -- End MASTER TABLE -- >

</body>



<! -- Begin Content ------ >
</html>
