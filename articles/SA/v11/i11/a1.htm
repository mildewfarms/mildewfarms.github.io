<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 4.0//EN">


<HTML>
<HEAD>
<TITLE>v11, i11: Cross-Platform UNIX Software Packaging with OpenPKG</TITLE>
<LINK REL=StyleSheet HREF="../../resource/css/sacdrom.css" TYPE="text/css" TITLE="CSS1">
</HEAD>

<body bgcolor="#ffffff" text="#000000" link="#000000" alink="#669999" vlink="#333366" topmargin=0 leftmargin=0>

<! -- Begin MASTER TABLE -- >
<!center>
<table width=98% cellpadding=0 cellspacing=0 border=0 bgcolor="#ffffff">
  <tr>

<table cellpadding=5 cellspacing=0 border=0>
	<tr>

		<td><span class="navbarLink">Article</span></td>
		<td><span class="navbarLink"><a href="a1_f1.htm">Figure 1</a></span></td>
		<td><span class="navbarLink"><a href="a1_f2.htm">Figure 2</a></span></td>
		<td><span class="navbarLink"><a href="a1_f3.htm">Figure 3</a></span></td>
		<td><span class="navbarLink"><a href="a1_l1.htm">Listing 1</a></span></td>
	</tr>
	<tr>
		<td><span class="navbarLink"><a href="a1_l2.htm">Listing 2</a></span></td>
		<td><span class="navbarLink"><a href="a1_l3.htm">Listing 3</a></span></td>
		<td><span class="navbarLink"><a href="a1_l4.htm">Listing 4</a></span></td>
		<td><span class="navbarLink"><a href="a1_l5.htm">Listing 5</a></span></td>
		<td><span class="navbarLink"><a href="a1_t1.htm">Table 1</a></span></td>
	</tr>
	<tr>
		<td><span class="navbarLink"><a href="a1_t2.htm">Table 2</a></span></td>
		<td><span class="navbarLink"><a href="a1_t3.htm">Table 3</a></span></td>
		<td><a href="../../../../source/SA/2002/nov2002.tar"><b class=codeListing>nov2002.tar</b></a></td>

	</tr>
</table>


</tr>
<tr>
<! -- Begin Content ------ >
    <td valign=top width=527 bgcolor="#ffffff"> 
      <table width=100% cellpadding=15 cellspacing=0 border=0>
<tr>
          <td valign=top> 
            <! -- Insert Content ------ >
            <h1><b><img src="a1.gif" width="200" height="174" align="right">Cross-Platform 
              UNIX Software Packaging with OpenPKG</b></h1>
            <p> <i>Ralf S. Engelschall, Thomas Lotterer, Michael Schloh von Bennewitz, 
              and Christoph Schug</i>
            <p> Many of us prefer open source software for its well-known advantages, 
              but sometimes regret the associated disadvantages when manually 
              applying it to a heterogeneous environment. To keep a work environment 
              stable and secure, it's often necessary to search for the latest 
              version of an application and collect the most recent patches. After 
              that, systems administrators must build and install the new binaries 
              on every UNIX box in the network. Then, after a laborious round 
              of build manipulation, it might not be clear that the application 
              will run as intended on each of the different platforms. If the 
              application is a daemon, even more work awaits because most UNIX 
              flavors have their own method of starting and stopping daemons.
            <p> In this article, we will explore OpenPKG, a software development 
              and packaging project initiated by Cable &amp; Wireless, an international 
              Internet Service Provider. The OpenPKG project began in November 
              2000 and has grown into a collaborative software development effort 
              managed and maintained by many. The project aims to create a modular 
              and flexible UNIX subsystem for cross-platform software packaging 
              and installation.
            <p> More specifically, the goals of OpenPKG stem from the historical 
              problem often faced in the daily operation of an ISP. The major 
              UNIX platforms in operation at ISPs include FreeBSD, Linux, and 
              Solaris. OpenPKG, however, is not limited to the three major platforms 
              mentioned (see Table 1). To achieve cross-platform portability, 
              OpenPKG provides a subsystem on top of the underlying UNIX system 
              as shown in Figure 1. It covers every essential server software 
              component from shells, editors, and compilers, to network daemons 
              and add-on applications. Hence, the intended target community consists 
              of systems administrators faced with a large and diverse set of 
              UNIX servers.
            <p> Internally, OpenPKG leverages the existing packaging technology 
              of the Red Hat Package Manager (RPM). However, the RPM software 
              included with OpenPKG is extended to be more unique and self-contained. 
              The more than 400 available OpenPKG packages are really just RPM 
              packages under the hood, but were developed in an OpenPKG standard 
              approach. The packages are clean and robust, because they follow 
              strict style guidelines and environment requirements.
            <p> To meet OpenPKG guidelines and standards, a package must be built 
              from pristine vendor sources in a non-root temporary environment. 
              It must work in an arbitrary file system location, follow a strict 
              file system layout, and must be self-contained within its OpenPKG 
              instance. Furthermore, the package must be independent from external 
              UNIX facilities, install with a reasonable configuration, and use 
              log file rotations and other such administrative wonders.
            <p> These package-building guidelines yield several benefits to OpenPKG 
              users. OpenPKG users can install an instance (the OpenPKG subsystem 
              and user-chosen packages) under any file system location, and even 
              install multiple such instances on a single UNIX system. The main 
              OpenPKG project environment is hosted on a machine with six other 
              ongoing software projects, each with their own dedicated OpenPKG 
              instance. To separately satisfy each project's needs, the associated 
              OpenPKG instance serves each required software component from Postfix 
              to BIND, and INN to Apache. Each project can therefore run in its 
              own isolated environment, much like on a virtual machine.
            <p> <b>The OpenPKG Package Lifecycle</b>
            <p> OpenPKG follows an approach of minimum OS intrusion and maximum 
              standalone presence. It tries hard to smooth out the differences 
              between the underlying vendor solutions. We are often asked why 
              OpenPKG uses RPM as the underlying packaging technology when other 
              alternatives exist. There are indeed other packaging technologies 
              available to projects like OpenPKG, such as the Debian <b>dpkg/apt</b> 
              combination, FreeBSD ports, and System V <b>pkgadd</b>. However, 
              RPM along with its OpenPKG extensions is the only solution that 
              covers the <i>whole</i> package lifecycle in a fully consistent 
              way.
            <p> The OpenPKG package lifecycle starts with fetching, unpacking, 
              patching, and building the source package from pristine vendor sources. 
              It builds the binary package in an unprivileged environment and 
              finishes its life term with the installation, upgrade, and de-installation 
              of the binary package on the target OpenPKG instance. This all works 
              in a self-contained environment and is driven by complete package 
              specifications (RPM <b>.spec</b> files). So, to finally answer the 
              question, OpenPKG adopts RPM as its underlying packaging technology 
              because no other fulfills these requirements.
            <p> Note that OpenPKG is primarily about packaging, not porting. One 
              requirement of the OpenPKG packaging philosophy is that the vendor 
              software be portable to begin with. Minor platform porting issues 
              are fixed by the OpenPKG packagers, but fundamental changes are 
              not considered. In fact, the main reason some platforms lack full 
              OpenPKG support is that the amount of overhead in building software 
              on them is not within reason.
            <p> OpenPKG also officially discourages the use of binary packages, 
              and only provides them for bootstrapping (development tools not 
              available) and emergency (tight time constraints) purposes. In our 
              experience, installing binary packages built from source packages 
              on the target machine outperforms other binary methods in respect 
              to security and robustness.
            <p> There are simply too many subtle differences between most build 
              and install systems that can influence the binary at run time and 
              cause trouble. Some important run-time parameters, such as the maximum 
              size of shared memory segments, are compiled into the binary on 
              the build machine. Among many examples of such a run-time build 
              dependency is a situation in which an Apache package is built with 
              mod_ssl and MM. The dependency details of such a combination are 
              overwhelming when sorting out the run-time parameters. To avoid 
              such trouble, we believe the best solution is to always start with 
              source packages.
            <p> <b>Bootstrapping OpenPKG for the First Time</b>
            <p> The OpenPKG bootstrapping process is wrapped into a shell script 
              that, when run, will create a new instance of OpenPKG. This process 
              is as self-contained as possible, and requires a minimum amount 
              of operating system support and tools to unpack and compile itself. 
              In the best case, the script will search the <b>$PATH</b> for the 
              development tools <b>tar</b>, <b>make</b>, and <b>cc</b> and use 
              them in its processing. If any of these tools are missing, an alternative 
              approach exists in which a shell script containing binaries provides 
              the missing tools.
            <p> The first step in bootstrapping involves dedicating a unique file 
              system prefix to the instance along with user and group ids. The 
              generic bootstrap building script called <b>openpkg-</b><i>version-release</i><b>.src.sh</b> 
              requires these arguments and creates a platform-specific bootstrap 
              installation script named <b>openpkg-</b><i>version-release.arch-os-id</i><b>.sh</b>. 
              When run, this script installs the OpenPKG instance under the specified 
              prefix with all files owned by the user and group (Figure 2). This 
              bootstrapping process links the OpenPKG instance with the underlying 
              UNIX system with only a few anchor points. Subsequent package installations 
              do not touch the system at all, and if OpenPKG itself is un-installed, 
              the anchor points vanish.
            <p> After creating a self-contained hierarchy, the bootstrap process 
              registers itself as <b>openpkg</b>, and can thus be upgraded or 
              treated like any other package. To make upgrading an already bootstrapped 
              OpenPKG instance easier, <b>.rpm</b> versions of the bootstrap package 
              are also available. A step-by-step example of a complete installation 
              and de-installation of an OpenPKG instance with a RSYNC server package 
              is given in Listing 1. To understand the RPM commands used, see 
              the quick reference in Table 2.
            <p> <b>OpenPKG File System Layout</b>
            <p> Every file system standard sucks. OpenPKG's file system aims 
              to suck less (Figure 2). Basically, its package area resembles the 
              traditional layout found under <b>/usr</b> on most popular UNIX 
              systems. Additionally, it contains its own RPM package management 
              information in a sub-area for purposes of self-containment and a 
              local area for adding unpackaged components.
            <p> OpenPKG breaks with tradition in one aspect of its file system 
              layout. It unconventionally uses a separate subdirectory of <i>prefix</i><b>/etc/</b>, 
              <i>prefix</i><b>/share/</b> and <i>prefix</i><b>/var/</b> for each 
              installed package. These subdirectories are easy to manage, because 
              each is named after its associated package. This provides for a 
              better structure than the usual mess of files, and every OpenPKG 
              package adheres to this layout scheme (even when requiring a lot 
              of effort to override the different vendor package intentions).
            <p> Looking again at the RSYNC example in Listing 1, note that the 
              RSYNC configuration is in <i>prefix</i><b>/etc/rsync/</b>, and it 
              logs to somewhere in <i>prefix</i><b>/var/rsync/</b>. Such ease 
              of maintenance makes backups easier, moving whole instances without 
              hassle, and more.
            <p> <b>Managing OpenPKG Packages</b>
            <p> When building packages, the temporary files are placed into subdirectories 
              of <b>prefix/RPM/</b> by default. A package builder can obtain the 
              necessary subdirectory access by either being a member of the associated 
              OpenPKG group, logging in under the user id of the OpenPKG instance, 
              or logging in as root. A carefully written <b>~/.rpmmacros</b> file 
              can alternatively redirect the paths to a specified location (see 
              the default macros <b>%_sourcedir</b>, <b>%_specdir</b>, <b>%_builddir</b>, 
              <b>%_tmppath</b>, <b>%_rpmdir</b>, <b>%_srcrpmdir</b> in <i>prefix</i><b>/etc/openpkg/rpmmacros</b>) 
              and allow even an arbitrary user to build packages.
            <p> To build a binary package <i>pkg-bin</i> from a source package 
              <i>pkg-src</i>, use <b>rpm --rebuild</b> <i>pkg-src</i>. OpenPKG's 
              RPM will read the <b>.spec</b> information of the <i>pkg-src</i>, 
              build the package based on the information, and place the resulting 
              binary package in <i>prefix</i><b>/RPM/PKG/</b><i>pkg-bin</i>. To 
              finally install the binary package so that it becomes part of the 
              OpenPKG instance, use <b>rpm -Uvh</b> <i>pkg-bin</i>. Strictly speaking, 
              this upgrades the package. To RPM, installation is nothing more 
              than the special case of upgrading from nothing.
            <p> As a side note, some packages provide alternative build variants 
              through boolean variables named <b>with_</b><i>name</i>. To determine 
              which variables are available (if any), run "<b>rpm -qpi</b> 
              <i>pkg-src</i> <b>| grep with_</b>". To build a binary package 
              using such variables, add <b>--define "with_</b><i>name</i> <i>value</i><b>"</b> 
              to the <b>rpm --rebuild</b> command to override the default value.
            <p> RPM is very clever when it comes to keeping configuration files 
              during an upgrade, as shown in Table 3. An old configuration file 
              is kept if the systems administrator stuck to default configuration, 
              or if the configuration was changed but coincidentally matches the 
              default configuration of the new package. In practice, an administrator-changed 
              configuration must be reapplied in few cases of package upgrade. 
              In any case, if a configuration file is not kept, RPM will save 
              the old configuration file with the extension <b>.rpmsave</b> before 
              saving a new default in its place. This ensures that changes to 
              a default configuration can be recovered and reapplied so that an 
              upgraded package will run correctly. If a new default configuration 
              file replaces an old one that retains its original (but old) RPM 
              default, RPM will rename it with the extension <b>.rpmorig</b>.
            <p> To make this delightful mechanism work properly, the configuration 
              files of each package must be explicitly tagged. OpenPKG packages 
              all follow this principle, further contributing to OpenPKG's 
              robust nature. OpenPKG's RPM does the intuitive right thing 
              by making sure that a changed configuration file is kept in place 
              if possible and, if not, preserves it for manual consideration and 
              application.
            <p> Finally, after the installation of a package, you can query a 
              lot of its information. The command <b>rpm -qi</b> <i>pkg-name</i> 
              summarizes a single installed package, while <b>rpm -qa</b> lists 
              the names of all installed packages. <b>rpm -qlv</b> <i>pkg-name</i> 
              lists all the files associated with a package, and <b>rpm -qf </b><i>prefix/path/to/file</i> 
              states to which package the given file belongs. You can even check 
              a package's integrity using <b>rpm -V</b> <i>pkg-name</i> to 
              verify which files have been tampered with or somehow munged. For 
              more details on this, see Table 2.
            <p> <b>The OpenPKG Run-Command Facility</b>
            <p> You might have noticed that in the previous example installation 
              of RSYNC, the server was started using the command <b>/usr/opkg/etc/rc 
              rsync start</b>. The workhorse behind this simple statement is the 
              powerful OpenPKG run-command facility, executed with <i>prefix</i><b>/etc/rc</b>. 
              Run-commands for every package are conveniently named <i>prefix</i><b>/etc/rc.d/rc.</b><i>pkg-name</i>. 
              Each offers the functionality of several shell script segments encapsulated 
              in a single file. The sections of a run-command file are identified 
              by left-aligned labels prefixed with '<b>%</b>'. Listing 
              2 shows <b>rc.rsync</b> as an example.
            <p> The <b>rc</b> command takes <i>pkg-name</i> as the first argument 
              and one or more section labels as additional arguments. The run 
              command segments corresponding with the desired section labels are 
              then extracted from the <b>rc.</b><i>pkg-name</i> file and executed 
              in the order given on the command line. The reserved package name 
              <b>all</b> serves as a wildcard and refers to all installed OpenPKG 
              packages, causing the processing of all run-command files in a specified 
              order. In this case, the run-command facility will order the run-command 
              processing according to the priority field (<b>-p</b> <i>number</i>) 
              of the given section label in each run-command file. Another popular 
              field in a section label is <b>-u</b> <i>user</i>, which directs 
              the script code to execute with the privileges of <i>user</i>.
            <p> Most sections in a run-command file have arbitrary labels intended 
              for use as command-line arguments to the run-command facility. However, 
              some sections have special meaning. The section labels of these 
              are reserved names used internally by the run-command facility. 
              For example, the <b>%common</b> section functions as a library and 
              contains script code useful to some or all of the other sections. 
              Its script code is run before any other script code.
            <p> Just like its cousin, the <b>%common</b> section, the <b>%config</b> 
              section can appear only one time in each run-command file. It contains 
              variables used to configure the behavior of the other sections residing 
              in the same run-command file. This means that logging and enabling 
              variables in a <b>%config</b> section will only affect the associated 
              package, for example. Such variables can be overridden in <i>prefix</i><b>/etc/rc.conf</b> 
              in a per-hierarchy scope, however. Technically, the run-command 
              facility assembles a large script file from the <b>%config</b> section, 
              the <i>prefix</i><b>/etc/rc.conf</b> file, the <b>%common</b> section, 
              and finally the user-defined section given as an argument (in that 
              order). The fat script is then executed.
            <p> The sections <b>%monthly</b>, <b>%weekly</b>, <b>%daily</b>, <b>%hourly</b>, 
              and <b>%quarterly</b> also have special meaning, as the OpenPKG 
              bootstrap process sets up <b>cron</b> jobs to execute them accordingly. 
              Another label often seen is <b>%env</b>, which is intended to be 
              used with the <b>--eval</b> option explained later.
            <p> Regarding configuration through variables, note that the <b>rc.</b><i>pkg-name</i> 
              file is intentionally not tagged as a configuration file and will 
              be overwritten on updates with no questions asked. The <i>prefix</i><b>/etc/rc.conf</b> 
              file is tagged as a configuration file and is intended for overriding 
              variables.
            <p> With OpenPKG, all daemon packages are released with scripts that 
              recognize the value of a variable <i>pkg-name</i><b>_enable</b> 
              (default value "<b>yes</b>"). Setting this variable to 
              "<b>no</b>" disables all run commands of the daemon in 
              question. As seen with the RSYNC server example, this can be quite 
              useful when installing a package just to get a client piece. If 
              the server piece is not of interest, then a simple variable shuts 
              it off completely. Similarly, to disable the automatic startup of 
              all daemons in a hierarchy, just add a <b>openpkg_runall="no"</b> 
              to <i>prefix</i><b>/etc/rc.conf</b>. In this case, daemons can still 
              be started manually. This feature may be useful to admins wanting 
              control over daemons with finer granularity.
            <p> The OpenPKG run-command facility has many other interesting features. 
              Use <b>rc --query</b> <i>variable</i> to see the effective value 
              of any configured variable, or use <b>rc --config</b> to see a complete 
              list of all available variables with their default and effective 
              values. The run-command facility also offers a handy feature to 
              allow packages to extend the user shell environment. For example, 
              the bootstrap package <b>openpkg</b> uses this to add the OpenPKG 
              instance into your <b>PATH</b>, <b>MANPATH</b>, <b>INFOPATH</b>, 
              etc. Just execute <b>eval '</b><i>prefix</i><b>/etc/rc --eval openpkg 
              env'</b> to perform this environment extension for your current 
              shell session.
            <p> <b>OpenPKG RPM vs. Red Hat RPM</b>
            <p> As mentioned, OpenPKG is based on a uniquely adjusted and extended 
              RPM-based packaging facility that allows for very concise and clean 
              package specifications and building of <i>every</i> package in an 
              unprivileged environment. To understand the added value of the OpenPKG 
              implementation, let's take as example the OpenPKG packaging 
              of the RSYNC program. The OpenPKG packaging consists of three files: 
              the RPM specification (<b>rsync.spec</b>, Listing 3), the run-commands 
              (<b>rc.rsync</b>, Listing 2), and the default daemon configuration 
              (<b>rsync.conf</b>, Listing 4). Compared with the RPM-based RSYNC 
              package of other vendors, the OpenPKG RPM-based package is full 
              featured yet very concise and clean. This is because of OpenPKG's 
              RPM extensions and strict style guidelines.
            <p> To offer more portable and concise shell scripting, OpenPKG's 
              RPM implementation uses GNU shtool. All manual installation and 
              patching tasks are done with the <b>shtool</b> command. A companion 
              tool, <b>rpmtool</b>, complements <b>shtool</b> with RPM and OS-specific 
              features. The <b>rpmtool</b> allows all OpenPKG packages to generate 
              their file list (<b>%files</b>) on the fly and makes the packaging 
              information smaller. It reduces the required maintenance when vendor 
              version updates occur as well.
            <p> OpenPKG's RPM additionally provides a set of local macros 
              (<b>%{l_xxx}</b>) to abstract system specifics and help in remove 
              redundancy from packaging specifications. For example, the <b>%{l_prefix}</b> 
              is the file system <i>prefix</i> of the associated OpenPKG instance. 
              Using OpenPKG's local macros offers a clear advantage, because 
              packages do not need hard-coded path prefixes and can be built for 
              arbitrary OpenPKG instances.
            <p> Macros exist for the most often used build variables. The <b>%{l_cc}</b> 
              macro expands to either <i>prefix</i><b>/bin/cc</b> (in case the 
              OpenPKG <b>gcc</b> package is installed) or defaults to <b>cc</b>. 
              The same goes for <b>%{l_cflags -O}</b>: it expands to the optimized 
              C compiler flags. If <b>gcc</b> is installed, it expands to "<b>-O2 
              -pipe</b>". Otherwise, it expands to just <b>-O</b> by default. 
              The variables <b>%{l_make}</b> and <b>%{l_mflags}</b> work together 
              in a similar way. If <b>%{l_make}</b> points to a known <b>make</b> 
              that supports parallel building, and the underlying system has more 
              than one CPU, then <b>%{l_mflags -O}</b> expands to the necessary 
              flags to leverage the system's multiple processing power. For 
              example, on a 2-CPU FreeBSD 4.x machine with BSD <b>make</b>, <b>%{l_mflags 
              -O}</b> expands to <b>-j4 -B</b>, while on a 4-CPU Linux machine 
              with GNU <b>make</b>, <b>%{l_mflags -O}</b> expands to <b>--no-print-directory 
              -j8</b>.
            <p> Additionally, all OpenPKG packages follow <i>exactly</i> the same 
              style as the RSYNC example (see Listings 2, 3, and 4). The header 
              order, indentation, etc. are standardized, and allow developers 
              to easily query and even semi-automatically edit package information 
              directly from the source. Incidentally, the indices on the OpenPKG 
              FTP server and the OpenPKG release engineering procedures are auto-generated 
              by exploiting this standard scheme.
            <p> Every OpenPKG package is able to build in an unprivileged (non-root 
              user) environment and with read-only access to an OpenPKG instance. 
              This allows safe (no development system intrusion) and precise (no 
              trashed or missing files) packaging. Such security and precision 
              is achieved by consistently using the <b>BuildRoot</b> feature of 
              RPM for <i>all</i> packages. In short, this means that when rolling 
              a binary package, the software is redirected to install into a shadow 
              area (<i>prefix</i><b>/RPM/TMP/</b><i>pkg-name</i><b>-root/</b><i>prefix</i>). 
              The package is then made from the shadow area just as if it were 
              located in the real file system location (<i>prefix</i>). This improvement 
              to the standard RPM behavior may sound trivial and easy to achieve, 
              but is actually one of the trickiest steps in packaging software 
              for OpenPKG. Sometimes (as with RSYNC), it is just a matter of overriding 
              variables (<b>prefix</b> in the example) on the <b>make install</b> 
              step. Other times, the solution is more involved. For some OpenPKG 
              packages, it takes a lot of effort to find a reasonable way to redirect 
              the vendor installation to the <b>BuildRoot</b> location, but the 
              extra effort is always worthwhile and results in safer and more 
              precise packaging.
            <p> Finally, OpenPKG's RPM implementation provides proxy packages, 
              an appealing mechanism for reusing the packages of a master OpenPKG 
              instance. Proxy packages can reside in multiple slave OpenPKG instances, 
              and allow the systems administrator to avoid redundant building 
              and maintaining of the same software package in multiple OpenPKG 
              instances. For example, <b>gcc</b> is typically required by many 
              packages at build time. A <b>gcc</b> OpenPKG package is usually 
              needed in every OpenPKG instance. A savvy systems administrator 
              will install a single <b>gcc</b> package in a master OpenPKG instance 
              and then install only proxy packages (pointing to the real <b>gcc</b>) 
              in the other OpenPKG instances by running <i>slave-prefix</i><b>/bin/rpm 
              --makeproxy</b> on the <b>gcc</b> binary RPM of the master instance. 
              OpenPKG's RPM will then produce a binary RPM package for the 
              slave instance containing a shadow tree resembling the contents 
              of the master instance. The shadow tree is technically nothing more 
              than symbolic links to the master (non-proxy) package's files 
              and directories. This mechanism can save a lot of time and storage, 
              however it should be applied to packages with global configuration 
              dependencies only or with no configuration dependencies at all.
            <p> <b>Integrating Unpackaged Software</b>
            <p> No matter how many packages OpenPKG provides, the world will always 
              have other appealing yet unpackaged software. Ambitious systems 
              administrators can package the software themselves for local purposes 
              and even contribute new packages to the OpenPKG community. Alternatively, 
              the <b>local</b> subdirectory of an OpenPKG instance exists for 
              the purpose of containing unpackaged software, and can be instrumental 
              in integrating a base of OpenPKG packages with other unpackaged 
              software in an easy to maintain way. OpenPKG also provides a corresponding 
              <b>lsync</b> tool to aid such integration.
            <p> To integrate unpackaged software into an OpenPKG instance, each 
              unpackaged software component can be installed into the <b>bin</b>, 
              <b>sbin</b>, <b>man</b>, <b>info</b>, <b>include</b>, and <b>lib</b> 
              subdirectories of <i>prefix</i><b>/local/PKG/</b><i>pkg-name</i><b>/</b> 
              and then virtually linked into the corresponding top-level directories 
              under <i>prefix</i><b>/local/</b> by running <i>prefix</i><b>/sbin/lsync</b>. 
              This strategy leads to a very clean and maintainable OpenPKG instance, 
              even with its new coexisting unpackaged software in <i>prefix</i><b>/local/</b>. 
              This especially makes it easy to un-install a package. Just remove 
              <i>prefix</i><b>/local/PKG/</b><i>pkg-name</i><b>/</b> with all 
              its contents and run <b>lsync</b> again.
            <p> This strategy even allows for installation of different versions 
              of the same software. Just install into <i>prefix</i><b>/local/PKG/</b><i>pkg-name-version/</i> 
              and add a symbolic link pointing from <i>prefix</i><b>/local/PKG/</b><i>pkg-name</i> 
              to this directory. This works because <b>lsync</b> skips subdirectories 
              of <i>prefix</i><b>/local/PKG/</b> with version numbers attached. 
              To upgrade an older <b>foo-0.7.41</b> to <b>foo-0.7.42</b>, just 
              repeat the installation in the same way, altering the symlink <i>prefix</i><b>/local/PKG/foo</b> 
              to point to <b>foo-0.7.42</b> instead and running <b>lsync</b> again. 
              <b>lsync</b> will automatically update symlinks, creating new links 
              if required and removing outdated dangling ones (see Listing 5). 
              As might be guessed, it is just as easy to go back to the old version 
              if the new one keeps dumping core or something. For an example of 
              such multiple unpackaged software installation, see Figure 3.
            <p> <b>OpenPKG Release Engineering</b>
            <p> A carefully crafted release process is part of the OpenPKG project, 
              and the fruits of the whole project are available to the public 
              according to open source standards. All sources (package specifications, 
              source patches, Web site sources, the handbook, this article, etc.) 
              are located in a publicly readable central CVS repository, which 
              can be browsed anonymously by conventional <b>cvs</b> commands or 
              through the Web site for added convenience. Additionally, all developer 
              commits to this repository are tracked and summarized with postings 
              to public mailing lists and public newsgroups. Participants can 
              easily follow all developments by subscribing to the list or reading 
              the newsgroup.
            <p> For stability and to reduce conflicts between development milestones, 
              OpenPKG has three release branches (which technically directly map 
              to CVS branches). These are OpenPKG-SOLID, OpenPKG-STABLE, and OpenPKG-CURRENT. 
              OpenPKG-SOLID is the security update branch of the last public OpenPKG 
              release. OpenPKG-STABLE is the stable branch from whose contents 
              the next public release is made. OpenPKG-CURRENT is the current 
              state of the development branch and contains packages of beta-grade 
              stability. In any case, the branch from which a package was built 
              can easily be determined by the OpenPKG RPM file name, because they 
              follow a consistent naming scheme: <i>pkg-name-version-YYYYMMDD</i> 
              (for CURRENT), <i>pkg-name-version-N.YYYYMMDD</i> (for <i>N-STABLE</i>), 
              <i>pkg-name-version-N.M.X</i> (for <i>N.M.X</i>-SOLID). Once such 
              a source RPM file is built, the new binary RPM file name contains 
              additional information, such as operating system, hardware, and 
              the OpenPKG instance prefix.
            <p> The OpenPKG developer team is very fast in keeping OpenPKG-CURRENT 
              packages up to date and in sync with the latest vendor versions. 
              This is possible because the versions of all externally available 
              vendor sources are automatically tracked on a daily basis. An OpenPKG 
              package for a new vendor software version is often available before 
              the software is even announced on Freshmeat.net.
            <p> Finally, OpenPKG takes security very seriously. Experience has 
              shown that "security through obscurity" does not work, 
              and that public disclosure leads to quicker and better solutions 
              to security problems. Thus, OpenPKG tries to release fixed packages 
              as quickly as possible when a vulnerability is discovered. The OpenPKG 
              security release and advisory process publishes official security 
              advisories in the security section of the Web site and on the mailing 
              lists.
            <p> <b>Conclusion</b>
            <p> OpenPKG is an open source software project founded by Cable &amp; 
              Wireless Germany in November 2000. The implementation relies on 
              RPM 4 for its basic packaging mechanism, but offers more than RPM 
              alone. To meet its goal of becoming a modular and flexible UNIX 
              subsystem for cross-platform software packaging and installation, 
              OpenPKG includes tricky bootstrapping logic that installs a customized 
              implementation of RPM 4 on any of the supported target platforms.
            <p> OpenPKG has been in production use at Cable &amp; Wireless Germany 
              since April 2001. Since its public release in January 2002, OpenPKG 
              users have profited from an increase of 220 to more than 400 software 
              packages. The project is continuously improved by a team of developers 
              who also daily update and add packages. The base of OpenPKG software 
              packages is expected to increase even more, partly because of the 
              ease of writing specifications and building packages. Most OpenPKG 
              users find it deceptively simple to build a basic package. New users 
              interested in such packaging can use the RSYNC example in this article 
              as a blueprint. Accordingly, package contributions are always appreciated 
              by the members of the OpenPKG project.
            <p> To make OpenPKG even more attractive, work is under way on a front 
              end, which will simplify and control the installation process according 
              to build and install dependencies. OpenPKG is also fulfilling plans 
              to satisfy the desktop user by offering X11-dependent packages for 
              Gtk, Qt, Gimp, Mozilla, and many others. For faster execution and 
              even more flexibility, a further enhanced run-command processor 
              is also under development. Shared library support is under investigation, 
              too. Lastly, we are looking forward to upgrading OpenPKG to use 
              the forthcoming RPM 4.1 version.
            <p> <b>References</b>
            <p> OpenPKG: <b>http://www.openpkg.org/</b> <b>ftp://ftp.openpkg.org/</b>
            <p> OpenPKG Community Forums: <br>
              <b>mailto:openpkg-users@openpkg.org</b> <br>
              <b>mailto:openpkg-dev@openpkg.org</b> <br>
              <b>nntp://news.openpkg.org/openpkg.users</b> <br>
              <b>nntp://news.openpkg.org/openpkg.dev</b>
            <p> RPM <b>http://www.rpm.org/</b> <b>ftp://ftp.rpm.org/pub/rpm/</b>
            <p> <i>Ralf S. Engelschall is a computer scientist and Open Source 
              software hacker, leading the software development department at 
              Cable &amp; Wireless Germany. He is the author of well-known software 
              like Apache mod_ssl, GNU Pth, and GNU Shtool and the founder of 
              Open Source software projects like OpenSSL, OpenPKG, and OSSP. He 
              can be contacted at: <b>rse@engelschall.com</b>.</i>
            <p><i> Thomas Lotterer is a network professional and consultant working 
              as a UNIX software developer at Cable &amp; Wireless Germany. He 
              gained experience in cross-platform system integration and software 
              distribution by working previously as a systems administrator and 
              technical trainer. Today, Thomas works actively on the OpenPKG and 
              OSSP projects. He can be contacted at: <b>thomas@lotterer.net</b>.</i>
            <p><i> Michael Schloh von Bennewitz is a software engineer at Cable 
              &amp; Wireless Germany, where he works on the network and user interface 
              logic of ISP tools and technologies. He is an active contributor 
              to both the OpenPKG and OSSP projects. With fingers blazing, Michael 
              listened to classical music while writing parts of this article 
              in order to go even faster. He can be contacted at: <b>michael@schloh.com</b>.</i>
            <p><i> Christoph Schug is a senior UNIX systems administrator at Cable 
              &amp; Wireless Germany. He leads the hosting department and is responsible 
              for all managed servers at the Munich data center. His revolutionary 
              ideas and visions often result in additional lines in Ralf's 
              TODO list. When not in the office, Christoph might be found in the 
              Alps steering the screaming and smoking tires of his Miata MX-5 
              roadster. He can be contacted at: <b>chris@schug.net</b>.</i>
          </table></table>&nbsp;

<! -- End Content ------ >

<!/center>
<! -- End MASTER TABLE -- >

</body>



<! -- Begin Content ------ >
</html>
