<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 4.0//EN">


<HTML>
<HEAD>
<TITLE>v02, i06:  New Messages</TITLE>
<LINK REL=StyleSheet HREF="../../resource/css/sacdrom.css" TYPE="text/css" TITLE="CSS1">
</HEAD>

<body bgcolor="#ffffff" text="#000000" link="#990000" alink="#669999" vlink="#333366" topmargin=0 leftmargin=0>

<! -- Begin MASTER TABLE -- >
<!center><table width=600 cellpadding=0 cellspacing=0 border=0 bgcolor="#ffffff">

<tr>

<table cellpadding=5 cellspacing=0 border=0>
	<tr>

		<td><span class=navbarLink>Article</span></td>
		<td><a href="../../../../source/SA/1993/nov93.tar"><b class=codeListing>nov93.tar</b></a></td>

	</tr>
</table>


</tr>
<tr>
<! -- Begin Content ------ >
<td valign=top width=440 bgcolor="#ffffff">
<table width=100% cellpadding=15 cellspacing=0 border=0>
<tr><td valign=top>



<H1>New Messages</H1><p>
<P>
From: Guido Beijderwellen &lt;q8.nl!beijder@uunet.uu.net&gt;
Status: RO<P>

Robert,<br>

We are very happy with the magazine Sys Admin. It gives
us 
the extra knowledge and tools to make an Administrator's
life much 
easier.<P>

I am trying to connect to your system in order to download
the last 
month's listings file. But I cannot get in contact with
the number 
1-900-468-7727. Is this a wrong number?<P>

Regards, Guido Beijderwellen<br>
Kuwait Petroleum (Benelux) B.V.<br>
beijder@kpn or: ...hp4nl!kpn!beijder<P>

<I>The number is correct but is apparently not accessible
to 
some international callers. We are working on alternate
code distribution 
possibilities, but have not yet found a suitable solution.
We are 
considering posting the Sys Admin code on CompuServe
-- would our 
readers like to see that?</I><P>



To: saletter@rdpub.com<br>
Subject: Good job!<P>

Dear Editor:<br>

I appreciate SysAdmin mag format in providing real solutions
and practical 
information. There are too many computer mag's dedicated
to keeping 
the world abreast on the latest toy or comparing Joe
Blow's product 
with John Doe's. Even though I'm a new subscriber, I've
already implemented 
several procedures I read about in SA. Most recently,
I was helped 
by the article called &quot;fchange: A File System Watchdog&quot;
written 
by Steven G. Isaacson. <P>

Keep up the good &quot;practical&quot; work, SA!<P>

Donald C. Stone<br>
System Administrator/GIS Coordinator<br>
California Dept. of Transportation - District 03<br>
703 B Street<br>
Marysville, CA 95901<br>
t3stone@t3avax.dot.ca.gov<P>

<I>Thanks for your kind words.</I><P>



From: Mark Dadgar &lt;mdadgar@wma.com&gt;<br>
To: saletter@rdpub.com<P>

Editor, SysAdmin, <P>

This is in response to Larry Reznick's response to Christopher
Calabrese's 
letter. <P>

Larry states that:<P>

&quot;As for directory names containing a space, that
sin is not easy 
to commit by the average user. If I ever saw that actually
happen, 
I'd track down the owner, find out why and what depends
on it, and 
rename the offending directory as soon as I can.&quot;<P>

Well, Larry, in our environment here (360 NeXT workstations),
our 
users create hundreds of files like this every day.
We have exclusively 
non-technical people on our system, and the NEXTSTEP
environment does 
not forbid file naming with spaces. And I don't see
why it should. 
This is a modern system we're talking about here. We've
left 8+3 DOS 
naming behind, let's leave as many old UNIX file restrictions
as we 
can, too.<P>

True, it makes system administration a little more difficult
(by making 
shell scripts more complex), but the most useful utilities
(gnutar, 
etc.) have no problem with filenames of this kind. And
if we're going 
to move these non-technical people into the future of
computing, we 
need to adapt the system (as much as is possible) to
THEIR way of 
thinking, and not them to ours.<P>

Mark Dadgar, NeXT SysAdmin<br>
William Morris Agency<br>
mdadgar@wma.com (NeXTmail) <P>

<I>Larry Reznick responds: I didn't bring MSDOS into the
conversation. 
As it happens, MSDOS doesn't restrict spaces in filenames,
command.com 
does. However, in all of the UNIX shells, the only way
to put a space 
into a filename on the command line is to enclose it
in quotes. That 
isn't commonly done by the average user. Within an application,
though, 
anyone might enter a space in response to a filename
prompt. The application 
simply passes the name on to the operating system when
creating or 
opening the file. <P>

The underlying OS file functions have no problem with
any 
characters including the various shell metacharacters,
redirection 
symbols, and any other symbols special to the shells.
Those characters 
simply aren't important to the underlying functions.
They are important 
to the shells, though, and most day-to-day system administration
is 
done from one shell or another. Those characters are
troublesome. 
If all maintenance of those files is restricted to application-specific

maintenance, they present no important problem for an
aware administrator. <P>

For instance, SVR4 and BSD filenames are limited to
255 
characters. Not much of a limit. One company I worked
for several 
years ago took advantage of that with applications that
created and 
worked with automatically generated filenames that might
be as long 
as 100 characters. Those files were destined for CDROM.
The names 
bore indexing and origin information for an audit trail.
Those filenames 
were a bear to type, and contained many unusual characters,
although 
no characters conflicted with shell metacharacters.
On the rare occasions 
we had to deal with those files manually, we usually
used wildcards. 
All of the applications I wrote to deal with them made
UNIX tell the 
program their names. The applications rarely dealt with
the names 
except as arbitrary strings. No restrictions, although
we did avoid 
characters meaningful to the shells.</I><P>



Editor,<br>

Concerning Larry Reznick's which program (Sys Admin

2.3): We had a C program called wh that had the function
of 
which. I replaced the C program with which because it

was easier to read. I just wanted to point out that
the while 
loop can be easily replaced with a for loop. I think
a for 
loop makes the program easier to read.<P>

My program (see Listing 1:  E-Media Production Manager's note:  Listings referenced within the New Messages/Letters can be found by
scrolling to the bottom of the current page.) does not exactly match yours
in function
because I wanted to match our old wh functions.<P>

Sincerely,<br>

Rory Hammond<P>

<I>A slightly different approach -- thanks for sharing
it.</I><P>



Dear Editor,<br>

We have recently acquired a product which runs on a
UNIX platform, 
having previously been a solely VAX VMS site. Unfortunately,
our UNIX 
platform appears to lack the functionality of VMS.<P>

Within VMS, the operating system can be set up so that
when a user 
logs onto the VAX across the network, he is given two
terminals, a 
physical and a virtual terminal. If for some reason
he loses his session 
across the network, his physical terminal is destroyed;
however, the 
virtual terminal is left intact, and, on logging in
again, the user 
can reconnect to his previous session via the virtual
terminal and 
carry on as though nothing has happened.<P>

My question is: does anyone know of a product that would
give us the 
above functionality under UNIX? We are running NCR SVR4
and IBM AIX. 
The nearest I can get so far is Double Vision from MaxTech,
which 
may allow users to connect to a lost session and log
it out, but would 
like the process to be automatic.<P>

Simon D. Ralfs<br>
Norwich Union Investment Management<br>
PO Box 150, Sentinel House<br>
37 Surrey Street<br>
Norwich, England NR1 3UZ<P>

<I>Can any of our readers help?</I><P>


<H1>Listing 1: Rory Hammond's wh</H1><p>
<P>
<PRE>
#! /bin
:
#ident &quot;@(#)    Rory Hammond -PN1 - /usr/lbin/wh&quot;
# 07-11-93   replaced C program with this shell
#
#       wh
#
#       Examine the path for a command &amp; tell which dir has it. Stop with
#       the 1st dir that has it.
#
#

if [ $# -eq 0 ]
then
echo &quot;usage:\t$0 prognam ....&quot; &gt;&gt;&amp;2
exit 1
fi

dirs=F51&gt;`F255&gt;echo $PATH |
sed -e 's/^:/.:/' -e 's/:$/:./' -e 's/::/:.:/' -e 's/:/ /g'F51&gt;`F255&gt;

notfound=

for ffile in $*
do
found=0

for dir in $dirs
do
if [ -x ${dir}/${ffile} -a ! -d &quot;${dir}/$1&quot; ]
then
echo ${dir}/${ffile}
found=1
break
fi
done

if [ ${found} -eq 0 ]
then
notfound=&quot;${notfound} $1&quot;
fi

shift
done

#report the not found

for arg in $notfound
do
echo &quot;${arg} not found&quot;
done

exit 0
</pre><p>
<p>



<P><br>&nbsp;<br>
</table></center></td>
<! -- End Content ------ >

</table><!/center>
<! -- End MASTER TABLE -- >

</body></html>
