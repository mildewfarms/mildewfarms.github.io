<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 4.0//EN">


<HTML>
<HEAD>
<TITLE>Web Feature:  User Configuration Basics</TITLE>
<LINK REL=StyleSheet HREF="../../resource/css/sacdrom.css" TYPE="text/css" TITLE="CSS1">
</HEAD>

<body bgcolor="#ffffff" text="#000000" link="#990000" alink="#669999" vlink="#333366" topmargin=0 leftmargin=0>

<! -- Begin MASTER TABLE -- >
<table width=100% cellpadding=15 cellspacing=0 border=0 bgcolor="#ffffff">

<tr>
<td>
<table cellpadding=5 cellspacing=0 border=0>
	<tr>

		<td><span class=navbarLink>Article</span></td>
		<td></td>

	</tr>
</table>
</td>

</tr>
<tr>
<! -- Begin Content ------ >
<td valign=top>
<h1>
User Configuration Basics
</h1> <p>
William L. Garner
<br>&nbsp;<br>

<p>Recently, I found myself in the position of explaining user configuration basics to two clients who, despite having run UNIX environments for some time, had failed to grasp some fundamental rules, concepts, and ideas of this task. Both clients had large numbers of users using a single home directory. Both clients had several group accounts, that is, accounts used by more than one person. Both clients had <B>.rhosts</B> files in every imaginable place. Before explaining the evils of these practices to my clients, I undertook some research so I could recommend some reading on the subject. I was quite surprised not to find an easily accessible document that adequately covers user configuration basics. Many system administration books discuss the mechanics of the process, but none adequately covers the rationale behind the mechanics. That is what this article is intended to do. The opinions expressed here are mine. Other rational minds may sometimes disagree.<p>
The creation of a UNIX user account is not a complicated thing, yet very often it is not done completely or correctly. If not done completely and correctly, the user account may experience problems, be unsecure, or unstable. A complete user configuration includes the following steps:<p>
<ol>
<li>An entry in <B>/etc/passwd</B> with all seven fields properly populated.<p>
<li>Group membership establishment.<p>
<li>A home directory with proper permissions and ownership.<p>
<li>Startup scripts in the home directory with proper ownership and permissions.<p>
<li>Creation of trust files with proper ownership and permissions.<p>
<li>Special abilities: <B>ftp/at/cron</B> considerations.<p>
</ol>
<p>The execution of the aforementioned steps is adequately documented in a variety of places. Our concern is the thinking behind the steps.	<p>
The creation of the entry in <B>/etc/passwd</B> for a new user is a simple process of adding a record consisting of seven colon delineated fields. The first field is that of the User Name. There are a number of schools of thought regarding the construction of the user name. One school maintains that the user name should be constructed from the components of the user's actual name. W.L. Garner, for example, might be used to construct "wlgarn" as a user name. A second approach is the arbitrary creation of a "handle". W.L. Garner might be user "falcon". A third approach is the creation of what are sometimes referred to as "A-Numbers". Garner's user name might then be "A4214".<p>
Each approach has advantages and drawbacks. The principle disadvantage of the first method is that that theft of a phone book will provide the raw data necessary to construct valid user names. This, obviously, is a potential security problem. The advantage to this approach is that a user is unlikely to forget their name. The second approach has a similar weakness. Names chosen in this manner are often easily guessed, or already common knowledge. The final approach is generally regarded as the most secure. It has no pre-existing association with the actual user and its construction can be varied. The disadvantage is that users must remember their "A-Number". The counter to that concern is that if a user isn't smart enough to remember the "A-Number", then they probably shouldn't have an account anyway.<p>
After the User Name field in <B>/etc/passwd</B> comes the password field. This field should never be left open or blank. To leave it blank is to create an unprotected account. An unprotected account is never acceptable. While creating the account, obviously, you can not hand code an encrypted password into this field. You can, however, set the password immediately after creating the account. This must be done. Never, ever leave an account unprotected even for 5 minutes. Make the setting of the password a ritual thing.<p>
Following the password field is the UID field. UID stands for User Identification. While we humans may refer to user garner, the UNIX operating system knows only UID 4332. UNIX makes no use of the user name, other than in the <B>passwd</B> file and in output displays of <B>ls</B>. Just as having two friends named John can sometimes lead to disastrous confusion, having two users with a UID of 4332 will cause similar confusion. Consequently, it should be written in stone that: a) UID numbers will be unique; b) users will never be removed from <B>/etc/passwd</B>; and c) UIDs will never be "reused". These rules should be written in stone because if you have unique UID numbers, do not remove user from <B>/etc/passwd1</B>, and do not "reuse" UID numbers, you will never encounter confusion relating to user identification and ownership issues.<p>
It can be argued that there are ways to break these rules and still have everything work properly. True, it can be done and as in the case of sites like Universities with high rates of turnover in users, sometimes it must be done. In these cases, it is all the more critical to establish standards and procedures for doing this because the potential for trouble will always be there. Keep in mind that one of the keys to success in systems administration is to make it easier to be right than it is to be wrong. For the vast majority of sites, reusing UID numbers is not a good idea. None the less, there will be people at these sites who will still insist on removing users from <B>/etc/passwd</B> and reusing the UID number. If you are a consultant, follow them around. you will make a great deal of money fixing what they break.<p>
The fourth field is the GID. This is the Group Identification number, where the association between the user and his/her/its principal group is made. A user can be a member of a number of groups, switching at will, or belong to all at once. This multiple association is made in the <B>/etc/group</B> file. The functionality afforded by groups is that it allows you to grant groups of people/users access to files for which they share a common need.<p>
The fifth field is the GECOS field. Conventional wisdom used to prescribe certain contents for this field. These contents included the user's actual name, phone number, office location, etc. The rise of the Internet, however, changed this. Current thinking is that this field should be empty except for three commas. The giving away of names, phone numbers, and office locations makes it too easy for someone to determine who is on vacation, out sick, etc. <B>finger</B> uses the <B>/etc/passwd</B> file for its information, so expect some complaints when <B>finger</B> no longer provides that information. Accept the complaints with a smile, and keep the information out of <B>/etc/passwd</B>.<p>
The sixth field establishes the location of the user's home directory. This is the directory in which the user finds himself when he logs in. An analogy can be made to a user's desk. It is the place where the user works - a place to store things, a filing cabinet, pens. Just as desks are usually equipped with locks, a user's home directory should be secured. That is, the user should own that directory, and it should not be writable by anyone else. This is one of the only places where a user should be able to create files and directories.<p>
One of the problems with group accounts is that the home directory is shared. Files created here could have been created by any of the group of people using that account. Which person actually created the file? No way to tell. It is in the home directory that users will find their configuration and startup files. The ownership of these files, and the permissions on them, should reflect your policy. At some sites, the user owns the <B>.profile</B> and other startup scripts as well as the configuration files found in the home directory. One advantage to having someone other than the user own those files, is that the user can be prevented from modifying or changing the files. This can be important where users are supposed to be "captive". That is, they log in and go directly into an application. Additionally, it may be important to have someone other than root own "trusting" files, so that their unauthorized modification can be prevented. Another way to make a "captive" user is to ensure that they never exit the <B>.profile</B> except to logout. Any application that is called must have no user exits or shell escapes.<p>
The seventh field defines the user's default shell. This is the executable shell that the user's account uses when the user logs in. Accounts that are enabled should have a functional shell here. Accounts that are disabled should have a non-functional shell here. If users are not allowed to change their default shell, then the execution bit for world and group should be removed from the <B>chsh</B> command. Also, ensure that the <B>/etc/shells</B> file is populated. This file defines the "legal" shells for your environment.<p>
"Trusting" files are those that create a trust relationship. In particular, <B>.rhosts</B> creates a "trust" relationship with the servers whose names appear in the file. The functionality of <B>.rhosts</B> is that a user coming from a "trusted" machine will not be required to enter a password when using <B>remsh</B> or <B>rlogin</B>. The remote machine trusts the authentication performed on the other machine. Thus, a user can acquire unauthenticated access to a machine. This is not a good thing. In the vast majority of cases, the justification for the existence of a <B>.rhosts</B> file is convenience. Usually, someone just doesn't want to type a password. They may give you all sorts of other reasons for the existence of the <B>.rhosts</B>, so it is important to dig deeply and see if there is not a more secure means to meet the user's requests. In some cases, there will be a legitimate need for a <B>.rhosts</B> file. Document this need extensively. Also document why other options won't meet the need. Watch this account closely, and make sure that security on the trusted machine is good. The existence of a <B>.rhosts</B> file is a major vulnerability. Although the exposure can be minimized, it is still exposure.<p>
Some sites will place an empty <B>.rhosts</B> file in every home directory. This file will be owned by root and not writable by anyone. The same is done for the <B>.**rc</B> files. Create them; have root own them; remove write permissions. By doing this, you prevent someone else from creating these files. However, as long as the user owns the directory, they can remove the files and create new ones. In such cases, other measures must be taken.<p>
There are a number of detail-oriented tasks that must accompany the creation of a new account. If the account does not require <B>ftp</B> ability, then the user should be added to the <B>/etc/ftpusers</B> file. This file works backward from what would seem intuitive. Inclusion of a user name in the file prevents <B>ftp</B> capability. Depending on your position regarding <B>at</B> and <B>cron allow/deny</B> files, it may be necessary to add the user name to one or both of these files. In any case, users should be explicitly granted or denied access to <B>cron </B>and <B>at</B>.<p>
In any discussion regarding users, the subject of the "root" account should be covered. Because of root's awesome power and responsibility in the environment, it is sometimes overlooked that root is, still, a user. A very powerful user, but none the less, a user. As such, root, more than the ordinary user, should enjoy a very protected home environment. Many platforms will allow you to move root's home directory from <B>/</B> to something more in keeping with the standard home directory configuration for your site. If all of your user's home directories are in <B>/home</B>, then root's home should be <B>/home/root</B>. Just like other user, <B>/home/root</B> should be owned by the user, that is, root. It should be readable and writeable only by the owner. Its <B>.profile</B> should be owned by root, read and writable only by the owner. An empty <B>.rhosts</B>, owned by root, should exist, readable and writable only by the owner.<p>
Some platforms will not be candidates for configuring root in this manner. The moving of root's home directory to a file system that may not be mounted during a boot to single user may cause problems. Before you configure your root environment in this manner, make sure that your platform will not have problems. In cases where root cannot be configured in this way, it is recommended that a directory for root be created in the same manner as described above, and that root use it as a repository for root's scripts, output, etc. The <B>/</B> directory is not the place for root's scripts and output files. Keep <B>/</B>clean.<p>
Root should be restricted to logging in at the console. Furthermore, ensure that the console is in a restricted area. Root should be a rarely used account. Systems administrators should not routinely use the root account for activity that does not require root authority. To do so invites disaster. Access to the root account should be made via <B>su</B>. This ensures that there is a trail of who has used root. Additionally, it gives you an opportunity to detect unauthorized root activity. Root's password should be a closely held secret. If you have more than one person who needs root authority, investigate the acquisition of a "root delegation" tool. These tools will allow you to selectively and auditabily grant root authority to users other than root. This will go a long way toward helping you secure root access.<p>
Now that I've covered some of the specific "do's", here are a few "don'ts". Because the actual list of things not to do is almost infinite, consider this a short list.<p>
<B>Do not share home directories.</B> It's never a good idea. It doesn't save appreciable disk space. It doesn't simplify user administration. It destroys accountability and security.<p>
<B>Do not allow "group" accounts.</B> A group account is any account that has more than one person accessing it. This also destroys accountability and security. I have heard every imaginable reason for a group account, and have yet to encounter one that is valid. The group functionality was put in UNIX for a reason. Use it. If that isn't enough, use ACLs. If you can't get the functionality via permissions and ACLs, then look at the business process. Just as a bank makes sure that each teller works out of his or her own drawer, you must make sure that each user works out of his or her own account. Accountability is vital not only to determine who did what, but also vice versa.<p>
<B>Do not grant ftp capability to root.</B> Root must be the most secure account on the machine. If you need to <B>ftp</B> something, do it under your personal account. Don't do it as root.<p>
<B>Do not take shortcuts.</B> Do it right the first time. Shoot anyone who cuts and pastes between <B>/etc/passwd</B> files.<p>
<B>Control-D</b><p>User administration can be a mind-boggling task at larger sites and a pain in the neck at smaller sites. The use of standards in user configuration will help make this task more manageable, and make it easier to teach to new administrators. It will improve your ability to identify backup requirements for your environment. Standard user configuration will also help you prepare your site to become more secure. Despite a seemingly endless list of reasons to adopt standards, you will inevitably encounter someone who wants to re-invent user administration standards. If you are a consultant, greet them warmly and follow them around. Remember, fixing what they break will make you a lot of money. 

<h1>About the Author</h1><p>
William Garner has been a working system administrator for fifteen years. As President of the North American Performance Group, he has built an organization of hard-core system administrators solving problems related to system administration, performance and security for clients across North America. He can be reached at wlgarner@napg.com</a>.

<br>&nbsp;<br>
<! -- End Content ------ >
</td>
</tr>

</table></center>
<! -- End MASTER TABLE -- >
</body></html>