<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 4.0//EN">


<HTML>
<HEAD>
<TITLE>v05, i11:  New Messages</TITLE>
<LINK REL=StyleSheet HREF="../../resource/css/sacdrom.css" TYPE="text/css" TITLE="CSS1">
</HEAD>

<body bgcolor="#ffffff" text="#000000" link="#990000" alink="#669999" vlink="#333366" topmargin=0 leftmargin=0>

<! -- Begin MASTER TABLE -- >
<!center><table width=600 cellpadding=0 cellspacing=0 border=0 bgcolor="#ffffff">

<tr>

<table cellpadding=5 cellspacing=0 border=0>
	<tr>

		<td><span class=navbarLink>Article</span></td>
		<td><a href="../../../../source/SA/1996/nov96.tar"><b class=codeListing>nov96.tar</b></a></td>

	</tr>
</table>


</tr>
<tr>
<! -- Begin Content ------ >
<td valign=top width=440 bgcolor="#ffffff">
<table width=100% cellpadding=15 cellspacing=0 border=0>
<tr><td valign=top>




<H1>New Messages</H1><p>
<P>
Please send letters via email to saletter@mfi.com.<P>



The following letters are in reply to a question about
noninteractive
file transfers that appeared in the August issue.<P>



From: John Nelson (jnelson@internoc.net)<br>
The internetwork operating company, inc.<P>

I have two suggestions for noninteractive file transfers.
If you are
transferring between two trusted machines, the rdist
program is a very
effective way to synchronize files.<P>
<PRE>
$&gt; rdist -f /path/to/distrib</pre><p>
<p>
the distrib file is as follows:<P>
<PRE>
HOSTS = ( machine1.domain.com machine2.domain.com)

FILES = ( /etc/passwd /etc/shadow /etc/shadow- /etc/group )

${FILES} -&gt; ${HOSTS}
install ;</pre><p>
<p>
This will copy the four important password files from
the local machine
to both 1 and 2. When using rdist, all the machines
must trust each
other by putting one another's names in the .rhosts
or /etc/hosts.equiv
file. rdist can be used in the crontab to be run automatically,
or might
be forced to run after every password update.<P>

Another possibility is a package called mirror. This
is a set of Perl
scripts used to mirror WWW sites and such. The latest
release of mirror
no longer supports put, but you may be able to find
an older version.
The latest version of mirror is available from: src.doc.ic.ac.uk
[146.169.2.1] directory: computing/archiving/mirror
(shortcut
packages/mirror); ftp.th-darmstadt.de [130.83.55.75]
directory:
pub/networking/mirror; or ftp.sun.ac.za [146.232.212.2]
directory:
pub/packages/mirror.<P>

mirror is part of a family of related programs. The
others are ftpmail
and ftpcat. ftpmail is a mail responder, and ftpcat
cats a remote file.
These can be found in: src.doc.ic.ac.uk:packages/ftpmail/
and
packages/ftpcat/.<P>



From: Michael G. Phillips (mgphl@cybertron.com)<br>
DBS@Bluewater Bay, Florida<P>

I am assuming that the request is for running ftp within
a shell script.
I do this quite regularly (via cron, even) by using
an alias in my
/etc/hosts file and an entry in .netrc. This allows
the script to invoke
ftp and redirect stdin as inline or from a file.<P>

In fact, I just used a Perl script to output cd, lcd,
and put commands
to rename and move files from 19 different directories
on my AIX box to
19 different partitioned datasets on our MVS box. The
output of the
script was simply piped to an ftp command.<P>

I know .netrc files are disliked by some people, but
they sure make this
process a lot simpler.<P>



From: Kevin Erickson (kerickso@bcbsnd.com)<br>
Blue Cross Blue Shield of North Dakota<P>

I have a suggestion for anyone needing a noninteractive
ftp. I've been
using expect for those types of needs. expect is &quot;A
Tcl-based Toolkit
for Automating Interactive Programs.&quot; O'Reilly
&amp; Associates, Inc. has
published an excellent book, Exploring Expect, entirely
devoted to
automating things that normally can't be automated.<P>

Below is a very simple expect script that connects to
an anonymous ftp
server, gets a file from /pub, and puts it back into
/pub/incoming:<P>
<PRE>
-- #!/usr/bin/expect --
spawn ftp $argv
expect &quot;Name&quot;
send &quot;anonymous\r&quot;
expect &quot;word:&quot;
send &quot;kerickso@bcbsnd.com\r&quot;
expect &quot;ftp&gt; &quot;
send &quot;get /pub/file1 myfile\r&quot;
expect &quot;ftp&gt; &quot;
send &quot;put myfile /pub/incoming/file2\r&quot; expect &quot;ftp&gt; &quot;
send &quot;quit\r&quot;
expect eof</pre><p>
<p>
The script could also do error checking, read a list
of files to
transfer from a file, etc. A sample expect script, rftp,
comes with the
distribution, which even does recursive ftp. A tool
to go along with
expect is autoexpect, which generates an expect script
from watching a
session.<P>

If you want more info, check out the expect home page
at:<P>
<PRE>
http://www.cme.nist.gov/pub/expect/index.html</pre><p>
<p>
<I>Thank you all for your suggestions. -AA</I><P>



Response to Arthur Donkers' letter in August:<br>

In the August '96 edition of Sys Admin, there was a
discussion about
Linux. Donkers said, &quot;I agree with you that 1.0.xx
and 1.2.xx kernels
are know as 'production' kernels and reasonably stable.&quot;<P>

I just want to defend 1.3.xx a little bit, because where
I'm working we
are running a www and ftp server on a Linux box with
kernel 1.3.20. This
system has been up (at the time I write this) for 139
days without any
failures. I would call this reasonably stable, if not
more, especially
when compared to an HP-UX system we have that has to
be rebooted once a
week. The network performance for this Linux box is
better than a news
box we have that runs on FreeBSD.<P>

Regards,<br>

Eje Gustafsson (gne@ffa.se)<br>
SystemAdministrator<br>
The Aeronautical Research Institute Of Sweden<P>




<P><br>&nbsp;<br>
</table></center></td>
<! -- End Content ------ >

</table><!/center>
<! -- End MASTER TABLE -- >

</body></html>
