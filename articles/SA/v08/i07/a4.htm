<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 4.0//EN">


<HTML>
<HEAD>
<TITLE>v08, i7: TCP Connection States - A Clue to Network Health</TITLE>
<LINK REL=StyleSheet HREF="../../resource/css/sacdrom.css" TYPE="text/css" TITLE="CSS1">
</HEAD>

<body bgcolor="#ffffff" text="#000000" link="#990000" alink="#669999" vlink="#333366" topmargin=0 leftmargin=0>

<! -- Begin MASTER TABLE -- >
<!center><table width=600 cellpadding=0 cellspacing=0 border=0 bgcolor="#ffffff">

<tr>

<table cellpadding=5 cellspacing=0 border=0>
	<tr>

		<td><span class=navbarLink>Article</a></span></td>
		<td><span class=navbarLink><a href="a4_f1.htm">Figure 1</a></span></td>
		<td><span class=navbarLink><a href="a4_f2.htm">Figure 2</a></span></td>
		<td><span class=navbarLink><a href="a4_f3.htm">Figure 3</a></span></td>
		<td><span class=navbarLink><a href="a4_f4.htm">Figure 4</a></span></td>
	</tr>
	<tr>
		<td><span class=navbarLink><a href="a4_f5.htm">Figure 5</a></span></td>
		<td><span class=navbarLink><a href="a4_f6.htm">Figure 6</a></span></td>
		<td><span class=navbarLink><a href="a4_f7.htm">Figure 7</a></span></td>
		<td><span class=navbarLink><a href="a4_f8.htm">Figure 8</a></span></td>
		<td><span class=navbarLink><a href="a4_t1.htm">Table 1</a></span></td>
	</tr>
	<tr>
		<td><span class=navbarLink><a href="a4_t2.htm">Table 2</a></span></td>
		<td><a href="../../../../source/SA/1999/jul99.tar"><b class=codeListing>jul99.tar</b></a></td>

	</tr>
</table>


</tr>
<tr>
<! -- Begin Content ------ >
<td valign=top width=440 bgcolor="#ffffff">
<table width=100% cellpadding=15 cellspacing=0 border=0>
<tr><td valign=top>
<! -- Insert Content ------ >

<H1>TCP Connection States - A Clue to Network Health</H1><p>
<P>Noah Davids
<P>
Most network administrators know that the <B>netstat -n</B> command will display a list of TCP connections and their states. Usually, the connection state is <B>ESTABLISHED</B>. Occasionally, the state is <B>FIN_WAIT_2</B> or <B>CLOSE_WAIT</B>. Very rarely it will be <B>SYN_SENT</B>, <B>SYN_RCVD</B>, or <B>FIN_WAIT_1</B>. Although all these states are normal, connections are typically in these states for only a brief time. Having connections in these states for longer than a few seconds, or having more than a few connections in these states at any one time may indicate a network problem. But in any case, the cause of this condition should be determined. This article explores how to diagnose network problems based on the state of the TCP connection.<p>
<B>The TCP States</b><p>The TCP states are defined in RFC-793. Figure 1 shows the TCP state machine, which defines what state to move to next and what type of packet to send back when a given type of packet is received. In general, TCP connections involve synchronizing the connection (SYN), transmitting the data, and then finishing, or closing the connection (FIN). As requests are made between systems, acknowledgements (ACK) are transmitted back and forth to assure that both sides of the connection agree on the state of the connection. For a more detailed explanation of these states, see the companion Web article on the <I>Sys Admin</I> Web site: <B>samag.com</B>.<p>
<B>Diagnoses</b><p>Table 1 lists most of the likely (and not so likely) causes of state problems. In all cases, host 1 is the host with the problem, and host 2 is the "other" host. Table 2 lists the causes that I see most often for each stuck state. This is not to say that I never see other causes. For example, I once saw a connection stuck in <B>SYN_RCVD</B> state because host 2 crashed after sending the connection request (cause 5). However, I cannot count the number of times that the routing table on host 1 was wrong (cause 2).<p>
<B>Diagnosing problems</b><p>Let's examine each of the probable causes as a means of diagnosing the network problem. Remember that host 1 is the local host (i.e., the host with the state problem), and host 2 is the remote host.<p>
<B>Host 1's Network Connection Is Down</b><p>This is usually simple to determine. If you can observe host 1, you can check its network interface card to see if the link light is on (I'm assuming 10 or 100BaseT connections). The link light indicates that a link pulse is being received from the device at the other end of the wire. The link pulse is received on the same pair of wires on which data is received and must be received before the network interface card will transmit any data. Since the link pulse/data is received on one pair of wires and transmitted on a different pair of wires, it's possible that host 1 is receiving a link pulse from its hub but the hub is not receiving a link pulse from the host. Hence, you also need to check the link light on the hub. And remember, just because both sides see a link pulse does not mean that the wire is capable of transmitting or receiving uncorrupted data.<p>
Provided both ends of the wire are showing a link light (or if you have to assume that they are because you cannot check), the next step is to try <B>ping</B>ing another host on the local network. (Note that if a host has multiple NICs on the same network or subnet, routing can get tricky. Typically, local traffic will go over 1 card and traffic to other networks and subnets will go over the other card. This means that testing a network connection by <B>ping</B>ing other hosts on the local network or subnet may not be testing the card that you are using to get to host 2.) This assumes that there is another host and that you know its IP address. If you don't know of any, check the routing table on host 1 and try <B>ping</B>ing one of the routers. If the <B>ping</B>s work, you know the network connection is OK, but if the <B>ping</B>s time out, you don't know if the problem is with host 1's connection or the other host's. The more hosts that you try and fail, the more likely the problem is with host 1.<p>
You can also look at the Ethernet statistics for the network interface card. Even if no one is trying to communicate with host 1, the interface should see broadcasts. The Ethernet statistics should show an increasing number of bytes and packets received. Of course, the rate of increase will depend on the size of the network and what types of hosts are connected to it. On UNIX systems, the <B>netstat -ni</B> command will show the number of packets received on the interface. On Windows NT and 98, <B>netstat -e</B> executed from a command prompt window will show that number. In Figure 2, the UNIX system received 66 packets (458827 - 458761) within a few seconds. Note also the incoming error count. If errors are going up, we may be connected to the network but the data in the frames may be corrupted. This could happen if the cables have been damaged or installed improperly.<p>
If you can, try looking at the port statistics on the hub. If host 1 sends a <B>ping</B>, does the hub see an increase in packets and bytes received?<p>
<B>No Route to Host 2</b><p>Without a route, host 1 will not know where to send the packet for forwarding to host 2. The command <B>netstat -nr</B> will display the routing table. On a UNIX system, there should be a row with either host 2's IP address or host 2's network or subnetwork address or the word default (see Figure 3). If host 2's IP address is shown, there should be an "H" in the flags portion of the row along with the flags "UG". If the "UG" flags do not appear or the "H" is missing from the host route, then the route is not defined correctly. On a Windows NT system, there will either be host 2's IP address or its network or subnetwork address or a destination address of 0.0.0.0, which stands for default. If the host 2's IP address is shown, the netmask will be 255.255.255.255.<p>
In Figure 3, the first blue line with the destination 192.168.13.151 represents a host route. It is followed by the default route, a network route to a remote network (10) and a route to the local network (192.168.33)<p>
Assuming there is a route, you need to make sure that the defined router (in the gateway column) is reachable. Try <B>ping</B>ing it; if you don't get a response, it's likely that the router is down or has some kind of problem.<p>
Even if host 1 and host 2 are on the same network or subnet, there should be an entry in the routing table. In this case, the gateway address is the address of host 1. Note that the flags for this entry are just U, for up.<p>
<B>Host 1 to Host 2 Link Down</b><p>This one is tricky; how do you distinguish between a network link between host 1 and 2 being down, host 2 or its network connection being down, a routing problem on host 2, or a link between host 2 and 1 being down? Ideally, you have access to host 2 via some other link or are in communication with someone who has access to host 2. Given that, you should first verify that host 2 is not down and that its network connection is OK and that it has a route to host 1. Once all that is confirmed, you can execute the command <B>netstat -s</B> and look at the ICMP statistics on host 2 before and after you send several <B>ping</B>s to it from host 1. (Note that routers and firewalls may be configured to filter ICMP echo packets (<B>ping</B>s). If <B>ping</B>s are failing and you think this may be a possibility, about all you can do is contact the firewall and router administrators to confirm the filtering and request that it be turned off.) If the counter for incoming echo packets is going up, you know that the <B>ping</B>s are reaching host 2 and that there is a problem with the echo reply being sent back. If the echo counter is not going up, you know that the problem is between host 1 and host 2. If you do not have access to host 2, there is not much you can do. It's possible that the <B>ping</B> command on host 1 will report a network or host unreachable error (Figure 5) or a time limit exceeded error. Both of these indicate a network link problem between host 1 and host 2. A <B>netstat -s</B> on the host 1 system may also show these error counters increasing even if the <B>ping</B> command does not report them (Figure 4).<p>
Note that on many UNIX systems a statistic for an ICMP message is only displayed if the counter is non-zero.<p>
The <B>traceroute</B> command can also be used to determine the route that the packet is taking. This will help identify when a wrong route is being used. Note that not all UNIX systems come with a <B>traceroute</B> command, and on Windows NT it's the <B>tracert</B> command, executed from a command prompt window (Figure 6).<p>
<B>Host 2 or Its Network Connection Down</b><p>The best way to eliminate these two possibilities is to speak to someone who has access to host 2 or to get access via some other link. You then know that host 2 is working, and you can run through the "host 1's network connection is down" tests to make sure that the network link is OK. If you are on the other side of a continent and it's 3 a.m. and there is no alternate link, you've got a problem. If you can get access to the hub to which host 2 is connected, you can query the hub to see if it's getting a link pulse and receiving any packets. Unfortunately, just because the hub is getting host 2's link pulse does not mean that host 2 is getting the hub's link pulse. Also just because you are getting a link pulse does not mean that the OS is up. Some network interface cards will send a link pulse as long as they have power - even if the OS is crashed. The best you can do is try to get a login session on another host on the same network or subnet as host 2. From there, you can try <B>ping</B>ing host 2. If the local <B>ping</B>s work while the remote <B>ping</B>s do not, routing is the most likely suspect. If the local <B>ping</B>s fail, then host 2 (or at least its network connection) is down.<p>
<B>No Route to Host 1</b><p>Again, the best approach is to gain access to host 2 via some other link and check the routing table on host 2. If that's not possible, then as in the previous case you need to gain access to a third host on the same network or subnet as host 2.<p>
<B>Host 2 to Host 1 Link Down</b><p>Without access to host 2, it is very difficult to diagnose this condition from host 1. Getting to a third host on host 2's subnet is not a guarantee that all the links between host 2 and host 1 are okay. Host 2 may be using a different router than host 3, so the network links could be different. If you have access to host 2, you can try the <B>ping</B> tests described in "some network link between host 1 and host 2 is down" and look at the echo statistics.<p>
<B>Server Too Busy</b><p>When host 2 receives a connection request, it will check its backlog queue, and if the queue is not full it will respond with a <B>SYN-ACK</B> packet. Once host 2 gets the <B>ACK</B> from host 1, it notifies the server application that a connection request has come in. The request stays on the queue until the server application accepts it. If there are many requests, the server may not be able to accept them fast enough and the backlog queue fills up. Once that happens, host 2 will ignore any further connection requests until there is space in the queue. The symptoms of this condition are: host 1 in a <B>SYN_SENT</B> state, host 2 has a number of connections in <B>SYN_RCVD</B> or <B>ESTABLISHED</B> states (they move to <B>ESTABLISHED</B> as soon as the <B>ACK</B> is received even if the server application has not accepted them yet), and new connection requests time out. This appears very similar to the next two causes. If you have access to the kernel structures on host 2 via some kind of debugging command, you may be able to check the actual backlog value. If not, you can look at system and server application performance. A heavily loaded system may not give the server application enough CPU cycles. A server application that uses all possible CPU cycles could be overloaded or stuck in a loop.<p>
<B>Host 2 Under Attack</b><p>A denial of service attack attempts to deny service to valid users of that service. These attacks make use of the connection request process described above by filling up the backlog queue with requests that cannot be completed. Basically, a connection request is sent to host 1, which appears to come from host 3. Typically, host 3 does not exist, but host 1 does not know that and will send a <B>SYN-ACK</B> packet to host 3. Since host 1 expects an ACK packet from host 3, it will eventually time out this half-open connection but until then it uses a slot in the backlog queue. Receiving lots of these types of requests at once will drown out the valid users. You can get some clue that this is happening by looking at the remote addresses of the connections in the <B>SYN_RCVD</B> state. Are they valid users of the server application? Even if they are, should they be sending a large number of requests? It's possible that the hacker who set up this attack is using a valid address but flooding host 1 with an unreasonably large number of requests (Figure 7).<p>
<B>Network Slow or Noisy</b><p>A noisy network connection or link corrupts or drops packets and requires retransmissions. The result is that connections stay in states that require acknowledgments longer than necessary. The <B>netstat -s</B> statistics include a count of retransmitted and duplicate received packets. The duplicate packets indicate that host 1's <B>ACK</B> packet to host 2 was lost, so host 2 retransmitted the packet. Keep in mind that the statistics are for all TCP connections, not just the connection you're interested in. If the network connection is causing the problem and the problem is occurring on the receiving end as well as the transmitting end, you should see input errors as well (Figure 2). If you have access to the hub to which the interface is connected, you can also check to see whether it's receiving errors.<p>
A slow network link also forces connections to stay in states longer than usual. The only good way to tell if this is happening is to ask the people in charge of the network. You can use the <B>traceroute</B> command (Figure 6) to determine the route and then contact the administrators of the routers. Besides giving you a list of routers, the <B>traceroute</B> command also gives you three times for each router. These times indicate the amount of time that the test packet took to get from host 1 to the router and back again. Three test packets are sent and each is timed separately. Treat these times gently. You'll notice that is quite possible for the round trip time to the 5th router to be faster than the round trip time to the 4th router. Many things affect the round trip times; it's even possible that the path of the test packet to or from router 5 did not pass through router 4.<p>
<B>A Firewall or Router Between the Two Hosts is Preventing Traffic</b><p>From a user's point of view, the difference between a firewall preventing traffic from flowing and a network link failure is the ease of getting it fixed. You can be pretty confident that a network link failure will be fixed. However, a firewall problem becomes an administrative and policy issue. For those familiar with the OSI layer model, this is sometimes called layer 8 - the administrative layer. Diagnosing that a firewall (instead of network link failure) is causing a problem can be difficult. It depends on what the firewall is configured to block. You can sometimes pinpoint the firewall by noting contradictions. For example, UDP traffic works, while TCP traffic does not. Or you can <B>ftp</B> to host 2 and get a connection, but <B>ftp</B>'s data transfer connection requests time out.<p>
<B>Connection is Flow Controlled</b><p>This situation is not very likely but easy to diagnose. It occurs when the transmit window for the connection between host 1 and host 2 is closed, and the local application on host 1 closes the connection. Since the transmit window is closed, host 1 cannot send a <B>FIN</B> packet. You can tell this has happened with the <B>netstat</B> display on the host 1. The connection state will be <B>FIN_WAIT_1</B>, but the send queue column will be non-zero and will remain unchanged. The state on host 2 remains in the <B>ESTABLISHED</B> state since the <B>FIN</B> packet is never sent. Some TCP stacks will remain in this state indefinitely, others will eventually time out the connection.<p>
How is the transmit window closed? Every TCP packet header includes a window size value. This value represents the number of bytes currently in the sender's receive buffer. When a packet is acknowledged, this window size is set to the current free space in the receive buffer. If host 2 runs out of space, it sets the window size to 0. When a packet is received by host 1 from host 2 with a 0 window size, host 1 closes the transmit window for that connection. Keep in mind that each connection has its own buffers and that what happens on one connection has no bearing on other connections, even when they are between the same hosts. Once the transmit window is closed, no more data can be sent until a packet is received from host 2 with a non-zero window size value. Some TCP stacks will not send any data until the window opens to a significant value (i.e., 512 or 1024 bytes). How could host 2 run out of buffer space? Typically the application on host 2 is either hung or in a tight loop, but whatever it's doing, it's not reading TCP data, so the data sent by host 1 is just accumulating in the host 2's buffers.<p>
In this instance, shutting down the application on host 1 will not unstick the connection. You must shut down the application on host 2, or somehow get it to start reading TCP data again so that the flow control can be turned off.<p>
<B>The Application on Host 2 Has Not Closed the Connection</b><p>From host 1's perspective, the connection is sitting in a <B>FIN_WAIT_2</B> state. Host 1 has closed the connection, sent its <B>FIN</B> packet to host 2 and gotten host 2's <B>ACK</B> packet for the <B>FIN</B>. Now host 1 is waiting for host 2 to send its <B>FIN</B> packet. Without checking host 2, you cannot be sure why host 1 hasn't gotten host 2's <B>FIN</B> packet. Its possible that host 2 has crashed or there has been a network failure, but more than likely host 2 has not closed its side of the connection. If you can check host 2 and the connection state is <B>CLOSE_WAIT</B>, then you can be sure that the application running on host 2 has not closed the connection. Either the application is busy or waiting or it just has a bug and is hung. For whatever reason, it has not responded to the indication sent up from the TCP stack saying that the remote side has closed its connection. Depending on what the application is doing and how it was written, it may be possible to tell it to close the connection. Or, you may just have to terminate the application. Terminating the application on host 2 should cause the TCP stack to shut down the connection, thereby sending a <B>FIN</B> packet back to host 1. (Note that a reset (RST) packet may be sent instead, but either way host 1 will close the connection when it receives the packet.)<p>
<B>The Application on Host 1 Has Not Closed <br>the Connection</b><p>This is the mirror image of the previous problem. Now host 1 is in the <B>CLOSE_WAIT</B> state, and host 2 will have a <B>FIN_WAIT_2</B> state or no state. As described in the Web companion piece, some TCP stacks will time out a connection in <B>FIN_WAIT_2</B> and release all its resources. As stated above, the application may be busy or waiting for some resource or just be hung. The hard part, is figuring out which application process is associated with the connection. Many times at least one of the ports associated with the connection is a well-known server port. If the local port is the server port then identification of the application is not a problem: it's the server application, and hopefully there is only one application running. If the remote port is the server port, then you must identify the client that was accessing the server. Good luck. How you do this or distinguish between multiple server applications will depend on your environment and your access and familiarity with kernel structures. As stated above, unless the application has a mechanism to allow you to tell it to close a connection (and it is responding to that mechanism), you will have to kill the application process to clear the <B>CLOSE_WAIT</B> condition.<p>
One final warning - beware of rapidly changing connections that appear stuck. Figure 8 shows the four iterations of <B>netstat</B> output. A casual look at the connection between 192.168.13.50 and 192.168.91.9 might lead you to think that the connection is stuck in <B>SYN_RCVD</B>. However, a close look shows that the port number is changing. There is nothing wrong here, just connections that are coming and going quickly.<p>
<B>Conclusions</b><p>Most people never pay any attention to the TCP connection state, until something goes wrong. Then they want to know what 1) what it means, 2) why it's in that state, and 3) what to do about it. This article has explored some of the typical TCP state problems, how to diagnose the causes, and how to resolve the problem. No set of canned answers can be applied in all cases. Armed with a better understanding of TCP states and the commands used to diagnose network problems, however, your network life should be more peaceful. 
<p>
<h1>About the Author</h1><p>
Noah Davids works in the Customer Assistance Center of Stratus Computer Inc. He specializes in the diagnosis and correction of LAN problems. "It's the wire" followed by "it's the router" covers most problems. The trick is finding which wire or router. He can be reached at Noah_Davids@stratus.com.


<! -- Begin Content ------ >
<br>&nbsp;<br>
</table></center></td>
<! -- End Content ------ >

</table><!/center>
<! -- End MASTER TABLE -- >

</body></html>