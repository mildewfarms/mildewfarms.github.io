<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 4.0//EN">


<HTML>
<HEAD>
<TITLE>v10, i02: Devouring Spam with Spamivore</TITLE>
<LINK REL=StyleSheet HREF="../../resource/css/sacdrom.css" TYPE="text/css" TITLE="CSS1">
</HEAD>

<body bgcolor="#ffffff" text="#000000" link="#000000" alink="#669999" vlink="#333366" topmargin=0 leftmargin=0>

<! -- Begin MASTER TABLE -- >
<!center>
<table width=98% cellpadding=0 cellspacing=0 border=0 bgcolor="#ffffff">
  <tr>

<table cellpadding=5 cellspacing=0 border=0>
	<tr>

		<td><span class="navbarLink">Article</span></td>
		<td><span class="navbarLink"><a href="a5_s1.htm">Sidebar</a></span></td>
		<td><a href="../../../../source/SA/2001/feb2001.tar"><b class=codeListing>feb2001.tar</b></a></td>

	</tr>
</table>


</tr>
<tr>
<! -- Begin Content ------ >
<td valign=top width=440 bgcolor="#ffffff">
<table width=100% cellpadding=15 cellspacing=0 border=0>
<tr>
          <td valign=top> 
            <! -- Insert Content ------ >
            <H1><img src="a5.gif" width="200" height="177" align="right">Devouring 
              Spam with Spamivore </h1>
            <p> <i>Charles V. Leonard</i> 
            <p> How many of us are bombarded each day with undesirable junk email, 
              commonly known as spam? How do you purge your email account of unsolicited 
              spam? This article presents an application called Spamivore. Spamivore 
              attacks spam at its source by disabling the harvesting agents that 
              steal email addresses. 
            <p> Spamivore consists of a 365-line Perl CGI (Common Gateway Interface) 
              and a 75-line supplemental HTML template used to execute the script. 
              The development platform was a Sun Solaris 2.x, System V, Release 
              4.0, but it has been ported to Windows 95/98/NT. The Web server 
              used in development of the script is Apache 1.3.9. The browsers 
              used for testing the scripts are Netscape 4.0 and Internet Explorer 
              5.0. 
            <p> <b>Spambots vs. Robots</b> 
            <p> There are many ways spam fills your mailbox. A common method involves 
              spammers stealing email addresses off your Web site by using a spambot. 
              A spambot is a specific form of a broader class of Internet applications 
              known as robots. Robots are software applications running unattended 
              on the Internet collecting and cataloging information about Web 
              sites. Most robots are legitimately helpful applications. A common 
              robot, for example, is a Web crawler. Search engines such as Yahoo!, 
              Altavista, Excite, Lycos, and Google use Web crawlers to update 
              their databases. Web crawlers put your Web site on the Internet 
              map. 
            <p> <b>Spam, Spam, Spam</b> 
            <p> Unlike Web crawlers, spambots are malicious entities; the email 
              addresses spambots collect are used to send mostly unwanted material. 
            <p> How do spammers obtain email addresses? According to Michael A. 
              Banks in "Beating the E-Mail Spammers", doing any of the 
              following will potentially place you on a list: 
            <p> 
            <p> 
            <ul>
              <li> Post on an online service's or Internet bulletin board 
              <li> Post in a Usenet newsgroup 
              <li> Spend time in chat rooms on an online service 
              <li> Have a listing in an online service's member directory 
            </ul>
            <p> Perhaps a few spammers collect email addresses manually by going 
              from site to site, but more spammers automate this task by using 
              spambots. Spamivore defends Web sites against these uninvited, intruding 
              spambots. (See the sidebar for more on spambots). 
            <p> <b>Spamivore Beginnings</b> 
            <p> I became more than slightly annoyed about all the spam in the 
              world (especially in my POP3 account), so I decided to research 
              what could be done to stop it. One of the applications that kept 
              being referenced at almost every anti-spam site I visited was Webpoison 
              (or Wpoison). I read about Webpoison, and I thought the concept 
              was great. 
            <p> I decided to create my own Spambot trap when I learned I would 
              need to modify the <b>http.conf</b> file if I wanted to disguise 
              the CGI references as regular links. Because I manage two sites 
              located on Web hosting services, where I do not have the necessary 
              administration rights to make these modifications), I was left to 
              contemplate an alternative plan. 
            <p> I came up with the idea of using Server Side Includes (SSI) as 
              an alternative way to cloak the spambot trap, which would not require 
              httpd administration rights. I chose the name Spamivore after viewing 
              a local news segment about Carnivore, the FBI's own potentially 
              intrusive application. (Ironically, Carnivore, like spambots, has 
              an interest in email.) 
            <p> <b>Spamivore Design Overview</b> 
            <p> The basic design for Spamivore is as follows: 
            <p> 
            <p> 1. Place a hidden link in the main HTML page that contains a link 
              to critical data (email addresses) that I do not want spambots to 
              access. 
            <p> 2. The hidden link will be not be seen by anyone except uninvited 
              robots. 
            <p> 3. Following the hidden link presents a page containing a Server 
              Side Include. 
            <p> 4. The SSI references a CGI script that randomly generates a page 
              full of email addresses, creates another SSI Web page, and creates 
              a corresponding link to this Web page for the spambot to follow. 
            <p> 5. The newly created SSI Web page contains another reference to 
              the CGI script. This CGI reference is never actually seen by the 
              spambot because the http daemon has already replaced it with the 
              content generated by the CGI before it reaches the spambot. 
            <p> 6. The CGI script contains a mechanism to maintain the physical 
              <b>.SHTML</b> (SSI) documents that are created. 
            <p> 7. After the spambot follows the third dynamic link, the CGI script 
              deletes from the system all the <b>.shtml</b> documents created 
              by the spambot (through our CGI script), except for the current 
              one it is viewing and the next one the spambot wants to link to. 
            <p> 8. At this point, there is the possibility that the spambot is 
              trapped and unable to go backwards to intrude on other areas of 
              the Web site. If the Spambot's history cacheing is not very 
              sophisticated (i.e., the Web page must exist on the Web site), the 
              Spambot will not be ble to go back to the previous page because 
              that page no longer exists (as it was deleted in step 7). 
            <p> 9. To protect against good robots from falling into our trap, 
              add an entry to <b>robots.txt</b> that informs the robot to stay 
              away from these areas that have planted traps. 
            <p> 10. As an added safety measure for normal users who accidentally 
              fall into our trap, add a second link below the <b>.shtml</b> link 
              that allows the user to go back to the main homepage 
            <p> 
            <b>Code Development </b> 
            <p><b> The Main Home Page </b>
            <p> First, create the main HTML page for the Web site to be protected 
              against spambots. Since I use SSI in this page, the file will end 
              with an <b>.shtml</b> extension (all SSI pages end in this extension). 
              The example site is called "Contact Busters of America". 
              As its name implies, Contact Busters is a fictitious group dedicated 
              to the abolition of intrusive interruptions in life such as junk 
              email, junk mail, telephone solicitation, and other spammish enterprises. 
            <p> In Listing 1 (the <b>index.shtml</b> for our fictitious Web site), 
              I use SSI to display today's date with the statement <b>&lt;!--#echo 
              var="DATE_LOCAL" --&gt;</b>. If SSI is enabled, the server replaces 
              this statement with today's date before delivering the page 
              to the client Web browser. 
            <p> The anchor <b>&lt;a href="sa/saelist1.shtml"&gt;</b> is the link 
              that begins the spambot's journey through the spam trap. Note 
              the <b>&lt;FONT&gt;</b>,<b>&lt;/FONT&gt;</b> tags around the word 
              "Contacts". This statement hides the link from visual 
              users. Since the background is black for this area, changing the 
              link font to black will make this link invisible to normal users, 
              but not to spambots. The <b>COLOR="#000000"</b> attribute changes 
              the normal link color to black regardless of whether the user has 
              visited this page before (at least for Netscape Version 4.0 and 
              Microsoft Internet Explorer 5.0). 
            <p> Although a spambot normally attacks the homepage of a Web site, 
              it is not necessarily the first or only page the spambot visits. 
              Any page containing email addresses should have a hidden link as 
              the first link of the page. Spambots, as most robots, will simply 
              follow the first link they come to unless otherwise restricted. 
              (I will discuss this later in the <b>robots.txt</b> section). 
            <p> <b>The Initial Spambot Trap Page</b> 
            <p> As I previously discussed, the Contact Busters main page has a 
              hidden link to <b>sa/saelist1.shtml</b>. The page <b>sa/saelist1.shtml</b> 
              introduces the spambot to Spamivore. The HTML code for <b>saelist1.shtml</b> 
              is described in Listing 2. The statement <b>&lt;!--#exec cgi="/cgi-bin/Contacts.cgi" 
              --&gt;</b> instructs the Web server to execute the script <b>Contacts.cgi</b> 
              and replace the statement with any output generated by <b>Contacts.cgi</b>. 
            <p> <b>Contacts.cgi</b> 
            <p> When the initial <b>saelist1.shtml</b> is visited, <b>Contacts.cgi</b> 
              executes and displays a page full of email addresses. This is typical 
              of spambot traps, and Spamivore is not any different. This, however, 
              is not all <b>Contacts.cgi</b> does. Because I want to hide that 
              <b>Contacts.cgi</b> is a CGI script, I create physical-looking links 
              to any new page that is dynamically generated; this includes creating 
              links with the actual file extension <b>.shtml</b>. 
            <p> To do this, physical <b>.shtml</b> Web pages must be created, 
              stored, and maintained on the Web site. When looking at the initial 
              spambot Trap page, <b>saelist1.shtml</b>, it might be overlooked 
              that <b>Contacts.cgi</b> script does not dynamically create the 
              entire content of the Web page you are viewing. Instead, it is using 
              a host physical Web page that already exists on the server and only 
              generates content for a partial portion of that existing Web page. 
            <p> Maintaining physical Web pages created dynamically by a CGI script 
              presents a whole new problem. After making the choice to create 
              these pages, when do you delete them? This was one of the primary 
              issues when developing the script. 
            <p> 
            <b>Contacts.cgi Code Review </b>
            <p><b>The Main Function </b>
            <p><b> Contacts.cgi</b>, Listing 3, informs the Web server of what 
              type of content to generate. The statement <b>print "Content-type: 
              text/html\n\n";</b> tells the server to generate regular text or 
              HTML content. The next two lines are debug statements that allow 
              examination of the argument passed to the script and the IP address 
              of the remote client. The function <b>clDebug()</b> prints whatever 
              is passed to it whenever the global debug variable <b>$bDebug</b> 
              is set. 
            <p> All debug information is enclosed in HTML comments so the client 
              application ignores them. Typically, most graphical browsers will 
              not display comments, unless the "Page Source" option 
              is selected. Because spambots have access to these comments, turn 
              them off when Spamivore is installed on your site. 
            <p> The next section of code, beginning with <b>if (@ARGV)</b>, checks 
              whether an argument has been passed to the script. A defined argument 
              sets the Run Count. The Run Count is later used in the program to 
              control document purging. Document purging involves purging of <b>.shtml</b> 
              files previously generated and no longer in use by the spambot. 
            <p> After determining the Run Count, call function <b>clGenMailAddrs()</b>. 
              As the name implies, it generates the random email addresses returned 
              to the spambot. After generating a page full of email addresses, 
              call the <b>clCrNextTrapPage()</b> function. 
            <p> The <b>clCrNextTrapPage()</b> function creates the next <b>.shtml</b> 
              file I want the spambot to link to. After the new <b>.shtml</b> 
              is created and saved to a public area on the Web site, create a 
              link to the new <b>.shtml</b> page by calling the next two print 
              statements (the paragraph tag of line 29, and the anchor tag of 
              line 30). 
            <p> Finally, call the <b>clAddDelFile()</b> function. This function 
              adds the new file I have just created to the Remove List. The list 
              is a file stored on the Web site to keep track of the random <b>.shtml</b> 
              files created and to be removed at a later time. The function <b>clAddDelFile()</b> 
              also determines document removal. 
            <p> <b>Function clGenMailAddrs</b> 
            <p> This function is responsible for generating the random banquet 
              of email addresses for the spambot. We have a finite set of nine 
              arbitrary email account name prefixes and a set of eight fictitious 
              email provider domain names. The nine email account name prefixes 
              are stored in array <b>@elist1</b>, and the eight fictitious domain 
              names are stored in array <b>@elist2</b>. Both are global arrays 
              defined at the beginning of the program. 
            <p> The function first seeds the random number generator. Because 
              no argument is passed to random number generator function <b>srand</b>, 
              Perl automatically uses the current system time as the seed. 
            <p> Next, enter the <b>Until</b> loop that generates 50 randomly created 
              email addresses. Fifty addresses were chosen because they fit in 
              a browser display, and a second link (below the email listings) 
              can be viewed by a typical user without scrolling. 
            <p> This second link that I want to account for will, of course, allow 
              a viewer to escape from our spambot trap. It also is a reasonable 
              amount of email addresses to contain on a page without tipping off 
              the spambot that the page is a set-up. However, I have no hard statistics 
              on this claim. 
            <p> The "Until" loop is the basis of our random generator. 
              Each iteration of the loop will creates a new random email address 
              and corresponding "mailto" HTML anchor. The first line 
              within the loop is a counter to keep track of how many phony email 
              addresses are being created. The next line creates a random number 
              with a limit of five digits. The variable <b>$iNumExt</b> is the 
              second part of the name used to create the email account. I will 
              also use <b>$iNumExt</b> later in function <b>clCreateTrapPage</b> 
              as the second part of the <b>.shtml</b> file name. 
            <p> The statement <b>$iName=((rand) * 10) % 9</b> creates the index 
              value for the first part of our email account name. The statement 
              <b>$iHost=((rand) * 10) % 8</b> creates the index value to the name 
              used for the phony domain name of our email account. The <b>print</b> 
              statement that follows the prior three random value assignments 
              creates the actual <b>mailto:</b> account name. 
            <p> The variable <b>$iName</b> is used to index the array <b>@elist1</b> 
              (the first part of our email account name), and <b>$iHost</b> is 
              used to index the array <b>@elist2</b> (the name of our phony account's 
              domain name), and <b>$iNumExt</b> is used as the second part of 
              our email account's name. For example, if <b>$iNumExt</b> were 
              1215, and <b>$iName</b> were 2, and <b>$iHost</b> were 7, the generated 
              line of HTML code by the print statement would be: 
            <p> 
            <pre>
&lt;a href="mailto:sandymims1215@ibm0.com"&gt;sandymims1215@ibm0.com&lt;/a&gt;</pre>
            <p> Note the print statements have backslashes preceding each reference 
              to the "<b>@</b>" symbol. In Perl, the "<b>@</b>" 
              symbol is a reserved word used to reference and define array variables. 
              The backslash is used to escape the symbol, so it is a literal reference 
              in string values. 
            <p> Listings 4 and 5 reference the code used to define the global 
              email arrays and the <b>clGenMailAddrs</b> function. 
            <p> <b>Function clCrNextTrapPage</b> 
            <p> The <b>clCrNextTrapPage()</b> function creates the next <b>.shtml</b> 
              page to which the spambot will link. The function creates a page 
              similar to the first initial <b>.shtml</b> page (<b>saelist1.shtml</b>). 
              Recall that <b>saelist1.shtml</b> is the page to which the spambot 
              first links from the hidden link in <b>index.shtml</b>. Listing 
              6 references the code used to define <b>clCrNextTrapPage</b>. 
            <p> The first statement, <b>$sHtmlName="$sEmRootName$iNumExt$sEmExt"</b> 
              creates the name for the new <b>.shtml</b> page. The global variables 
              (<b>$sEmRootName</b>, <b>$iNumExt</b>, and <b>$sEmExt</b>) are defined 
              at the top of the <b>Contacts.cgi</b> program's <b>GLOBAL VARIABLES</b> 
              section. 
            <p> The next line assigns the variable <b>$sHtmlFullName</b> with 
              the variable <b>$sWrkHtDocs</b>, a slash, and the variable <b>$sHtmlName</b>. 
              The variable <b>$sHtmlFullName</b> defines the full path name relative 
              to the CGI directory of the <b>.shtml</b> being created. Variable 
              <b>$sWrkHtDocs</b> defines the directory where the modifiable HTML 
              documents are stored and accessed by the uninvited spambot. 
            <p> The example source code directory <b>../www/sa</b> is where I 
              store and view the HTML documents. The variable <b>$sEmRootName</b> 
              contains the first part of the atomic file name being created. In 
              the example, <b>saelist1_</b> will be the name of the first part 
              of the document. The variable <b>$sEmRootName</b> is configurable 
              and can be assigned another value if desired. 
            <p> The second variable of the <b>$sHtmlName</b> assignment is <b>$iNumExt</b>, 
              first seen in function <b>clGenMailAddrs</b>. <b>$iNumExt</b> contains 
              the value of the last random value generated for the second part 
              of the email account name. I choose to use the last email address 
              number simply to avoid another call to the function "<b>rand</b>". 
              The last variable in the assignment is <b>$sEmExt</b>. This is a 
              global variable, set to <b>.shtml</b>, assigned at the top of the 
              program. 
            <p> The directory where pages are created, must have read, write, 
              and execute privileges set for the world. Otherwise, the spambot 
              will not be able to create the page. If this happens, the program 
              dies. 
            <p> If the <b>open</b> statement fails, call the function <b>die</b> 
              and the program terminates, leaving the spambot to digest a strange 
              message but ending any further random email generation. If the <b>open</b> 
              statement succeeds, allow generation of the content for the new 
              file and save the information to disk. 
            <p> Another item of interest concerns the <b>#include</b> <b>virtual</b> 
              server side include reference. This reference executes the script 
              <b>Contacts.cgi</b> just as the <b>#exec cgi</b> SSI reference did 
              in the initial <b>saelist1.shtml</b> page. The difference is the 
              <b>#include virtual</b> allows passing arguments to the executing 
              script where the <b>#exec cgi</b> reference does not allow this. 
              Arguments are passed using the standard CGI method for passing arguments 
              (e.g., <b>ScriptName?arg1+arg2+arg3</b>, etc.). In this instance, 
              only one parameter, the <b>$nRunCount</b> is passed to the Spamivore 
              CGI. 
            <p> <b>Creating the Next Link</b> 
            <p> The following lines: 
            <p> 
            <pre>
print "&lt;P&gt;";
print "&lt;a href=\"$sHtmlName\"&gt;Rest for the Weary!&lt;/a&gt;\n";
</pre>
            <p> create the link to the new page just stored to disk. 
            <p> The variable assigned in <b>clCrNextTrapPage</b>, <b>$sHtmlName</b>, 
              is again used to create the name of the link. Since the link is 
              relative to the directory from which the browser is reading, use 
              <b>$sHtmlName</b> instead of <b>$sHtmlFullName</b>. This portion 
              of the code dynamically displays to the spambot as the current page 
              it is viewing. 
            <p> <b>Functions clAddDelFile and clRmFiles</b> 
            <p> Now that the next page is created to which the spambot can link, 
              the question arises, "When do I delete it?" Because of 
              the slightly awkward way in which physical pages are generated for 
              the spambot to devour (rather than relying exclusively on generating 
              pages "on the fly", as is normally done in CGI programs), 
              I have introduced a new problem of document management. <b>clAddDelFile</b> 
              is a function that attempts to address this issue. 
            <p> Here are three issues of concern: 
            <p> 
            <p> 
            <ul>
              <li> I do not want to let the spambot generate pages that will eventually 
                fill up the disk. 
              <li> I do not want to delete the page the spambot is currently viewing. 
              <li> I do not want to delete the next page the spambot will link 
                to. 
            </ul>
            <p> The approach I chose was to create a disk file, named <b>rmlist.txt</b> 
              (the "Remove List"), listing the <b>.shtml</b> pages the 
              spambot created. Later, when I'm sure the spambot is finished 
              accessing the files, the program removes them. At this point, I 
              still haven't addressed when to perform the actual delete. 
            <p> There were two approaches I could have used to attack this problem: 
            <p> 
            <p> 
            <ul>
              <li> Delete the documents using a second process such as a background 
                process 
              <li> Delete the pages while the spambot is still in the trap. 
            </ul>
            <p> I opted to devise a way to delete the pages while the spambot 
              is still in the trap. This is where I make use of the "Run 
              Count." The "Run Count" tells us when it is safe 
              to start the document purge process. 
            <p> The first time the spambot enters the trap, the run count, <b>$nRunCount</b>, 
              is zero. The first time the CGI executes, no arguments exist, and 
              the run count is not incremented. The next time the script executes, 
              it is done by linking to the page created in which the <b>$nRunCount</b> 
              is passed within the SSI reference. In this instance of the script, 
              detect the argument and increment the Run Count by 1. Now our run 
              count is 1. The third time the script executes, the Run Count is 
              2. 
            <p> When the run count is two, it's probably safe to purge the 
              documents the spambot created. By this time, I have already created 
              one file ready to be deleted. However, we must not delete the document 
              the spambot is currently viewing or the next one it is about to 
              link to. 
            <p> The <b>clAddDelFile</b> and <b>clRmFiles</b> functions implement 
              the above requirements just described. The code for <b>clAddDelFile</b> 
              (see below) assigns the <b>$HtmlName</b> to the <b>$sDelFile</b> 
              variable. Next, create the delete path variable <b>$sDelPath</b> 
              composed of <b>$sDelHtPath</b> and <b>$HtmlName</b>. 
            <p> The variable <b>$sDelHtPath</b> is the same value as the value 
              for the variable <b>$sWrkHtDocs</b> except it contains a slash at 
              the end of its definition. Because multiple platforms are maintained, 
              <b>$sDelHtPath</b> is needed to manipulate the directory delimiters 
              based on what platform Spamivore is installed on. (e.g., UNIX uses 
              "/", while Windows/NT uses "\"). This could 
              have been automated by using the Perl languages' <b>s///</b> 
              function. 
            <p> After creating the <b>$sDelPath</b>, check the Run Count. If the 

              count is greater than 2, call the <b>clRmFiles</b> function to start 
              the purging process. Otherwise, only add the file to the Remove 
              List file. The global variable <b>$sRmList</b> is used to define 
              the file name for the Remove List. Whether or not the <b>clRmFiles()</b> 
              function is called, always add the file to the Remove List. 
            <p> The calls to <b>clLockFile</b> and <b>clUnlockFile</b> prevent 
              contention problems if more than one spambot simultaneously accesses 
              the script. I only want one spambot at a time accessing the file 
              operations that are taking place. The functions were written with 
              portability in mind, thus, the references to WIN32. The lock routines 
              are very crude, using a disk file to implement the locking mechanism. 
              Lock files are not as reliable as a semaphore in memory but they 
              suffice. See Listing 7 for the source code for <b>clAddDelFile</b> 
              function. 
            <p> When the <b>clRmFiles</b> function invokes, the function assigns 
              the <b>$nRmCount</b> to zero, opens the Remove List file, and begins 
              deleting the files. However, I do not want to delete the last file 
              in the list because this is the one the spambot is currently viewing. 
              It may help you to visualize why I don't want to delete the 
              last file by tracing through our algorithm. If you do, it will become 
              clear that by the time I enter the <b>clRmFiles</b> function, the 
              last file added to this list (in the prior run of <b>Contacts.cgi</b>) 
              should be the one the spambot is viewing. Also, notice the link 
              file just created has not yet been added to the Remove List. Thus, 
              not removing the last file allows the page the spambot is viewing 
              and the next page that was just created to remain on disk (while 
              all others are deleted). 
            <p> The <b>foreach</b> loop implements the ideas of the previous two 
              paragraphs. By using the <b>$nRmCount</b> (the Remove Count) variable, 
              I keep track of the iterations. For the first iteration, I do not 
              delete the first file read. I delete this file in the second iteration. 
              When in the last iteration of the loop, the previous file read in 
              the prior iteration is removed, but the last file read is left to 
              remain on disk. The function <b>unlink</b> is used to do the actual 
              file deletion. See Listing 8 for the source code for <b>clRmFiles</b> 
              function. 
            <p> After the <b>foreach</b> loop completes, check whether the <b>$bRmAll</b> 
              flag has been set. If it has, delete the last file. I have left 
              this in as hook for future use where I may want to delete all files 
              when the <b>$nRunCount</b> variable is 0. This is a condition (assuming 
              that only one spambot is running the script at a time) where it 
              will be safe to purge the files listed in our Remove List (including 
              the last file). 
            <p> If the <b>$bRmAll</b> flag is not set, write the last file not 
              deleted to a new temporary Remove List. Before leaving the <b>clRmFiles</b> 
              function, delete the old Remove list and rename the temporary file 
              as the new Remove List. When <b>clRmFiles</b> exits, return to <b>clAddDelFile</b>, 
              where the new link file that was created in <b>clCreateNextTrap</b> 
              page will be added to the new Remove list. 
            <p> The new Remove List now contains two files -- the file not 
              deleted and the file for the new link just created. In addition 
              to updating the new Remove List, I also have a feature that will 
              log the page created for the spambot along with its remote IP address. 
              If logging is turned on, write this information to the file named 
              by the variable <b>$sLogFile</b> (which in the example is set to 
              <b>contacts.log</b>). The logging feature is useful for keeping 
              track of what (potential) spambots have visited the trap. 
            <p> 
            <b>Installing and Running Spamivore </b>
            <p><b>Configuration Settings </b>
            <p> The primary configuration variables most likely to modify are: 
            <p> 
            <ul>
              <li> <b> $sWrkHtDocs</b> -- Used to specify the public directory 
                from where the <b>.shtml</b> pages will be created and deleted. 
                In the example, this is set to <b>../www/sa</b> directory 
              <li> <b> $sDelHtPath</b> -- This will be the same value as <b>$sWrkHtDocs</b> 
                on UNIX systems with an additional "/" added to the 
                end of the value. Because I maintain Web sites on more than one 
                platform, I need to specify a different path structure when deleting 
                files. 
              <li> <b> $sLogDir</b> -- This is used to specify the public 
                logging directory. This directory will be used to house the Remove 
                List and the contacts log. In the example, this is set this to 
                <b>../public</b>.
            </ul>
            <p> <b>Optional Configuration Variables</b> 
            <p> 
            <ul>
              <li> <b> $sRmlist</b> -- Used to define the name of the remove 
                list. In the example it is set to <b>$sLogDir/rmlist.txt</b>. 
              <li> <b> $sNewRmList</b> -- Used to define the name of the temporary 
                Remove List file created in <b>clRmFiles</b>. 
              <li> <b> $sLogFile</b> -- Used to define the name of the log 
                file. In the example, this is set to <b>$sLogDir/contacts.log</b>. 
              <li> <b> $sRmLockFile</b> -- Used to define the name of the 
                lock file. 
              <li> <b> $nLockSleep</b> -- Used to tell the lock function how 
                long to sleep (in seconds) before checking if the file resource 
                is available.
            </ul>
            <p> <b>Installation Instructions</b> 
            <p> 
            <ul>
              <li> Install the main Web page (<b>index.shtml</b>) in the target 
                directory to be protected from spambots. In the example, I put 
                this in the root directory. Note: In the source delivery, the 
                file is named <b>samain.shtml</b>. This can be renamed as <b>index.shtml</b> 
                and installed as described above. 
              <li> Include a <b>robots.txt</b> file in the root directory of the 
                Web site. See the section <b>robots.txt</b> below for more information 
                about what this file is and how it should be used. 
              <li> Create the public logging directory with read, write, and execute 
                access for the world. The logging directory is where the <b>RmList.txt</b> 
                and <b>contacts.log</b> files reside. In the example, this in 
                the "public" directory. 
              <li> Create the directory where the Spamivore <b>.shtml</b> files 
                will be created and destroyed. Again, this directory must have 
                world read and write privileges. In the example, this was the 
                <b>www/sa</b> directory. If the Apache Web server is used, this 
                directory will most likely be <b>htdocs/sa</b>. 
              <li> Install the initial <b>saelist1.shtml</b> in the Spamivore 
                <b>.shtml</b> directory. 
              <li> Install <b>Contacts.cgi</b> in the <b>cgi-bin</b> directory.
            </ul>
            <p> 
            <p> To run Spamivore: 
            <p> 
            <p> 
            <ul>
              <li> Point your browser at the <b>index.shtml</b> just installed. 
              <li> Find the hidden link within <b>index.shtml</b> (the link to 
                <b>saelist1.shtml</b>). 
              <li> Click on the hidden link. You should see the same email addresses 
                and links the spambot sees.
            </ul>
            <p> <b>Robots.txt</b> 
            <p> The <b>robots.txt</b> file informs robots of what files and directories 
              to avoid on your site. Place the file in the Root Document directory. 
              Include in this file references to any file or even whole directories 
              containing critical email address listings. In my <b>robots.txt</b> 
              file, for example, I include the pages that contain email addresses 
              as well as the directory where the Spamivore SSI resides (in the 
              directory "sa"). 
            <p> Good robots read the <b>robots.txt</b> file and avoid areas with 
              references to the names specified, thus, saving them from the trap. 
              Bad robots are less likely to observe <b>robots.txt</b>. However, 
              documentation at the Wpoison Web site indicates that even spambots 
              are honoring this rule now. This means a chance exists that just 
              putting an entry in <b>robots.txt</b> is enough to keep spambots 
              from sniffing through your email addresses. A backup precaution 
              of including a spambot trap will make your site fully protected. 
            <p> Below is an example <b>robots.txt</b> file: 
            <p> 
            <pre>
#
#  FILE NAME: robots.txt
#
User-agent: *
Disallow: /sa/
Disallow: /mymaillist.html</pre>
            <p> For more information on <b>robots.txt</b>, see:
            <p> 
            <pre>
http://info.webcrawler.com/mak/projects/robots/exclusion.html</pre>
            <b>Conclusion </b>
<p> I have presented one version of a spambot trap to help in the 
              fight against spam. The script may interest Web masters who maintain 
              Web sites on remote hosting services where they do not have direct 
              access to the Web server configuration files. It may also interest 
              Web masters who do not want to maintain non-standard "cgi-bin" 
              directories (which would be required to hide Wpoison type CGI scripts).
            <p> Although I have demonstrated that Server Side Includes do offer 
              an alternative way to hide CGI execution, my solution presents some 
              challenging hurdles. Document Management and concurrent processing 
              become major concerns. The Spamivore algorithm works best when only 
              one spambot at a time is running on the installed Web site.
            <p> Spamivore assumes that the spambot will execute the script at 
              least three times before document management takes place. Both these 
              areas can be improved. For example, add code to the script that 
              deletes all documents the first time the script runs.
            <p> Spamivore will not end spam. If spambots never execute the script 
              because they honor the <b>robots.txt</b> standard, the script will 
              not make much impact. However, along with other anti-spam mechanisms, 
              Spamivore is one more weapon to add to the arsenal in the never-ending 
              war against spam.
            <p> <b>References</b>
            <p> 1. <b> http://w3.one.net/~banks/spam.htm</b> -- "Beating 
              the E-Mail Spammers" by Michael A. Banks
            <p> 2. <b> http://www.e-scrub.com/wpoison</b>/ -- Wpoison home 
              site.
            <p> 3. <b> http://www.turnstep.com/Spambot/lure.html</b> -- "Spambot 
              Beware" by Greg Sabino Mullane.
            <p> 4. <b>http://info.webcrawler.com/mak/projects/robots/ \<br>
              exclusion.html</b> -- Robots exclusion page.
            <p> 5. <b> http://hoohoo.ncsa.uiuc.edu/docs/tutorials/includes.html</b> 
              -- NCSA httpd Server Side Includes (SSI) Page. 
            <p> <i>Charles Leonard is a Software Engineer for eLabor.com (formally, 
              jeTECH DATA SYSTEMS), where he has worked for the past six years. 
              Prior to eLabor.com, he worked five years as a Software Engineer 
              on the Deep Space Network at Jet Propulsion Laboratory in Pasadena, 
              CA. As a hobby, he also maintains Web sites for friends and family. 
              He can be reached at: </i><b><i>cvl1989@hotmail.com</i></b><i>.</i> 
          </table></table><br>&nbsp;<br>

<! -- End Content ------ >

<!/center>
<! -- End MASTER TABLE -- >

</body>



<! -- Begin Content ------ >
</html>
