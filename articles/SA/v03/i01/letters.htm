<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 4.0//EN">


<HTML>
<HEAD>
<TITLE>v03, i01:  New Messages</TITLE>
<LINK REL=StyleSheet HREF="../../resource/css/sacdrom.css" TYPE="text/css" TITLE="CSS1">
</HEAD>

<body bgcolor="#ffffff" text="#000000" link="#990000" alink="#669999" vlink="#333366" topmargin=0 leftmargin=0>

<! -- Begin MASTER TABLE -- >
<!center><table width=600 cellpadding=0 cellspacing=0 border=0 bgcolor="#ffffff">

<tr>

<table cellpadding=5 cellspacing=0 border=0>
	<tr>

		<td><span class=navbarLink>Article</span></td>
		<td><a href="../../../../source/SA/1994/jan94.tar"><b class=codeListing>jan94.tar</b></a></td>

	</tr>
</table>


</tr>
<tr>
<! -- Begin Content ------ >
<td valign=top width=440 bgcolor="#ffffff">
<table width=100% cellpadding=15 cellspacing=0 border=0>
<tr><td valign=top>




<H1>New Messages</H1><p>
<P>
Dear Mr. Ward,<br>

A statement was made in the Question and Answer section
of your November/December 
issue which I believe is unfounded.<P>

On page 28, Bjorn Satdeva says, regarding Job Accounting
software 
packages, &quot;the few commercial packages I have come
across have 
been buggy and cumbersome to deal with.&quot;<P>

I think your readers should know that our resource accounting
package 
is neither of those things. We have many satisfied customers
using 
UNISOL JobAcct. Furthermore, many customers call us
because 
they have tried to write their own system accounting
packages and 
have run into difficulties. The biggest complaint we
hear about other 
commercial packages concerns performance, which is not
a problem with 
UNISOL JobAcct. <P>

Sincerely,<br>

Laurie Craig<br>
Director of Marketing<br>
UniSolutions Associates<br>
Redondo Beach, CA 90278<P>

<I>Bjorn's comments reflected his own experience, but should

not be read to imply that all commercial packages are
subject to the 
same criticism. Thanks for writing to us.</I><P>



Editor,<br>

I saw the letter from Guido Beijerwellen in your November/December

1993 issue in which he complains about the availability
of the sysadmin 
files via your telephone number.<P>

You suggest CompuServe, but did you know that uunet
keeps copies too? 
ftp to ftp.uu.net, go to the directory /published/sysadmin,
and there 
you will find the files for 1992 and 1993 in the directories
1992 
and 1993.<P>

Other sites where the files are stored can be found
using archie. 
I found the following places:<br>

ftp.cs.umn.edu:/pub/doc/published/sysadmin<P>

ftp.uu.net:/published/sysadmin<P>

ftp.ccu.edu.tw:/pub1/document/published/sysadmin<P>

nctuccca.edu.tw:/documents/published/sysadmin<P>

unix.hensa.ac.uk:/pub/uunet/published/sysadmin<P>

src.doc.ic.ac.uk:/media/literary/published/sysadmin<P>

For those close to the Netherlands, we keep a mirror

of some of the published documents on our archive server
ftp.nl.net, 
in the directory /pub/published. This server can also
be reached via 
our mail server: send mail to mail-server@nl.net and
you will get 
help from the mailserver.<P>

Since this would be the easiest way fo Mr. Beijerwellen
to obtain 
the files, I have sent him a copy of this e-mail.<P>

Jan Christiaan van Winkel<br>
archive maintainer jc@inter.nl.net<br>
Alternative e-mail addresses: jc@oreo.atcmp.nl and jc@atcmp.nl<P>

<I>Many thanks to you for this useful information. Readers

unfamiliar with &quot;archie&quot; can look to Chris
Bush's article, 
&quot;Internet Online Services: archie,&quot; beginning
on p. 37 of 
this issue, for an explanation.</I><P>



Dear SysAdm:<br>

Nice magazine, I enjoy reading it.<P>

I have a question though:<P>

Does anybody at SysAdm know where I may obtain information
about the 
CM University Mach project and also about the GNU or
Free Software 
Foundation Hurd project? I have very little info on
either, all of 
it coming from my GNU magazine.<P>

I appreciate your time and effort.<P>

Thank you.<br>

Ennis McCaffrey<br>
emccaff@pica.army.mil<P>

<I>We're not able to provide this information, but feel

sure 
that our readers can. If you can help Mr. McCaffrey
out, e-mail him 
at the address above.</I><P>



Editor:<br>

A curious reader not to long ago sent me a question
regarding UUCP 
and alarm messages. Before I reply to this forum with
a general response, 
I am asking that individual to re-send his message to
me. You can 
reach me via e-mail at chare@unilabs.org, or chare@choreo.ca.<P>

Thanks.<br>

Chris Hare<br>
chare@unilabs.org<P>

<I>If you had this question for Chris, please contact him
again.</I><P>



Sys Admin Editor,<br>

One of the great things about system administration
is that there 
can be so many ways to solve a problem! In your checkcron
script from 
Nov/Dec 1993, you have the following line:<P>
<PRE>
ps -fu root | sed '/grep/d' | grep cron</pre><p>
<p>
For those who are not as familiar with using sed, the

following line should accomplish the same thing:<P>
<PRE>
ps -fu root | grep cron | grep -v grep</pre><p>
<p>
Here I use the -v option of grep to remove any lines

containing grep. Again, due to the way the pipeline
works, the second 
grep not only filters out the search for cron, but itself
as well!<P>

Jason Vogel<br>
System Administrator<br>
Sunbelt Business Computers<br>
jason@sunbelt.com<P>

<I>Thanks for the elaboration -- the greater thing about

system administration is system administrators' willingness
to share 
such tips with each other!</I><P>



From: Chris Linstruth &lt;cjl@aop.com&gt;<br>
Subject: New Messages November/December 1993<br>
To: saletter@rdpub.com<P>

A reader queried about VMS-like virtual terminals in
this issue [Nov/Dec 
1993]. I think the freeware 'screen' package from the
FSF should fill 
their needs...<P>

It allows multiple sessions to be run (each on a pty)
on regular ASCII 
terminals (vt100 works best). Screen can be configured
to not drop 
these sessions when it terminates so they can be reattached
at a later 
time. It works like a champ. I don't know of an ftp
site but I'm sure 
it's on all the major GNU archives.<P>

Here's what it looks like.<P>
<PRE>
$ screen -?
Use: screen [-opts] [cmd [args]]
or: screen -r [host.tty]
</pre><p>
<p><B>Options:</B>
<PRE>
-a -- Force all capabilities into each window's termcap.

-A -[r|R] -- Adapt all windows to the new display width &amp; height.

-c file -- Read configuration file instead of '.screenrc'.

-d (-r) -- Detach the elsewhere running screen (and reattach here).

-D (-r) -- Detach and logout remote (and reattach here).

-e xy -- Change command characters.

-f -- Flow control on, -fn = off, -fa = auto.

-h -- lines Set the size of the scrollback history buffer.

-i -- Interrupt output sooner when flow control is on.

-l -- Login mode on (update /etc/utmp), -ln = off.

-list or -ls. -- Do nothing, just list our SockDir.

-L -- Terminal's last character can be safely updated.

-m -- ignore $STY variable, do create a new screen session.

-O -- Choose optimal output rather than exact vt100 emulation.

-q -- Quiet startup. Exits with non-zero return code if unsuccessful.

-r -- Reattach to a detached screen process.

-R -- Reattach if possible, otherwise start a new session.

-s -- shell Shell to execute rather than $SHELL.

-S sockname -- Name this session &lt;pid&gt;.sockname instead of &lt;pid&gt;.&lt;tty&gt;.&lt;host&gt;.

-t title -- Set command's a.k.a. (window title).

-T term -- Use term as $TERM for windows, rather than &quot;screen&quot;.

-v -- Print &quot;Screen version 3.05.00 (FAU) 22-Jul-93&quot;.

-wipe -- Do nothing, just clean up SockDir.

-x -- Attach to a not detached screen. (Multi display mode).
</pre><p>
<p>Chris Linstruth<br>
Capitol Heights, Maryland<br>
cjl@aop.com <P>

<I>This is one I'm not familiar with -- let's hope it does

the trick.</I><P>



Editor:<br>

In your November/December 1993 issue of Sys Admin, you
printed an 
article by Don Pipkin titled &quot;A Revised sudo: Managing
Super-User 
Privileges.&quot;<P>

I ftp-ed the source code from this article and was mildly
disappointed 
when it failed to work on our Pyramid MIServer-ES (running
SVR4). 
A cursory examination of the code showed that it was
not using the 
function calls that were created to handle the shadow
password file 
(/etc/shadow). I asked a colleague, Paul Ready, to add
in the corresponding 
functions, which he did. With those changes, together
with a couple 
of minor changes elsewhere, the code now compiles and
runs successfully 
on our Pyramid box.<P>

The code that Paul added tests the length of the password
field in 
/etc/passwd and, if it is not 13 chars long, calls the
shadow password 
functions. So this code works with both shadow and non-shadow
passwords.<P>

We have tested in on both the Pyramid (1.1-93c062 dcosx
MIServer-ES 
4/256 r3000) and under SCO Xenix 2.3.4.<P>

Because of the changes from tabs to spaces and back
again over the 
many transfers this source has had, the 'diff' between
the two versions 
does not help too much!, so, here is the whole source.<P>

Ben Thomas, P.Eng <br>
ben@ShoppersDrugMart.CA<P>

<I>Thanks for taking the time to investigate and solve

the problem. Interested readers will find the code in below.</I><P>

<b>Listing 1: new sudo.c, revised by Ben Thomas and Paul Ready</b>
<PRE>
/*
**   sudo.c
*/

/*
**   Configurable constants
*/

#define SECURE_PATH
&quot;/bin:/usr/sbin:/sbin:/usr/lbin:/opt/x25/bin/usr/bin/X11&quot;
#define USERFILE    &quot;/usr/local/adm/sudoers&quot;
#define LOGFILE     &quot;/usr/local/adm/sudolog&quot;
#define TIMEDIR     &quot;/usr/local/adm/sudocheck/&quot;
#define TIME         5 /* minutes */
#define SUDO_COP    &quot;root@localhost&quot;

/*
**   To install create the directories in the SECURE_PATH
**   and TIMEDIR and the files USERFILE and LOGFILE.
**   Set the owner of these files to root and the permissions
**   to og-rw.  Change the owner to root for the sudo program
**   and set the permissions to 4111 (--s--x--x).
*/

#define BUFSIZE  256
#define SUCCESS  1
#define FAILED  -1
#define CONFIG_ERR &quot;Configuration error.  &quot; \
&quot;Contact your security manager.&quot;
#define CONFIG_SUB &quot;Invalid sudo configuration!&quot;
#define SUID_ERR   &quot;Set UID bit not set.&quot;
#define STAT_ERR   &quot;Couldn't stat user file&quot;
#define OWNER_ERR  &quot;User file not owned by root&quot;
#define PERM_ERR   &quot;Invalid permissions on user file&quot;
#define OPEN_ERR   &quot;Couldn't open user file&quot;
#define USER_ERR   &quot;You are not set up to execute &quot; \
&quot;sudo on this machine.&quot;
#define USER_SUB   &quot;SECURITY**  Invalid sudo user!&quot;

#include &lt;ctype.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;pwd.h&gt;
#include &lt;signal.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;netdb.h&gt;
#include &lt;sys/file.h&gt;
#include &lt;sys/param.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;grp.h&gt;
#include &lt;shadow.h&gt;

char *getpass();
char *crypt();
char *find_passwd(int user_id);

FILE *check_config(user)
char *user;
{

struct stat statb;
FILE *fp;
if ((setuid(0)) &lt; 0) /* no setuid */
mail(CONFIG_SUB, user, SUID_ERR, CONFIG_ERR);
if (stat(USERFILE, &amp;statb))   /* couldn't stat */
mail(CONFIG_SUB, user, STAT_ERR, CONFIG_ERR);
if (statb.st_uid != 0) /* must be owned by root */
mail(CONFIG_SUB, user, OWNER_ERR, CONFIG_ERR);
if (statb.st_mode &amp; 044)   /* should be og-rw */
mail(CONFIG_SUB, user, PERM_ERR, CONFIG_ERR);
if ((fp = fopen(USERFILE, &quot;r&quot;)) == 0) /* open err */
mail(CONFIG_SUB, user, OPEN_ERR, CONFIG_ERR);
return(fp);
}

char *get_command_list(fp, name, password)
FILE *fp; char *name; char *password;
{
char buffer[BUFSIZ];
while ((fgets(buffer, BUFSIZ, fp)) != NULL) {
if (buffer[0] == '#') continue; /* skip remarks */

if ((strncmp(buffer, name, strlen(name))) == 0)
if ((get_password(name, password)) == SUCCESS)
return(buffer); /* valid user */
else
return(NULL); /* invalid password */
}
return(NULL); /* invalid user */
}

int get_password(name, password)
char *name; char *password;
{
char     fname[200];
char     *paswd;
char     *encrypted;
struct   stat stab;
sprintf (fname, &quot;%s/%s&quot;, TIMEDIR, name);
if (stat(fname, &amp;stab) == 0) {
if ((time(NULL) - stab.st_mtime) &lt; (TIME * 60)) {
create_file(fname);
return (SUCCESS);
}
}

paswd = getpass(&quot;Password:&quot;);
encrypted = crypt(paswd, password);
if (strcmp(password, encrypted)) {
fprintf (stderr, &quot;Password incorrect\n&quot;);
return(FAILED);
}

fflush (stderr);
fflush (stdout);
create_file(fname);
return (SUCCESS);
}

create_file(file)
char *file;
{
int      descrip;
long     timep[2];
if ((descrip = open(file, O_TRUNC|O_CREAT|O_WRONLY,  0700)) &gt; 0) {
close (descrip);
timep[0] = timep[1] = time(0);
utime (file, timep);
}
}

int checkdoer (dp, ap)
char *dp; char *ap;
{

char    *cp0, *cp1;
int not_flag = 0;
cp0 = dp;
while (isalnum (*cp0))
cp0++;  /* skip past user */
while (*cp0) {   /* search until end of line */
while (isspace (*cp0))
cp0++;   /* skip to cmd */
if (strncmp (cp0, &quot;not&quot;, 3) == 0)
not_flag = 1;
if (strncmp (cp0, &quot;all&quot;, 3) == 0)
return (SUCCESS);
cp1 = cp0;

/* find end of this entry */
while (*cp1 != '\n' &amp;&amp; !isspace(*cp1))
cp1++;
if (strncmp (cp0, ap, strlen(ap)) == 0) {
cp1 = '\0';
if (not_flag)
return(FAILED);
else
return(SUCCESS);
}

/* move pointer past and keep looking */
while (!isspace (*cp0) &amp;&amp; *cp0 != '\n')
cp0++;
if (*cp0 == '\n')
break;  /* if EOL then fail */
else
continue;
}

if (not_flag)
return(SUCCESS);
else
return(FAILED);
}

char *log(username, info, argc, argv)
char *username; char *info; int argc; char **argv;
{
FILE *fp;
long now;
char ret_st[BUFSIZ];
if ((fp = fopen(LOGFILE, &quot;a&quot;)) == NULL)
mail(&quot;WARNING sudo can't open logfile.&quot;, username,  LOGFILE,
&quot;&quot;);
now = time((long*) 0);
fprintf (fp, &quot;%20.20s :&quot;, ctime(&amp;now));
fprintf (fp, &quot;%10.10s&quot;, info);
fprintf (fp, &quot;%9.9s :&quot;,username);
while (argc--) {
fprintf (fp, &quot;%s &quot;, *argv++);
sprintf (ret_st, &quot;%s &quot;, *argv++);
}
fprintf (fp, &quot;\n&quot;);
(void) fclose (fp);
return(ret_st);
}

int mail(subject, user, text, err_msg)
char *subject; char *user; char *text; char *err_msg;
{
char hostname[MAXHOSTNAMELEN];
FILE *fd;
FILE *popen();
char cmd[80];
firsthostname (hostname, MAXHOSTNAMELEN);
(void) sprintf (cmd, &quot;/usr/bin/mailx  -s \&quot;%s\&quot; %s &quot;, subject,
SUDO_COP);
if ((fd = popen (cmd, &quot;w&quot;)) == NULL)
return;
(void) fputs(text, fd);
(void) fputs (&quot;\n\nThought you might want to know.&quot;, fd);
(void) pclose(fd);
fprintf(stderr, &quot;%s %s&quot;, err_msg, &quot;\n&quot;);
exit(1);
}

int firsthostname(n, l)
char *n; int l;
{
(void) gethostname(n, l); /* get full hostname */
n[l - 1] = 0;         /* make sure null terminated */
if (n = strchr(n,  '.'))
*n = 0; /* put null on '.'*/
}

int main(int argc, char **argv)
{
FILE *userfile;
struct passwd *user;
long uid;
char *valid_cmds;
char *progname;
char *cmd_line;
char *real_passwd;
progname = argv[0];
if (argc &lt; 2) {
fprintf(stderr, &quot;usage: %s cmd\n&quot;, progname);
exit(1);
}

uid = getuid();
user = getpwuid(uid);
userfile = check_config(user);
real_passwd = find_passwd(uid);
if ((valid_cmds = get_command_list(userfile, user-&gt;pw_name,
real_passwd)) != NULL) {
argv++, argc--;
if (checkdoer(valid_cmds, *argv) != FAILED) {
putenv(&quot;PATH=&quot; SECURE_PATH);
putenv(&quot;SHELL=/bin/false&quot;);
(void) log(user-&gt;pw_name, &quot;&quot;, argc, argv);
execvp(*argv, argv);   /* then do it */
perror(*argv);
} else {
(void) log(user-&gt;pw_name, &quot;FAIL &quot;, argc,  argv);
fprintf(stderr, &quot;%s: You are not set up to &quot;
&quot;execute %s with sudo on this machine.\n&quot;,
progname, *argv);
exit(1);
}
} else {
cmd_line = log(user-&gt;pw_name, &quot;FAIL &quot;, argc, argv);
mail(USER_SUB, user-&gt;pw_name, cmd_line, USER_ERR);
}
}

char *find_passwd(int user_id)
{
struct passwd *pw, *getpwuid();
struct group  *gr, *getgrgid();
struct spwd *spw, *getspnam();
if ((pw = getpwuid(user_id)) == NULL)
return(&quot;unknown&quot;);
if (strlen(pw-&gt;pw_passwd) == 13) {
if ((pw = getpwuid(user_id)) == NULL) {
return(&quot;unknown&quot;);
} else {
return(pw-&gt;pw_passwd);
}
} else {
if ((spw = getspnam(pw-&gt;pw_name)) == NULL) {
return(&quot;unknown&quot;);
} else {
return(spw-&gt;sp_pwdp);
}
}
return(&quot;unknown&quot;);
}
</pre><p>
<p>




<P><br>&nbsp;<br>
</table></center></td>
<! -- End Content ------ >

</table><!/center>
<! -- End MASTER TABLE -- >

</body></html>
